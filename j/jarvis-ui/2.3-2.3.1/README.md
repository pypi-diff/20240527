# Comparing `tmp/jarvis_ui-2.3-py3-none-any.whl.zip` & `tmp/jarvis_ui-2.3.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,41 @@
-Zip file size: 1083638 bytes, number of entries: 37
--rw-r--r--  2.0 unx      689 b- defN 23-Sep-10 05:42 jarvis_ui/__init__.py
--rw-r--r--  2.0 unx     2852 b- defN 23-Sep-10 05:42 jarvis_ui/main.py
--rw-r--r--  2.0 unx     2144 b- defN 23-Sep-10 05:42 jarvis_ui/test_listener.py
--rw-r--r--  2.0 unx     2553 b- defN 23-Sep-10 05:42 jarvis_ui/executables/api_handler.py
--rw-r--r--  2.0 unx     4352 b- defN 23-Sep-10 05:42 jarvis_ui/executables/audio_driver.py
--rw-r--r--  2.0 unx      779 b- defN 23-Sep-10 05:42 jarvis_ui/executables/display.py
--rw-r--r--  2.0 unx     2073 b- defN 23-Sep-10 05:42 jarvis_ui/executables/helper.py
--rw-r--r--  2.0 unx     2105 b- defN 23-Sep-10 05:42 jarvis_ui/executables/listener.py
--rw-r--r--  2.0 unx      541 b- defN 23-Sep-10 05:42 jarvis_ui/executables/speaker.py
--rw-r--r--  2.0 unx     8873 b- defN 23-Sep-10 05:42 jarvis_ui/executables/starter.py
--rw-r--r--  2.0 unx   103102 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/acknowledgement.wav
--rw-r--r--  2.0 unx   233690 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/connection_restart_mac.wav
--rw-r--r--  2.0 unx   226348 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/connection_restart_ss.wav
--rw-r--r--  2.0 unx   224084 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/connection_restart_win.wav
--rw-r--r--  2.0 unx   106902 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/failed_mac.wav
--rw-r--r--  2.0 unx    99372 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/failed_ss.wav
--rw-r--r--  2.0 unx   103858 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/failed_win.wav
--rw-r--r--  2.0 unx    58530 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/restart_mac.wav
--rw-r--r--  2.0 unx    48172 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/restart_ss.wav
--rw-r--r--  2.0 unx    59106 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/restart_win.wav
--rw-r--r--  2.0 unx    63820 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/shutdown_mac.wav
--rw-r--r--  2.0 unx    50220 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/shutdown_ss.wav
--rw-r--r--  2.0 unx    63736 b- defN 23-Sep-10 05:42 jarvis_ui/indicators/shutdown_win.wav
--rw-r--r--  2.0 unx     4276 b- defN 23-Sep-10 05:42 jarvis_ui/lib/install.sh
--rw-r--r--  2.0 unx      170 b- defN 23-Sep-10 05:42 jarvis_ui/lib/requirements.txt
--rw-r--r--  2.0 unx     3876 b- defN 23-Sep-10 05:42 jarvis_ui/modules/config.py
--rw-r--r--  2.0 unx     2379 b- defN 23-Sep-10 05:42 jarvis_ui/modules/exceptions.py
--rw-r--r--  2.0 unx     1454 b- defN 23-Sep-10 05:42 jarvis_ui/modules/logger.py
--rw-r--r--  2.0 unx     6416 b- defN 23-Sep-10 05:42 jarvis_ui/modules/models.py
--rw-r--r--  2.0 unx     1469 b- defN 23-Sep-10 05:42 jarvis_ui/modules/peripherals.py
--rw-r--r--  2.0 unx     1460 b- defN 23-Sep-10 05:42 jarvis_ui/modules/timer.py
--rwxr-xr-x  2.0 unx     4276 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.data/scripts/install.sh
--rw-r--r--  2.0 unx     1079 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.dist-info/LICENSE
--rw-r--r--  2.0 unx     9622 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3284 b- defN 23-Sep-10 05:42 jarvis_ui-2.3.dist-info/RECORD
-37 files, 1507764 bytes uncompressed, 1078368 bytes compressed:  28.5%
+Zip file size: 1084704 bytes, number of entries: 39
+-rw-r--r--  2.0 unx      635 b- defN 24-May-27 03:52 jarvis_ui/__init__.py
+-rw-r--r--  2.0 unx     2920 b- defN 24-May-27 03:52 jarvis_ui/main.py
+-rw-r--r--  2.0 unx     2145 b- defN 24-May-27 03:52 jarvis_ui/test_listener.py
+-rw-r--r--  2.0 unx     2474 b- defN 24-May-27 03:52 jarvis_ui/executables/api_handler.py
+-rw-r--r--  2.0 unx     2179 b- defN 24-May-27 03:52 jarvis_ui/executables/audio_driver.py
+-rw-r--r--  2.0 unx      801 b- defN 24-May-27 03:52 jarvis_ui/executables/display.py
+-rw-r--r--  2.0 unx     2072 b- defN 24-May-27 03:52 jarvis_ui/executables/helper.py
+-rw-r--r--  2.0 unx     2126 b- defN 24-May-27 03:52 jarvis_ui/executables/listener.py
+-rw-r--r--  2.0 unx      541 b- defN 24-May-27 03:52 jarvis_ui/executables/speaker.py
+-rw-r--r--  2.0 unx     9012 b- defN 24-May-27 03:52 jarvis_ui/executables/starter.py
+-rw-r--r--  2.0 unx   103102 b- defN 24-May-27 03:52 jarvis_ui/indicators/acknowledgement.wav
+-rw-r--r--  2.0 unx   233690 b- defN 24-May-27 03:52 jarvis_ui/indicators/connection_restart_mac.wav
+-rw-r--r--  2.0 unx   226348 b- defN 24-May-27 03:52 jarvis_ui/indicators/connection_restart_ss.wav
+-rw-r--r--  2.0 unx   224084 b- defN 24-May-27 03:52 jarvis_ui/indicators/connection_restart_win.wav
+-rw-r--r--  2.0 unx   106902 b- defN 24-May-27 03:52 jarvis_ui/indicators/failed_mac.wav
+-rw-r--r--  2.0 unx    99372 b- defN 24-May-27 03:52 jarvis_ui/indicators/failed_ss.wav
+-rw-r--r--  2.0 unx   103858 b- defN 24-May-27 03:52 jarvis_ui/indicators/failed_win.wav
+-rw-r--r--  2.0 unx    58530 b- defN 24-May-27 03:52 jarvis_ui/indicators/restart_mac.wav
+-rw-r--r--  2.0 unx    48172 b- defN 24-May-27 03:52 jarvis_ui/indicators/restart_ss.wav
+-rw-r--r--  2.0 unx    59106 b- defN 24-May-27 03:52 jarvis_ui/indicators/restart_win.wav
+-rw-r--r--  2.0 unx    63820 b- defN 24-May-27 03:52 jarvis_ui/indicators/shutdown_mac.wav
+-rw-r--r--  2.0 unx    50220 b- defN 24-May-27 03:52 jarvis_ui/indicators/shutdown_ss.wav
+-rw-r--r--  2.0 unx    63736 b- defN 24-May-27 03:52 jarvis_ui/indicators/shutdown_win.wav
+-rwxr-xr-x  2.0 unx     5487 b- defN 24-May-27 03:52 jarvis_ui/lib/install.sh
+-rw-r--r--  2.0 unx      145 b- defN 24-May-27 03:52 jarvis_ui/lib/requirements.txt
+-rw-r--r--  2.0 unx     1666 b- defN 24-May-27 03:52 jarvis_ui/lib/squire/detector.sh
+-rw-r--r--  2.0 unx     3910 b- defN 24-May-27 03:52 jarvis_ui/modules/config.py
+-rw-r--r--  2.0 unx     2043 b- defN 24-May-27 03:52 jarvis_ui/modules/exceptions.py
+-rw-r--r--  2.0 unx     1498 b- defN 24-May-27 03:52 jarvis_ui/modules/logger.py
+-rw-r--r--  2.0 unx     6702 b- defN 24-May-27 03:52 jarvis_ui/modules/models.py
+-rw-r--r--  2.0 unx     1541 b- defN 24-May-27 03:52 jarvis_ui/modules/peripherals.py
+-rw-r--r--  2.0 unx     1498 b- defN 24-May-27 03:52 jarvis_ui/modules/timer.py
+-rwxr-xr-x  2.0 unx     1666 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.data/scripts/detector.sh
+-rwxr-xr-x  2.0 unx     5487 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.data/scripts/install.sh
+-rw-r--r--  2.0 unx     1068 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9662 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3482 b- defN 24-May-27 03:52 jarvis_ui-2.3.1.dist-info/RECORD
+39 files, 1511802 bytes uncompressed, 1079114 bytes compressed:  28.6%
```

## zipnote {}

```diff
@@ -69,14 +69,17 @@
 
 Filename: jarvis_ui/lib/install.sh
 Comment: 
 
 Filename: jarvis_ui/lib/requirements.txt
 Comment: 
 
+Filename: jarvis_ui/lib/squire/detector.sh
+Comment: 
+
 Filename: jarvis_ui/modules/config.py
 Comment: 
 
 Filename: jarvis_ui/modules/exceptions.py
 Comment: 
 
 Filename: jarvis_ui/modules/logger.py
@@ -87,26 +90,29 @@
 
 Filename: jarvis_ui/modules/peripherals.py
 Comment: 
 
 Filename: jarvis_ui/modules/timer.py
 Comment: 
 
-Filename: jarvis_ui-2.3.data/scripts/install.sh
+Filename: jarvis_ui-2.3.1.data/scripts/detector.sh
+Comment: 
+
+Filename: jarvis_ui-2.3.1.data/scripts/install.sh
 Comment: 
 
-Filename: jarvis_ui-2.3.dist-info/LICENSE
+Filename: jarvis_ui-2.3.1.dist-info/LICENSE
 Comment: 
 
-Filename: jarvis_ui-2.3.dist-info/METADATA
+Filename: jarvis_ui-2.3.1.dist-info/METADATA
 Comment: 
 
-Filename: jarvis_ui-2.3.dist-info/WHEEL
+Filename: jarvis_ui-2.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: jarvis_ui-2.3.dist-info/top_level.txt
+Filename: jarvis_ui-2.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: jarvis_ui-2.3.dist-info/RECORD
+Filename: jarvis_ui-2.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## jarvis_ui/__init__.py

```diff
@@ -1,20 +1,24 @@
 import os
 
-version = "2.3"
+version = "2.3.1"
 
-install_script = os.path.join(os.path.dirname(__file__), 'lib', 'install.sh')
+install_script = os.path.join(os.path.dirname(__file__), "lib", "install.sh")
 
 try:
-    import pvporcupine  # noqa: F401
-    import pyaudio  # noqa: F401
-    import pynotification  # noqa: F401
+    import pynotification
+
+    from .main import start  # noqa: F401
 except ImportError as error:
     try:
-        pynotification.pynotifier(title="First time user?", dialog=True, message=f"Please run\n\n{install_script}")
+        pynotification.pynotifier(
+            title="First time user?",
+            dialog=True,
+            message=f"Please run\n\n{install_script}",
+        )
     except NameError:
         pass
-    raise UserWarning(f"{error.__str__()}\n\nPlease run\n\n{install_script}\n\n"
-                      "Note: Shell script will quit for any non-zero exit status, "
-                      "so it might have to be triggered twice.")
-else:
-    from .main import start  # noqa: F401
+    raise UserWarning(
+        f"{error.__str__()}\n\nPlease run\n\n{install_script}\n\n"
+        "Note: Shell script will quit for any non-zero exit status, "
+        "so it might have to be triggered twice."
+    )
```

## jarvis_ui/main.py

```diff
@@ -8,17 +8,22 @@
 
 def initiator(status_manager: DictProxy = None) -> None:
     """Starts main process to activate Jarvis and process requests via API calls."""
     from jarvis_ui.executables.helper import heart_beat
     from jarvis_ui.executables.starter import Activator
     from jarvis_ui.modules.models import env
     from jarvis_ui.modules.timer import RepeatedTimer
+
     if env.heart_beat:
-        logger.info("Initiating heart beat with an interval of %d seconds", env.heart_beat)
-        timer = RepeatedTimer(function=heart_beat, interval=env.heart_beat, args=(status_manager,))
+        logger.info(
+            "Initiating heart beat with an interval of %d seconds", env.heart_beat
+        )
+        timer = RepeatedTimer(
+            function=heart_beat, interval=env.heart_beat, args=(status_manager,)
+        )
         timer.start()
     else:
         timer = None
     activator = Activator()
     try:
         if status_manager:
             status_manager["LOCKED"] = False
@@ -35,29 +40,32 @@
 
     Args:
         process: Takes the process object as an argument.
     """
     logger.info("Terminating %s [%d]", process.name, process.pid)
     process.terminate()
     if process.is_alive():
-        logger.warning("Process %s [%d] is still alive. Killing it.", process.name, process.pid)
+        logger.warning(
+            "Process %s [%d] is still alive. Killing it.", process.name, process.pid
+        )
         process.kill()
         process.join(timeout=1e-01)
         try:
             logger.info("Closing process: %s [%d]", process.name, process.pid)
             process.close()  # Close immediately instead of waiting to be garbage collected
         except ValueError as error:
             # Expected when join timeout is insufficient. The resources will be released eventually but not immediately.
             logger.error(error)
 
 
 def start() -> None:
     """Initiates Jarvis as a child process."""
     # Import within a function to be called repeatedly
     from jarvis_ui.modules.models import env, settings  # noqa: F401
+
     if settings.operating_system == "Linux":
         initiator()
         return
     status_manager = Manager().dict()
     status_manager["LOCKED"] = False  # Instantiate DictProxy
     process = Process(target=initiator, args=(status_manager,))
     process.name = pathlib.Path(__file__).stem
```

## jarvis_ui/test_listener.py

```diff
@@ -5,52 +5,63 @@
 import yaml
 
 logger = logging.getLogger(__name__)
 logger.setLevel(logging.DEBUG)
 logger.addHandler(logging.StreamHandler())
 
 RECOGNIZER = speech_recognition.Recognizer()
-ERROR_TUPLE = speech_recognition.UnknownValueError, speech_recognition.RequestError, \
-    speech_recognition.WaitTimeoutError, TimeoutError, ConnectionError,
-
-defaults = dict(energy_threshold=RECOGNIZER.energy_threshold,
-                dynamic_energy_threshold=RECOGNIZER.dynamic_energy_threshold,
-                pause_threshold=RECOGNIZER.pause_threshold,
-                phrase_threshold=RECOGNIZER.phrase_threshold)
+ERROR_TUPLE = (
+    speech_recognition.UnknownValueError,
+    speech_recognition.RequestError,
+    speech_recognition.WaitTimeoutError,
+    TimeoutError,
+    ConnectionError,
+)
+
+defaults = dict(
+    energy_threshold=RECOGNIZER.energy_threshold,
+    dynamic_energy_threshold=RECOGNIZER.dynamic_energy_threshold,
+    pause_threshold=RECOGNIZER.pause_threshold,
+    phrase_threshold=RECOGNIZER.phrase_threshold,
+)
 
 RECOGNIZER.energy_threshold = 1100
 RECOGNIZER.pause_threshold = 1
 RECOGNIZER.phrase_threshold = 0.1
 RECOGNIZER.dynamic_energy_threshold = False
 RECOGNIZER.non_speaking_duration = 1
 
-changed = dict(energy_threshold=RECOGNIZER.energy_threshold,
-               dynamic_energy_threshold=RECOGNIZER.dynamic_energy_threshold,
-               pause_threshold=RECOGNIZER.pause_threshold,
-               phrase_threshold=RECOGNIZER.phrase_threshold)
+changed = dict(
+    energy_threshold=RECOGNIZER.energy_threshold,
+    dynamic_energy_threshold=RECOGNIZER.dynamic_energy_threshold,
+    pause_threshold=RECOGNIZER.pause_threshold,
+    phrase_threshold=RECOGNIZER.phrase_threshold,
+)
 
 
 async def save_for_reference():
     """Saves the original config and new config in a yaml file."""
-    with open('speech_recognition_values.yaml', 'w') as file:
+    with open("speech_recognition_values.yaml", "w") as file:
         yaml.dump(data={"defaults": defaults, "modified": changed}, stream=file)
 
 
 async def main():
     """Initiates yaml dump in an asynchronous call and initiates listener in a never ending loop."""
     asyncio.create_task(save_for_reference())
     with speech_recognition.Microphone() as source:
         while True:
             try:
-                logger.info('Listening..')
+                logger.info("Listening..")
                 audio = RECOGNIZER.listen(source)
-                logger.info('Recognizing..')
-                recognized = RECOGNIZER.recognize_google(audio_data=audio)  # Requires stable internet connection
+                logger.info("Recognizing..")
+                recognized = RECOGNIZER.recognize_google(
+                    audio_data=audio
+                )  # Requires stable internet connection
                 # recognized = RECOGNIZER.recognize_sphinx(audio_data=audio)  # Requires pocketsphinx module
                 if "stop" in recognized.lower().split():
                     break
             except ERROR_TUPLE:
                 continue
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     asyncio.run(main())
```

## jarvis_ui/executables/api_handler.py

```diff
@@ -45,41 +45,43 @@
         """
         request.headers["authorization"] = "Bearer " + self.token
         return request
 
 
 session = requests.Session()
 session.auth = BearerAuth(token=env.token)
-session.headers['Accept'] = 'application/json'
+session.headers["Accept"] = "application/json"
 
 
-def make_request(path: str, data: dict = None, method: str = 'POST') -> Union[dict, bool]:
+def make_request(
+    path: str, data: dict = None, method: str = "POST"
+) -> Union[dict, bool]:
     """Makes a requests call to the API running on the backend to execute a said task.
 
     Args:
         data: Takes the command to be executed as an argument.
         path: Path to make the api call.
         method: HTTP methods, GET/POST.
 
     Returns:
         dict:
         Returns the JSON response if request was successful.
     """
     try:
-        if method == 'POST':
-            response = session.post(url=env.request_url + path, json=data, timeout=(3, 30))
-        else:
-            response = session.get(url=env.request_url + path, json=data, timeout=(3, 30))
+        response = session.request(
+            method, env.server_url + path, json=data, timeout=(3, 30)
+        )
     except requests.RequestException as error:
         logger.error(error)
         return False
     if not response.ok:
         logger.error("%d - %s", response.status_code, response.reason)
         return False
     if response.headers.get("Content-Type", "NO MATCH") == "application/octet-stream":
         with open(file=fileio.speech_wav_file, mode="wb") as file:
             file.write(response.content)
+            file.flush()
         return True
     try:
         return response.json()
     except json.JSONDecodeError as error:
         logger.error(error)
```

## jarvis_ui/executables/audio_driver.py

```diff
@@ -1,22 +1,15 @@
-import importlib
 import pathlib
-import subprocess
-from multiprocessing import current_process
-from threading import Thread
-from typing import Dict
 
 import pyttsx3
 
-from jarvis_ui.modules.exceptions import InvalidEnvVars, SegmentationError
+from jarvis_ui.modules.exceptions import InvalidEnvVars
 from jarvis_ui.modules.logger import logger
 from jarvis_ui.modules.models import env, fileio, settings
 
-module: Dict[str, pyttsx3.Engine] = {}
-
 
 def reload_static_files() -> None:
     """Iterates through ``FileIO`` objects and converts all preloaded audio files to speech-synthesis audio files."""
     extn = fileio.extn_[settings.operating_system]
     if extn == "ss":
         return
     for key, value in fileio.__dict__.items():
@@ -25,87 +18,40 @@
             value = value.replace(f"{extn}.wav", "ss.wav")
             # because playaudio in Windows uses string concatenation assuming input sound is going to be a string
             if settings.operating_system != "Windows":
                 value = pathlib.PosixPath(value)
             setattr(fileio, key, value)
 
 
-def import_module() -> None:
-    """Instantiates pyttsx3 after importing ``nsss`` drivers beforehand."""
-    if settings.operating_system == "Darwin":
-        importlib.import_module("pyttsx3.drivers.nsss")
-    module['pyttsx3'] = pyttsx3.init()
-
-
-def get_driver() -> pyttsx3.Engine:
-    """Get audio driver by instantiating pyttsx3.
-
-    Returns:
-        pyttsx3.Engine:
-        Audio driver.
-    """
-    try:
-        subprocess.run(["python3", "-c", "import pyttsx3; pyttsx3.init()"], check=True)
-    except subprocess.CalledProcessError as error:
-        if error.returncode == -11:  # Segmentation fault error code
-            if current_process().name == "MainProcess":
-                print(f"\033[91mERROR:{'':<6}Segmentation fault when loading audio driver "
-                      "(interrupted by signal 11: SIGSEGV)\033[0m")
-                print(f"\033[93mWARNING:{'':<4}Trying alternate solution...\033[0m")
-            thread = Thread(target=import_module)
-            thread.start()
-            thread.join(timeout=10)
-            if module.get('pyttsx3'):
-                if current_process().name == "MainProcess":
-                    print(f"\033[92mINFO:{'':<7}Instantiated audio driver successfully\033[0m")
-                return module['pyttsx3']
-            else:
-                raise SegmentationError(
-                    "Segmentation fault when loading audio driver (interrupted by signal 11: SIGSEGV)"
-                )
-        else:
-            return pyttsx3.init()
-    else:
-        return pyttsx3.init()
-
-
 def instantiate_audio_driver() -> pyttsx3.Engine:
     """Instantiates the audio driver and sets voice.
 
     Returns:
         pyttsx3.Engine:
         Returns instance of audio engine.
     """
-    try:
-        if settings.operating_system == "Windows":
-            driver = pyttsx3.init()
-        else:
-            driver = get_driver()
-        voices = driver.getProperty("voices")  # gets the list of voices available
-        voice_names = [__voice.name for __voice in voices]
-        if not env.voice_name:
-            if settings.operating_system == "Darwin":
-                env.voice_name = "Daniel"
-            elif settings.operating_system == "Windows":
-                env.voice_name = "David"
-            elif settings.operating_system == "Linux":
-                env.voice_name = "english-us"
-        elif env.voice_name not in voice_names:
-            raise InvalidEnvVars(
-                f"\n\nVoice name {env.voice_name!r} is not available.\nAvailable voices:\n\t{', '.join(voice_names)}"
-            )
-        for ind_d, voice in enumerate(voices):
-            if voice.name == env.voice_name:
-                logger.debug(voice.__dict__)
-                driver.setProperty("voice", voices[ind_d].id)
-                if env.voice_rate:
-                    driver.setProperty("rate", env.voice_rate)
-                if env.voice_pitch:
-                    driver.setProperty("pitch", env.voice_pitch)
-                break
-        else:
-            logger.info("Using default voice model.")
-        return driver
-    except (SegmentationError, Exception):  # resolve to speech-synthesis
-        env.speech_timeout = 10
-        reload_static_files()
-        logger.warning("Failed to load the audio driver. Resolving to use SpeechSynthesis")
+    driver = pyttsx3.init()
+    voices = driver.getProperty("voices")  # gets the list of voices available
+    voice_names = [__voice.name for __voice in voices]
+    if not env.voice_name:
+        if settings.operating_system == "Darwin":
+            env.voice_name = "Daniel"
+        elif settings.operating_system == "Windows":
+            env.voice_name = "David"
+        elif settings.operating_system == "Linux":
+            env.voice_name = "english-us"
+    elif env.voice_name not in voice_names:
+        raise InvalidEnvVars(
+            f"\n\nVoice name {env.voice_name!r} is not available.\nAvailable voices:\n\t{', '.join(voice_names)}"
+        )
+    for ind_d, voice in enumerate(voices):
+        if voice.name == env.voice_name:
+            logger.debug(voice.__dict__)
+            driver.setProperty("voice", voices[ind_d].id)
+            if env.voice_rate:
+                driver.setProperty("rate", env.voice_rate)
+            if env.voice_pitch:
+                driver.setProperty("pitch", env.voice_pitch)
+            break
+    else:
+        logger.info("Using default voice model.")
+    return driver
```

## jarvis_ui/executables/display.py

```diff
@@ -26,10 +26,12 @@
     """Flushes the screen output.
 
     See Also:
         - Writes white spaces to the window size in a terminal.
         - Writes recursive empty text in IDE to flush screen.
     """
     if models.settings.interactive:
-        sys.stdout.write(f"\r{' '.join(['' for _ in range(os.get_terminal_size().columns)])}")
+        sys.stdout.write(
+            f"\r{' '.join(['' for _ in range(os.get_terminal_size().columns)])}"
+        )
     else:
         sys.stdout.write("\r")
```

## jarvis_ui/executables/helper.py

```diff
@@ -4,55 +4,55 @@
 from typing import NoReturn
 
 import requests
 
 from jarvis_ui.modules.logger import logger
 from jarvis_ui.modules.models import env, settings
 
-FAILED_HEALTH_CHECK = {'count': 0}
+FAILED_HEALTH_CHECK = {"count": 0}
 
 
 def linux_restart() -> NoReturn:
     """Restarts the base script on Linux OS.
 
     See Also:
         - In Linux, it is not possible to trigger port audio on multiple processes.
         - To overcome this problem, JarvisUI on Linux is set to restart from self.
         - Since restarting executable triggers the base script, explicit reload of env vars are not required.
 
     Raises:
         - KeyboardInterrupt: To stop the current process to avoid recursion.
     """
-    os.execv(sys.executable, ['python'] + sys.argv)
+    os.execv(sys.executable, ["python"] + sys.argv)
     raise KeyboardInterrupt
 
 
 def heart_beat(status_manager: DictProxy = None) -> None:
     """Initiate health check with the server.
 
     Args:
         status_manager: Shared multiprocessing dict to update in case of failed health check.
 
     See Also:
         - Heart beat should be set no lesser than 5 seconds to avoid throttling and no longer than an hour.
         - Maintains a consecutive failure threshold of 5, as a single failed health check doesn't warrant a restart.
     """
     try:
-        response = requests.get(url=env.request_url + 'health', timeout=(3, 3))
+        response = requests.get(url=env.server_url + "health", timeout=(3, 3))
     except requests.RequestException as error:
         logger.error(error)
     else:
         if response.ok:
-            if FAILED_HEALTH_CHECK['count']:
+            if FAILED_HEALTH_CHECK["count"]:
                 logger.info("Resetting failure count")
-                FAILED_HEALTH_CHECK['count'] = 0
+                FAILED_HEALTH_CHECK["count"] = 0
             return
-    FAILED_HEALTH_CHECK['count'] += 1
-    if FAILED_HEALTH_CHECK['count'] >= 5:
+    FAILED_HEALTH_CHECK["count"] += 1
+    if FAILED_HEALTH_CHECK["count"] >= 5:
         while True:
             # Awaits any ongoing request/response to go through before restarting
             if not status_manager["LOCKED"]:
                 break
         logger.critical("Heart beat failed for 5 times in row, restarting...")
         if settings.operating_system == "Linux":
             linux_restart()
-        status_manager['LOCKED'] = None
+        status_manager["LOCKED"] = None
```

## jarvis_ui/executables/listener.py

```diff
@@ -5,16 +5,21 @@
 
 """
 
 from typing import Union
 
 import requests
 from pydantic import PositiveFloat, PositiveInt
-from speech_recognition import (Microphone, Recognizer, RequestError,
-                                UnknownValueError, WaitTimeoutError)
+from speech_recognition import (
+    Microphone,
+    Recognizer,
+    RequestError,
+    UnknownValueError,
+    WaitTimeoutError,
+)
 
 from jarvis_ui.executables import display
 from jarvis_ui.modules.logger import logger
 from jarvis_ui.modules.models import env
 
 recognizer = Recognizer()  # initiates recognizer object
 microphone = Microphone()  # initiates microphone object
@@ -22,31 +27,35 @@
 recognizer.energy_threshold = env.recognizer_settings.energy_threshold
 recognizer.pause_threshold = env.recognizer_settings.pause_threshold
 recognizer.phrase_threshold = env.recognizer_settings.phrase_threshold
 recognizer.dynamic_energy_threshold = env.recognizer_settings.dynamic_energy_threshold
 recognizer.non_speaking_duration = env.recognizer_settings.non_speaking_duration
 
 
-def listen(timeout: Union[PositiveInt, PositiveFloat] = env.listener_timeout,
-           phrase_time_limit: Union[PositiveInt, PositiveFloat] = env.listener_phrase_limit) -> Union[str, None]:
+def listen(
+    timeout: Union[PositiveInt, PositiveFloat] = env.listener_timeout,
+    phrase_time_limit: Union[PositiveInt, PositiveFloat] = env.listener_phrase_limit,
+) -> Union[str, None]:
     """Function to activate listener and get the user input.
 
     Args:
         timeout: Time in seconds to wait for a phrase/sound to begin.
         phrase_time_limit: Time in seconds to await user input. Anything spoken beyond this limit will be excluded.
 
     Returns:
         str:
         Returns the recognized statement listened via microphone.
     """
     return_val = None
     with microphone as source:
         display.write_screen(f"Listener activated [{timeout}: {phrase_time_limit}]")
         try:
-            listened = recognizer.listen(source=source, timeout=timeout, phrase_time_limit=phrase_time_limit)
+            listened = recognizer.listen(
+                source=source, timeout=timeout, phrase_time_limit=phrase_time_limit
+            )
             return_val = recognizer.recognize_google(audio_data=listened)
         except (UnknownValueError, WaitTimeoutError, RequestError) as error:
             logger.debug(error)
         except requests.exceptions.RequestException as error:
             logger.error(error)
         display.flush_screen()
         return return_val
```

## jarvis_ui/executables/speaker.py

```diff
@@ -12,12 +12,12 @@
 
 def speak(text: str) -> None:
     """Speak the received text using audio driver.
 
     Args:
         text: Takes the text that has to be spoken as an argument.
     """
-    text = text.replace('\n', '\t').strip()
-    if not text.endswith('.') or not text.endswith('!'):
-        text = text + '!'
+    text = text.replace("\n", "\t").strip()
+    if not text.endswith(".") or not text.endswith("!"):
+        text = text + "!"
     driver.say(text=text)
     driver.runAndWait()
```

## jarvis_ui/executables/starter.py

```diff
@@ -20,15 +20,17 @@
 from jarvis_ui.executables import display, listener, speaker
 from jarvis_ui.executables.api_handler import make_request
 from jarvis_ui.executables.helper import linux_restart
 from jarvis_ui.modules.config import config
 from jarvis_ui.modules.logger import logger
 from jarvis_ui.modules.models import env, fileio, settings
 
-assert speaker.driver or env.speech_timeout, "Cannot proceed without both audio drivers and speech timeout."
+assert (
+    speaker.driver or env.speech_timeout
+), "Cannot proceed without both audio drivers and speech timeout."
 
 
 def process_request(phrase: str) -> Union[str, None]:
     """Process request from the user.
 
     Args:
         phrase: Takes the phrase spoken as an argument.
@@ -53,23 +55,29 @@
         logger.warning("keywords are not loaded yet, restarting")
         if os.path.isfile("failed_command"):
             logger.critical("Consecutive failure")
             os.remove("failed_command")
         else:
             with open("failed_command", "w") as file:
                 file.write(phrase)
+                file.flush()
             playsound(sound=fileio.connection_restart)
         display.write_screen("Trying to re-establish connection with Server...")
         return "RESTART"
     if os.path.isfile("failed_command"):
         logger.info("Recovered after a recent failure, deleting placeholder file.")
         os.remove("failed_command")
-    if response := make_request(path='offline-communicator',
-                                data={'command': phrase, 'native_audio': env.native_audio,
-                                      'speech_timeout': env.speech_timeout}):
+    if response := make_request(
+        path="offline-communicator",
+        data={
+            "command": phrase,
+            "native_audio": env.native_audio,
+            "speech_timeout": env.speech_timeout,
+        },
+    ):
         process_response(response)
     else:
         playsound(sound=fileio.failed)
         return "RESTART"
 
 
 def process_response(response: Union[dict, bool]) -> None:
@@ -79,26 +87,28 @@
         response: Takes either a boolean flag or a dictionary from the server as an argument.
     """
     if response is True:
         logger.info("Response received as audio.")
         display.write_screen("Response received as audio.")
         # Because Windows runs into PermissionError if audio file is open when file is removed
         if settings.operating_system == "Windows":
-            player = Process(target=playsound, kwargs={'sound': fileio.speech_wav_file})
+            player = Process(target=playsound, kwargs={"sound": fileio.speech_wav_file})
             player.start()
             player.join()
             if player.is_alive():
                 player.terminate()
                 player.kill()
-            Timer(interval=3, function=os.remove, args=(fileio.speech_wav_file,)).start()
+            Timer(
+                interval=3, function=os.remove, args=(fileio.speech_wav_file,)
+            ).start()
         else:
             playsound(sound=fileio.speech_wav_file)
             os.remove(fileio.speech_wav_file)
         return
-    response = response.get('detail', '')
+    response = response.get("detail", "")
     logger.info("Response: %s", response)
     display.write_screen(f"Response: {response}")
     speaker.speak(text=response)
 
 
 def processor(phrase: str = None, status_manager: DictProxy = None) -> None:
     """Handles request and response.
@@ -140,28 +150,32 @@
         References:
             - `Audio Overflow <https://people.csail.mit.edu/hubert/pyaudio/docs/#pyaudio.Stream.read>`__ handling.
         """
         keyword_paths = [pvporcupine.KEYWORD_PATHS[x] for x in env.wake_words]
         self.py_audio = PyAudio()
         arguments = {
             "library_path": pvporcupine.LIBRARY_PATH,
-            "sensitivities": env.sensitivity
+            "sensitivities": env.sensitivity,
         }
         if settings.legacy:
             arguments["keywords"] = env.wake_words
             arguments["model_file_path"] = pvporcupine.MODEL_PATH
             arguments["keyword_file_paths"] = keyword_paths
         else:
             arguments["model_path"] = pvporcupine.MODEL_PATH
             arguments["keyword_paths"] = keyword_paths
 
         self.detector = pvporcupine.create(**arguments)
         self.audio_stream = self.open_stream()
-        label = ', '.join([f'{string.capwords(wake)!r}: {sens}' for wake, sens in
-                           zip(env.wake_words, env.sensitivity)])
+        label = ", ".join(
+            [
+                f"{string.capwords(wake)!r}: {sens}"
+                for wake, sens in zip(env.wake_words, env.sensitivity)
+            ]
+        )
         self.label = f"Awaiting: [{label}]"
 
     def at_exit(self) -> None:
         """Invoked when the run loop is exited or manual interrupt.
 
         See Also:
             - Releases resources held by porcupine.
@@ -183,15 +197,15 @@
         """
         return self.py_audio.open(
             rate=self.detector.sample_rate,
             channels=1,
             format=paInt16,
             input=True,
             frames_per_buffer=self.detector.frame_length,
-            input_device_index=env.microphone_index
+            input_device_index=env.microphone_index,
         )
 
     def executor(self, status_manager: DictProxy = None):
         """Closes the audio stream and calls the processor."""
         if status_manager:
             status_manager["LOCKED"] = True
             logger.debug("Restart locked")
@@ -214,14 +228,18 @@
         if os.path.isfile("failed_command"):
             with open("failed_command") as file:
                 existing = file.read().strip()
             processor(phrase=existing, status_manager=status_manager)
         display.write_screen(self.label)
         while True:
             result = self.detector.process(
-                pcm=struct.unpack_from("h" * self.detector.frame_length,
-                                       self.audio_stream.read(num_frames=self.detector.frame_length,
-                                                              exception_on_overflow=False))
+                pcm=struct.unpack_from(
+                    "h" * self.detector.frame_length,
+                    self.audio_stream.read(
+                        num_frames=self.detector.frame_length,
+                        exception_on_overflow=False,
+                    ),
+                )
             )
             if result is False or result < 0:
                 continue
             self.executor(status_manager=status_manager)
```

## jarvis_ui/lib/install.sh

```diff
@@ -1,88 +1,116 @@
 #!/bin/bash
+# 'set -e' stops the execution of a script if a command or pipeline has an error.
+# This is the opposite of the default shell behaviour, which is to ignore errors in scripts.
+set -e
+
+# defaults
+osname=""
+architecture=""
+
+# Get to the current directory
+current_dir="$(dirname "$(realpath "$0")")"
+export current_dir=$current_dir
+source "$current_dir/squire/detector.sh"
+
+if ! [ -x "$(command -v python)" ] && ! [ -x "$(command -v python3)" ]; then
+  echo -e '\n***************************************************************************************************'
+  echo "                       Neither 'python' nor 'python3' command found!!"
+  echo "                      Please install 'python' 3.8 to 3.11 to proceed!!"
+  echo -e '***************************************************************************************************\n'
+  exit 1
+fi
+
+if ! [ -x "$(command -v python)" ]; then
+  alias python=python3
+fi
 
-OSName=$(UNAME)
 ver=$(python -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")
 echo_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
 
 echo -e '\n***************************************************************************************************'
-echo "                               $OSName running python $echo_ver"
+echo "                            $osname-$architecture running python $echo_ver"
 echo -e '***************************************************************************************************\n'
 
 if [ "$ver" -ge 38 ] && [ "$ver" -le 311 ]; then
-  pyaudio="PyAudio-0.2.11-cp$ver-cp$ver-win_amd64.whl"
+  # Upgrades pip, setuptools and wheel
+  python -m pip install --upgrade pip setuptools wheel
 else
   echo "Python version $echo_ver is unsupported for Jarvis. Please use any python version between 3.8.* and 3.11.*"
   exit
 fi
 
+current_dir="$(dirname "$(realpath "$0")")"
+
 # Upgrades pip module
 python -m pip install --upgrade pip
 
 os_independent_packages() {
     # Get to the current directory and install the module specific packages from requirements.txt
-    current_dir="$(dirname "$(realpath "$0")")"
     python -m pip install --no-cache-dir -r "$current_dir"/requirements.txt
 }
 
-if [[ "$OSName" == "Darwin" ]]; then
+if [[ "$osname" == "darwin" ]]; then
+    echo -e '\n***************************************************************************************************'
+    echo "                             Installing dependencies specific to macOS"
+    echo -e '***************************************************************************************************\n'
+
     # Looks for xcode installation and installs only if xcode is not found already
     which xcodebuild > tmp_xcode && xcode_check=$(cat tmp_xcode) && rm tmp_xcode
-    if  [[ "$xcode_check" == "/usr/bin/xcodebuild" ]] || [[ $HOST == "/*" ]] ; then
-        xcode_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version)
-        echo "xcode $xcode_version"
+    if [[ "$xcode_check" == "/usr/bin/xcodebuild" ]] || [[ $HOST == "/*" ]]; then
+      xcode_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version)
+      echo "xcode $xcode_version"
     else
-        echo "Installing xcode"
-        xcode-select --install
+      echo "Installing xcode"
+      xcode-select --install
     fi
 
     # Looks for brew installation and installs only if brew is not found
-    brew_check=$(which brew)
-    if [[ "$brew_check" == "/usr/local/bin/brew" ]] || [[ "$brew_check" == "/usr/bin/brew" ]]; then
-        brew -v > tmp_brew && brew_version=$(head -n 1 tmp_brew) && rm tmp_brew
-        echo "$brew_version"
-    else
-        echo "Installing Homebrew"
-        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
+    if ! [ -x "$(command -v brew)" ]; then
+      echo "Installing Homebrew"
+      /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
     fi
+    brew -v > tmp_brew && brew_version=$(head -n 1 tmp_brew) && rm tmp_brew
+    echo "$brew_version"
+    # Packages installed using homebrew
     brew install portaudio coreutils
-    python -m pip install PyAudio==0.2.13 playsound==1.3.0
+    python -m pip install playsound==1.3.0
 
     # Checks current version and installs legacy pvporcupine version if macOS is older han 10.14
     base_ver="10.14"
     os_ver=$(sw_vers | grep ProductVersion | cut -d':' -f2 | tr -d ' ')
     if awk "BEGIN {exit !($base_ver > $os_ver)}"; then
       pip install 'pvporcupine==1.6.0'
     else
       pip install 'pvporcupine==1.9.5'
     fi
     os_independent_packages
-elif [[ "$OSName" == MSYS* ]]; then
+elif [[ "$osname" == "windows" ]]; then
     conda install portaudio=19.6.0
-    # PyAudio wheel files original source:
-    # https://www.lfd.uci.edu/~gohlke/pythonlibs/#:~:text=PyAudio:%20bindings%20for%20the%20PortAudio%20library
-    curl https://vigneshrao.com/Jarvis/"$pyaudio" --output "$pyaudio" --silent
-    pip install "$pyaudio"
-    rm "$pyaudio"
     pip install pvporcupine==1.9.5 pywin32==305 playsound==1.2.2
     os_independent_packages
-elif [[ "$OSName" == "Linux" ]]; then
+elif [[ "$osname" == "linux" ]]; then
+    echo -e '\n***************************************************************************************************'
+    echo "                             Installing dependencies specific to Linux"
+    echo -e '***************************************************************************************************\n'
+
+    sudo apt update
     dev_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
     sudo apt install -y "python$dev_ver-distutils"  # Install distutils for the current python version
     sudo apt-get install -y git libasound-dev portaudio19-dev libportaudio2 libportaudiocpp0
     sudo apt install -y build-essential ffmpeg espeak python3-pyaudio "python$dev_ver-dev"
-    python -m pip install PyAudio==0.2.12 pvporcupine==1.9.5
+    python -m pip install pvporcupine==1.9.5
     python -m pip install gobject PyGObject
     # Install as stand alone as playsound depends on gobject
     python -m pip install playsound==1.3.0
     os_independent_packages
 else
     clear
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
     echo ""
-    echo "Current Operating System: $OSName"
+    echo "Current Operating System: $osname"
     echo "Jarvis is currently supported only on Linux, MacOS and Windows"
     echo ""
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
 fi
```

## jarvis_ui/lib/requirements.txt

```diff
@@ -1,7 +1,9 @@
-packaging==23.1
-SpeechRecognition==3.8.1  # Do not upgrade, no functional upgrade in latest version
-pydantic[dotenv,email]==1.10.7
-pynotification
-requests
+packaging==23.2
 py3-tts
+PyAudio==0.2.14
+pydantic[email]==2.4.*
+pydantic_settings==2.0.*
+pynotification
 PyYAML
+requests
+SpeechRecognition==3.10.0
```

## jarvis_ui/modules/config.py

```diff
@@ -12,31 +12,38 @@
 import pvporcupine
 from pydantic import BaseConfig, PositiveInt
 
 from jarvis_ui.executables.api_handler import make_request
 from jarvis_ui.modules.logger import logger
 from jarvis_ui.modules.models import env, settings
 
-add_ss_extn: Callable = lambda filepath: os.path.splitext(filepath)[0] + "_ss" + os.path.splitext(filepath)[1]
+add_ss_extn: Callable = (
+    lambda filepath: os.path.splitext(filepath)[0]
+    + "_ss"
+    + os.path.splitext(filepath)[1]
+)
 
 
 def swapper() -> None:
     """Swaps any request URL with the public URL if returned by Jarvis.
 
     Notes:
         Avoid making calls via load balancers or reverse proxy (if one is in place) such as CloudFront or Nginx.
     """
-    if (public_url := make_request(path='offline-communicator',
-                                   data={'command': 'ngrok public url'})) and public_url.get('detail'):
-        if public_url['detail'][-1] != "/":
-            public_url['detail'] += "/"
-        if public_url['detail'] == env.request_url:
+    if (
+        public_url := make_request(
+            path="offline-communicator", data={"command": "ngrok public url"}
+        )
+    ) and public_url.get("detail"):
+        if public_url["detail"][-1] != "/":
+            public_url["detail"] += "/"
+        if public_url["detail"] == env.server_url:
             return
-        logger.info("Switching %s to %s", env.request_url, public_url['detail'])
-        env.request_url = public_url['detail']
+        logger.info("Switching %s to %s", env.server_url, public_url["detail"])
+        env.server_url = public_url["detail"]
 
 
 class Config(BaseConfig):
     """Gets keywords during start up. Runs custom validations on env-vars.
 
     >>> Config
 
@@ -45,22 +52,22 @@
         If the voice name is not present for the OperatingSystem.
     """
 
     if env.voice_pitch and settings.operating_system in ("Windows", "Darwin"):
         warnings.warn(
             "Voice pitch adjustment is currently supported only in Linux operating system."
         )
-    if env.request_url[-1] != "/":
-        env.request_url += "/"
+        env.voice_pitch = None
+    env.server_url = str(env.server_url)
 
     swapper()
 
     if isinstance(env.sensitivity, float) or isinstance(env.sensitivity, PositiveInt):
         env.sensitivity = [env.sensitivity] * len(env.wake_words)
-    if keywords := make_request(path='keywords', method='GET'):
+    if keywords := make_request(path="keywords", method="GET"):
         logger.info("keywords have been loaded")
 
     if keywords:
         keywords = sum([v for _, v in keywords.items()], [])
 
     if env.speech_timeout and env.native_audio:
         warnings.warn(
@@ -68,27 +75,38 @@
             "Speech synthesis uses third-party tts service where as `native_audio` preserves the audio from server.\n"
             "Disabling speech synthesis!!"
         )
         env.speech_timeout = 0
 
     if settings.legacy:
         pvporcupine.KEYWORD_PATHS = {}
-        pvporcupine.MODEL_PATH = os.path.join(os.path.dirname(pvporcupine.__file__),
-                                              'lib/common/porcupine_params.pv')
-        pvporcupine.LIBRARY_PATH = os.path.join(os.path.dirname(pvporcupine.__file__),
-                                                f'lib/mac/{platform.machine()}/libpv_porcupine.dylib')
-        keyword_files = os.listdir(os.path.join(os.path.dirname(pvporcupine.__file__), "resources/keyword_files/mac/"))
+        pvporcupine.MODEL_PATH = os.path.join(
+            os.path.dirname(pvporcupine.__file__), "lib/common/porcupine_params.pv"
+        )
+        pvporcupine.LIBRARY_PATH = os.path.join(
+            os.path.dirname(pvporcupine.__file__),
+            f"lib/mac/{platform.machine()}/libpv_porcupine.dylib",
+        )
+        keyword_files = os.listdir(
+            os.path.join(
+                os.path.dirname(pvporcupine.__file__), "resources/keyword_files/mac/"
+            )
+        )
         for x in keyword_files:
-            pvporcupine.KEYWORD_PATHS[x.split('_')[0]] = os.path.join(os.path.dirname(pvporcupine.__file__),
-                                                                      f"resources/keyword_files/mac/{x}")
+            pvporcupine.KEYWORD_PATHS[x.split("_")[0]] = os.path.join(
+                os.path.dirname(pvporcupine.__file__),
+                f"resources/keyword_files/mac/{x}",
+            )
 
     for keyword in env.wake_words:
-        if keyword == 'sphinx-build':
+        if keyword == "sphinx-build":
             break
-        if not pvporcupine.KEYWORD_PATHS.get(keyword) or not os.path.isfile(pvporcupine.KEYWORD_PATHS[keyword]):
+        if not pvporcupine.KEYWORD_PATHS.get(keyword) or not os.path.isfile(
+            pvporcupine.KEYWORD_PATHS[keyword]
+        ):
             raise ValueError(
                 f"Detecting '{keyword}' is unsupported!\n"
                 f"Available keywords are: {', '.join(list(pvporcupine.KEYWORD_PATHS.keys()))}"
             )
 
 
 logger.info("Current Process: %s", current_process().name)
```

## jarvis_ui/modules/exceptions.py

```diff
@@ -1,21 +1,20 @@
 import ctypes
 from contextlib import contextmanager
 from typing import ByteString, Iterable
 
-ALSA_ERROR_HANDLER = ctypes.CFUNCTYPE(None,
-                                      ctypes.c_char_p,
-                                      ctypes.c_int,
-                                      ctypes.c_char_p,
-                                      ctypes.c_int,
-                                      ctypes.c_char_p)
+ALSA_ERROR_HANDLER = ctypes.CFUNCTYPE(
+    None, ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p
+)
 
 
 # noinspection PyUnusedLocal
-def py_error_handler(filename: ByteString, line: int, function: ByteString, err: int, fmt: ByteString) -> None:
+def py_error_handler(
+    filename: ByteString, line: int, function: ByteString, err: int, fmt: ByteString
+) -> None:
     """Handles errors from pyaudio module especially for Linux based operating systems."""
     pass
 
 
 c_error_handler = ALSA_ERROR_HANDLER(py_error_handler)
 
 
@@ -36,15 +35,15 @@
 
     References:
         - https://github.com/Uberi/speech_recognition/issues/100
         - https://github.com/Uberi/speech_recognition/issues/182
         - https://github.com/Uberi/speech_recognition/issues/191
         - https://forums.raspberrypi.com/viewtopic.php?t=136974
     """
-    sound = ctypes.cdll.LoadLibrary('libasound.so')
+    sound = ctypes.cdll.LoadLibrary("libasound.so")
     sound.snd_lib_error_set_handler(c_error_handler)
     yield
     sound.snd_lib_error_set_handler(None)
 
 
 class UnsupportedOS(OSError):
     """Custom ``OSError`` raised when initiated in an unsupported operating system.
@@ -56,15 +55,7 @@
 
 class InvalidEnvVars(ValueError):
     """Custom ``InvalidEnvVars`` raised when invalid env vars are passed.
 
     >>> InvalidEnvVars
 
     """
-
-
-class SegmentationError(EnvironmentError):
-    """Custom ``SegmentationError`` raised when the code exits with SIGSEGV.
-
-    >>> SegmentationError
-
-    """
```

## jarvis_ui/modules/logger.py

```diff
@@ -10,49 +10,54 @@
 import importlib
 import logging
 import os
 from logging.config import dictConfig
 
 from jarvis_ui.modules.models import env, fileio
 
-if not os.path.isdir('logs'):
-    os.makedirs('logs')
+if not os.path.isdir("logs"):
+    os.makedirs("logs")
 
 importlib.reload(module=logging)
-dictConfig({
-    'version': 1,
-    'disable_existing_loggers': True,
-})
+dictConfig(
+    {
+        "version": 1,
+        "disable_existing_loggers": True,
+    }
+)
 logging.getLogger("_code_cache").propagate = False
 log_level = logging.DEBUG if env.debug else logging.INFO
 
 
 def file_logger() -> logging.Logger:
     """Create custom file logger.
 
     Returns:
         Logger:
         Returns the logger object.
     """
     logging.basicConfig(
-        filename=fileio.base_log_file, filemode='a', level=log_level,
-        format='%(asctime)s - %(levelname)s - [%(module)s:%(lineno)d] - %(funcName)s - %(message)s',
-        datefmt='%b-%d-%Y %I:%M:%S %p'
+        filename=fileio.base_log_file,
+        filemode="a",
+        level=log_level,
+        format="%(asctime)s - %(levelname)s - [%(module)s:%(lineno)d] - %(funcName)s - %(message)s",
+        datefmt="%b-%d-%Y %I:%M:%S %p",
     )
     return logging.getLogger(__name__)
 
 
 def console_logger() -> logging.Logger:
     """Create custom stream logger.
 
     Returns:
         Logger:
         Returns the logger object.
     """
     logging.basicConfig(
-        format='%(asctime)s - %(levelname)s - [%(module)s:%(lineno)d] - %(funcName)s - %(message)s',
-        datefmt='%b-%d-%Y %I:%M:%S %p', level=log_level
+        format="%(asctime)s - %(levelname)s - [%(module)s:%(lineno)d] - %(funcName)s - %(message)s",
+        datefmt="%b-%d-%Y %I:%M:%S %p",
+        level=log_level,
     )
     return logging.getLogger(__name__)
 
 
 logger = file_logger()
```

## jarvis_ui/modules/models.py

```diff
@@ -5,28 +5,39 @@
 import os
 import platform
 import string
 import sys
 from collections import ChainMap
 from datetime import datetime
 from enum import Enum
-from typing import List, Union
+from typing import Dict, List, Union
 
 from packaging.version import parse as parser
-from pydantic import (BaseSettings, Field, FilePath, HttpUrl, PositiveFloat,
-                      PositiveInt, validator)
+from pydantic import (
+    Field,
+    FilePath,
+    HttpUrl,
+    PositiveFloat,
+    PositiveInt,
+    field_validator,
+)
+from pydantic_settings import BaseSettings
 
 from jarvis_ui import indicators
 from jarvis_ui.modules.exceptions import UnsupportedOS
 from jarvis_ui.modules.peripherals import channel_type, get_audio_devices
 
 if os.getcwd().endswith("doc_generator"):
     os.chdir(os.path.dirname(os.getcwd()))
 
-UNICODE_PREFIX = base64.b64decode(b'XA==').decode(encoding="ascii") + string.ascii_letters[20] + string.digits[:1] * 2
+UNICODE_PREFIX = (
+    base64.b64decode(b"XA==").decode(encoding="ascii")
+    + string.ascii_letters[20]
+    + string.digits[:1] * 2
+)
 
 
 class Settings(BaseSettings):
     """Loads most common system values.
 
     >>> Settings
 
@@ -40,24 +51,28 @@
         raise UnsupportedOS(
             f"\n{''.join('*' for _ in range(80))}\n\n"
             "Unsupported Operating System. Currently Jarvis can run only on Mac and Windows OS.\n\n"
             "To raise an issue: https://github.com/thevickypedia/Jarvis/issues/new\n"
             "To reach out: https://vigneshrao.com/contact\n"
             f"\n{''.join('*' for _ in range(80))}\n"
         )
-    legacy: bool = True if os == "Darwin" and parser(platform.mac_ver()[0]) < parser('10.14') else False
+    legacy: bool = (
+        True
+        if os == "Darwin" and parser(platform.mac_ver()[0]) < parser("10.14")
+        else False
+    )
     if sys.stdin.isatty():
-        interactive = True
+        interactive: bool = True
     else:
-        interactive = False
+        interactive: bool = False
 
 
 settings = Settings()
 # Intermittently changes to Windows_NT because of pydantic
-if settings.operating_system.startswith('Windows'):
+if settings.operating_system.startswith("Windows"):
     settings.operating_system = "Windows"
 
 
 class Sensitivity(float or PositiveInt, Enum):
     """Allowed values for sensitivity.
 
     >>> Sensitivity
@@ -85,92 +100,127 @@
     """Configure all env vars and validate using ``pydantic`` to share across modules.
 
     >>> EnvConfig
 
     """
 
     # Required env vars
-    request_url: HttpUrl = Field(default=...)
-    token: str = Field(default=...)
+    server_url: HttpUrl
+    token: str
 
     # Heart beat
-    heart_beat: int = Field(default=None, le=3_600, ge=5)
+    heart_beat: Union[int, None] = Field(None, le=3_600, ge=5)
 
     # Speech recognition settings
-    recognizer_settings: RecognizerSettings = Field(default=RecognizerSettings())
+    recognizer_settings: RecognizerSettings = RecognizerSettings()
 
-    debug: bool = Field(default=False)
-    microphone_index: Union[int, PositiveInt] = Field(default=None, ge=0)
+    debug: bool = False
+    microphone_index: Union[int, PositiveInt, None] = Field(None, ge=0)
 
-    speech_timeout: Union[float, PositiveInt] = Field(default=0)
-    sensitivity: Union[Sensitivity, List[Sensitivity]] = Field(default=0.5, le=1, ge=0)
+    speech_timeout: Union[int, PositiveFloat, PositiveInt] = 0
+    sensitivity: Union[
+        PositiveInt, PositiveFloat, List[PositiveInt], List[PositiveFloat]
+    ] = Field(0.5, le=1, ge=0)
 
     # Built-in speaker config (Unused if speech synthesis is used)
-    voice_name: str = Field(default=None)
-    voice_rate: Union[PositiveInt, PositiveFloat] = Field(default=None)
-    voice_pitch: Union[PositiveInt, PositiveFloat] = Field(default=None)
+    voice_name: Union[str, None] = None
+    voice_rate: Union[PositiveInt, PositiveFloat, None] = None
+    voice_pitch: Union[PositiveInt, PositiveFloat, None] = None
 
-    listener_timeout: Union[float, PositiveInt] = Field(default=2)
-    listener_phrase_limit: Union[float, PositiveInt] = Field(default=5)
+    listener_timeout: Union[float, PositiveInt] = 2
+    listener_phrase_limit: Union[float, PositiveInt] = 5
     if settings.legacy:
-        wake_words: list = Field(default=['alexa'])
+        wake_words: List[str] = ["alexa"]
     else:
-        wake_words: list = Field(default=['jarvis'])
-    native_audio: bool = Field(default=False)
+        wake_words: List[str] = ["jarvis"]
+    native_audio: bool = False
 
     class Config:
         """Environment variables configuration."""
 
         env_prefix = ""
         env_file = os.environ.get("env_file", os.environ.get("ENV_FILE", ".env"))
 
     # noinspection PyMethodParameters
-    @validator("microphone_index", pre=True, allow_reuse=True)
-    def parse_microphone_index(cls, v: Union[int, PositiveInt]) -> Union[int, PositiveInt, None]:
+    @field_validator("microphone_index", mode="before")
+    def parse_microphone_index(
+        cls, v: Union[int, PositiveInt]
+    ) -> Union[int, PositiveInt, None]:
         """Validates microphone index."""
         if not v:
             return
-        if int(v) in list(map(lambda tag: tag['index'], get_audio_devices(channels=channel_type.input_channels))):
+        if int(v) in list(
+            map(
+                lambda tag: tag["index"],
+                get_audio_devices(channels=channel_type.input_channels),
+            )
+        ):
             return v
         else:
-            complicated = dict(ChainMap(*list(map(lambda tag: {tag['index']: tag['name']},
-                                                  get_audio_devices(channels=channel_type.input_channels)))))
+            complicated = dict(
+                ChainMap(
+                    *list(
+                        map(
+                            lambda tag: {tag["index"]: tag["name"]},
+                            get_audio_devices(channels=channel_type.input_channels),
+                        )
+                    )
+                )
+            )
             raise ValueError(f"value should be one of {complicated}")
 
 
 env = EnvConfig()
 
 
 class FileIO(BaseSettings):
     """Loads all the mp3 files' path and log file path required by Jarvis.
 
     >>> FileIO
 
     """
 
-    path = indicators.__path__[0]
-    extn_ = {"Darwin": "mac", "Windows": "win", "Linux": "ss"}  # Mapping for OS specific pre-recorded audio files
+    path: str = indicators.__path__[0]
+    # Mapping for OS specific pre-recorded audio files
+    extn_: Dict[str, str] = {"Darwin": "mac", "Windows": "win", "Linux": "ss"}
 
-    acknowledgement: FilePath = os.path.join(path, 'acknowledgement.wav')
+    acknowledgement: FilePath = os.path.join(path, "acknowledgement.wav")
 
     if env.speech_timeout and not env.native_audio:
-        extn_[settings.operating_system] = "ss"  # Set mapping to use speech synthesis' audio file
-
-    failed: FilePath = os.path.join(path, f'failed_{extn_[settings.operating_system]}.wav')
-    restart: FilePath = os.path.join(path, f'restart_{extn_[settings.operating_system]}.wav')
-    shutdown: FilePath = os.path.join(path, f'shutdown_{extn_[settings.operating_system]}.wav')
-    connection_restart: FilePath = os.path.join(path, f'connection_restart_{extn_[settings.operating_system]}.wav')
-
-    speech_wav_file: Union[FilePath, str] = os.path.join(path, 'speech-synthesis.wav')
-    base_log_file: Union[FilePath, str] = datetime.now().strftime(os.path.join('logs', 'jarvis_%d-%m-%Y.log'))
+        extn_[
+            settings.operating_system
+        ] = "ss"  # Set mapping to use speech synthesis' audio file
+
+    failed: FilePath = os.path.join(
+        path, f"failed_{extn_[settings.operating_system]}.wav"
+    )
+    restart: FilePath = os.path.join(
+        path, f"restart_{extn_[settings.operating_system]}.wav"
+    )
+    shutdown: FilePath = os.path.join(
+        path, f"shutdown_{extn_[settings.operating_system]}.wav"
+    )
+    connection_restart: FilePath = os.path.join(
+        path, f"connection_restart_{extn_[settings.operating_system]}.wav"
+    )
+
+    speech_wav_file: Union[FilePath, str] = os.path.join(path, "speech-synthesis.wav")
+    base_log_file: Union[FilePath, str] = datetime.now().strftime(
+        os.path.join("logs", "jarvis_%d-%m-%Y.log")
+    )
 
 
 fileio = FileIO()
 # because playaudio in Windows uses string concatenation assuming input sound is going to be a string
 if settings.operating_system == "Windows":
     for key, value in fileio.__dict__.items():
-        if not key.endswith('_'):
+        if not key.endswith("_"):
             setattr(fileio, key, value.__str__())
 raw_token = env.token
-env.token = UNICODE_PREFIX + UNICODE_PREFIX.join(binascii.hexlify(data=env.token.encode(encoding="utf-8"),
-                                                                  sep="-").decode(encoding="utf-8").split(sep="-"))
-assert raw_token == bytes(env.token, "utf-8").decode(encoding="unicode_escape")  # Check decoded value before startup
+env.token = UNICODE_PREFIX + UNICODE_PREFIX.join(
+    binascii.hexlify(data=env.token.encode(encoding="utf-8"), sep="-")
+    .decode(encoding="utf-8")
+    .split(sep="-")
+)
+assert raw_token == bytes(env.token, "utf-8").decode(
+    encoding="unicode_escape"
+)  # Check decoded value before startup
```

## jarvis_ui/modules/peripherals.py

```diff
@@ -19,16 +19,16 @@
 class ChannelType(str, Enum):
     """Allowed values for channel types.
 
     >>> ChannelType
 
     """
 
-    input_channels: str = 'maxInputChannels'
-    output_channels: str = 'maxOutputChannels'
+    input_channels: str = "maxInputChannels"
+    output_channels: str = "maxOutputChannels"
 
 
 channel_type = ChannelType
 
 
 def get_audio_devices(channels: str) -> Iterable[Dict[str, Union[str, int, float]]]:
     """Iterates over all devices and yields the device that has input channels.
@@ -42,10 +42,18 @@
     """
     for index in range(_device_range):
         device_info = audio_engine.get_device_info_by_index(device_index=index)
         if device_info.get(channels, 0) > 0:
             yield device_info
 
 
-if __name__ == '__main__':
-    print(json.dumps(list(get_audio_devices(channels=channel_type.input_channels)), indent=2))
-    print(json.dumps(list(get_audio_devices(channels=channel_type.output_channels)), indent=2))
+if __name__ == "__main__":
+    print(
+        json.dumps(
+            list(get_audio_devices(channels=channel_type.input_channels)), indent=2
+        )
+    )
+    print(
+        json.dumps(
+            list(get_audio_devices(channels=channel_type.output_channels)), indent=2
+        )
+    )
```

## jarvis_ui/modules/timer.py

```diff
@@ -5,28 +5,34 @@
 class RepeatedTimer:
     """Instantiates RepeatedTimer object to kick off the threading.Timer object with custom intervals.
 
     >>> RepeatedTimer
 
     """
 
-    def __init__(self, interval: int, function: Callable, args: Tuple = None, kwargs: Dict[str, Any] = None):
+    def __init__(
+        self,
+        interval: int,
+        function: Callable,
+        args: Tuple = None,
+        kwargs: Dict[str, Any] = None,
+    ):
         """Repeats the ``Timer`` object from threading.
 
         Args:
             interval: Interval in seconds.
             function: Function to trigger with intervals.
             args: Arguments for the function.
             kwargs: Keyword arguments for the function.
         """
         self._timer = None
         self.interval = interval
         self.function = function
-        self.args = args or tuple()
-        self.kwargs = kwargs or dict()
+        self.args = args or ()
+        self.kwargs = kwargs or {}
         self.is_running = False
 
     def _run(self):
         """Triggers the target function."""
         self.is_running = False
         self.start()
         self.function(*self.args, **self.kwargs)
```

## Comparing `jarvis_ui-2.3.data/scripts/install.sh` & `jarvis_ui-2.3.1.data/scripts/install.sh`

 * *Files 27% similar despite different names*

```diff
@@ -1,88 +1,116 @@
 #!/bin/bash
+# 'set -e' stops the execution of a script if a command or pipeline has an error.
+# This is the opposite of the default shell behaviour, which is to ignore errors in scripts.
+set -e
+
+# defaults
+osname=""
+architecture=""
+
+# Get to the current directory
+current_dir="$(dirname "$(realpath "$0")")"
+export current_dir=$current_dir
+source "$current_dir/squire/detector.sh"
+
+if ! [ -x "$(command -v python)" ] && ! [ -x "$(command -v python3)" ]; then
+  echo -e '\n***************************************************************************************************'
+  echo "                       Neither 'python' nor 'python3' command found!!"
+  echo "                      Please install 'python' 3.8 to 3.11 to proceed!!"
+  echo -e '***************************************************************************************************\n'
+  exit 1
+fi
+
+if ! [ -x "$(command -v python)" ]; then
+  alias python=python3
+fi
 
-OSName=$(UNAME)
 ver=$(python -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")
 echo_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
 
 echo -e '\n***************************************************************************************************'
-echo "                               $OSName running python $echo_ver"
+echo "                            $osname-$architecture running python $echo_ver"
 echo -e '***************************************************************************************************\n'
 
 if [ "$ver" -ge 38 ] && [ "$ver" -le 311 ]; then
-  pyaudio="PyAudio-0.2.11-cp$ver-cp$ver-win_amd64.whl"
+  # Upgrades pip, setuptools and wheel
+  python -m pip install --upgrade pip setuptools wheel
 else
   echo "Python version $echo_ver is unsupported for Jarvis. Please use any python version between 3.8.* and 3.11.*"
   exit
 fi
 
+current_dir="$(dirname "$(realpath "$0")")"
+
 # Upgrades pip module
 python -m pip install --upgrade pip
 
 os_independent_packages() {
     # Get to the current directory and install the module specific packages from requirements.txt
-    current_dir="$(dirname "$(realpath "$0")")"
     python -m pip install --no-cache-dir -r "$current_dir"/requirements.txt
 }
 
-if [[ "$OSName" == "Darwin" ]]; then
+if [[ "$osname" == "darwin" ]]; then
+    echo -e '\n***************************************************************************************************'
+    echo "                             Installing dependencies specific to macOS"
+    echo -e '***************************************************************************************************\n'
+
     # Looks for xcode installation and installs only if xcode is not found already
     which xcodebuild > tmp_xcode && xcode_check=$(cat tmp_xcode) && rm tmp_xcode
-    if  [[ "$xcode_check" == "/usr/bin/xcodebuild" ]] || [[ $HOST == "/*" ]] ; then
-        xcode_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version)
-        echo "xcode $xcode_version"
+    if [[ "$xcode_check" == "/usr/bin/xcodebuild" ]] || [[ $HOST == "/*" ]]; then
+      xcode_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version)
+      echo "xcode $xcode_version"
     else
-        echo "Installing xcode"
-        xcode-select --install
+      echo "Installing xcode"
+      xcode-select --install
     fi
 
     # Looks for brew installation and installs only if brew is not found
-    brew_check=$(which brew)
-    if [[ "$brew_check" == "/usr/local/bin/brew" ]] || [[ "$brew_check" == "/usr/bin/brew" ]]; then
-        brew -v > tmp_brew && brew_version=$(head -n 1 tmp_brew) && rm tmp_brew
-        echo "$brew_version"
-    else
-        echo "Installing Homebrew"
-        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
+    if ! [ -x "$(command -v brew)" ]; then
+      echo "Installing Homebrew"
+      /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
     fi
+    brew -v > tmp_brew && brew_version=$(head -n 1 tmp_brew) && rm tmp_brew
+    echo "$brew_version"
+    # Packages installed using homebrew
     brew install portaudio coreutils
-    python -m pip install PyAudio==0.2.13 playsound==1.3.0
+    python -m pip install playsound==1.3.0
 
     # Checks current version and installs legacy pvporcupine version if macOS is older han 10.14
     base_ver="10.14"
     os_ver=$(sw_vers | grep ProductVersion | cut -d':' -f2 | tr -d ' ')
     if awk "BEGIN {exit !($base_ver > $os_ver)}"; then
       pip install 'pvporcupine==1.6.0'
     else
       pip install 'pvporcupine==1.9.5'
     fi
     os_independent_packages
-elif [[ "$OSName" == MSYS* ]]; then
+elif [[ "$osname" == "windows" ]]; then
     conda install portaudio=19.6.0
-    # PyAudio wheel files original source:
-    # https://www.lfd.uci.edu/~gohlke/pythonlibs/#:~:text=PyAudio:%20bindings%20for%20the%20PortAudio%20library
-    curl https://vigneshrao.com/Jarvis/"$pyaudio" --output "$pyaudio" --silent
-    pip install "$pyaudio"
-    rm "$pyaudio"
     pip install pvporcupine==1.9.5 pywin32==305 playsound==1.2.2
     os_independent_packages
-elif [[ "$OSName" == "Linux" ]]; then
+elif [[ "$osname" == "linux" ]]; then
+    echo -e '\n***************************************************************************************************'
+    echo "                             Installing dependencies specific to Linux"
+    echo -e '***************************************************************************************************\n'
+
+    sudo apt update
     dev_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
     sudo apt install -y "python$dev_ver-distutils"  # Install distutils for the current python version
     sudo apt-get install -y git libasound-dev portaudio19-dev libportaudio2 libportaudiocpp0
     sudo apt install -y build-essential ffmpeg espeak python3-pyaudio "python$dev_ver-dev"
-    python -m pip install PyAudio==0.2.12 pvporcupine==1.9.5
+    python -m pip install pvporcupine==1.9.5
     python -m pip install gobject PyGObject
     # Install as stand alone as playsound depends on gobject
     python -m pip install playsound==1.3.0
     os_independent_packages
 else
     clear
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
     echo ""
-    echo "Current Operating System: $OSName"
+    echo "Current Operating System: $osname"
     echo "Jarvis is currently supported only on Linux, MacOS and Windows"
     echo ""
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
 fi
```

## Comparing `jarvis_ui-2.3.dist-info/LICENSE` & `jarvis_ui-2.3.1.dist-info/LICENSE`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 MIT License
 
-Copyright (c) 2020 Vignesh Sivanandha Rao
+Copyright (c) 2020 Vignesh Rao
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

## Comparing `jarvis_ui-2.3.dist-info/METADATA` & `jarvis_ui-2.3.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 Metadata-Version: 2.1
 Name: jarvis-ui
-Version: 2.3
+Version: 2.3.1
 Summary: Jarvis UI to perform voice commands via API calls
-Author-email: Vignesh Sivanandha Rao <svignesh1793@gmail.com>
+Author-email: Vignesh Rao <svignesh1793@gmail.com>
 License: MIT License
         
-        Copyright (c) 2020 Vignesh Sivanandha Rao
+        Copyright (c) 2020 Vignesh Rao
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
         of this software and associated documentation files (the "Software"), to deal
         in the Software without restriction, including without limitation the rights
         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         copies of the Software, and to permit persons to whom the Software is
         furnished to do so, subject to the following conditions:
@@ -54,33 +54,36 @@
 Classifier: Topic :: System :: Hardware :: Universal Serial Bus (USB) :: Human Interface Device (HID)
 Classifier: Framework :: FastAPI
 Classifier: Framework :: Flake8
 Classifier: Framework :: AsyncIO
 Classifier: Framework :: Sphinx
 Classifier: Framework :: aiohttp
 Classifier: Natural Language :: English
-Requires-Python: >=3.8
+Requires-Python: <3.12,>=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: packaging ==23.1
-Requires-Dist: SpeechRecognition ==3.8.1
-Requires-Dist: pydantic[dotenv,email] ==1.10.7
-Requires-Dist: pynotification
-Requires-Dist: requests
+Requires-Dist: packaging ==23.2
 Requires-Dist: py3-tts
+Requires-Dist: PyAudio ==0.2.14
+Requires-Dist: pydantic[email] ==2.4.*
+Requires-Dist: pydantic-settings ==2.0.*
+Requires-Dist: pynotification
 Requires-Dist: PyYAML
+Requires-Dist: requests
+Requires-Dist: SpeechRecognition ==3.10.0
 Provides-Extra: dev
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: pre-commit ; extra == 'dev'
 
 ![Python](https://img.shields.io/badge/python-3.8%20%7C%203.9%20%7C%203.10%20%7C%203.11-blue)
 
 **Deployments**
 
 [![pages-build-deployment](https://github.com/thevickypedia/Jarvis_UI/actions/workflows/pages/pages-build-deployment/badge.svg)](https://github.com/thevickypedia/Jarvis_UI/actions/workflows/pages/pages-build-deployment)
+
 [![pypi](https://github.com/thevickypedia/Jarvis_UI/actions/workflows/python-publish.yml/badge.svg)](https://github.com/thevickypedia/Jarvis_UI/actions/workflows/python-publish.yml)
 
 # Jarvis UI
 
 Connects to [`Jarvis`](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/api/fast.py) running in the backend to process request and response via API calls.
 
 ### Kick off
@@ -99,30 +102,30 @@
 ```
 
 ### Environment Variables
 Env vars are loaded from a `.env` file and validated using `pydantic`
 <details>
 <summary><strong><i>To use custom .env files</i></strong></summary>
 
-If the filename is anything other than `.env`, set the filename as an env var `env_file` before importing `jarvis_ui`
+To use a custom `.env` file, set the filename to the env var `env_file` before importing `jarvis_ui` module.
 
 ```python
 import os
 os.environ['env_file'] = "jarvis_ui.env"
 
 import jarvis_ui
 
 if __name__ == '__main__':
     jarvis_ui.start()
 ```
 
 </details>
 
 #### Mandatory
-- **REQUEST_URL**: URL to which the API call has to be made. Can be `localhost` or a `tunneled` URL behind a reverse proxy/CDN.
+- **SERVER_URL**: Endpoint URL to which the API call has to be made. Can be `localhost` or a `tunneled` URL behind a reverse proxy/CDN.
 - **TOKEN**: Authentication token.
 
 #### Optional
 - **HEART_BEAT**: Defaults to `None` - _Interval in seconds to trigger background healthcheck on the server with automatic restart_
 - **DEBUG**: Defaults to `False` - _Enable debug level logging_
 <br><br>
 - **SPEECH_TIMEOUT**: Defaults to `0` for macOS, `10` for Windows - _Timeout for speech synthesis_
@@ -162,15 +165,15 @@
 ---
 
 :bulb: &nbsp; **Refer Jarvis' [README](https://github.com/thevickypedia/Jarvis/blob/master/README.md) for more information on setting up the backend server.**
 
 ### Coding Standards
 Docstring format: [`Google`](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings) <br>
 Styling conventions: [`PEP 8`](https://www.python.org/dev/peps/pep-0008/) <br>
-Clean code with pre-commit hooks: [`flake8`](https://flake8.pycqa.org/en/latest/) and 
+Clean code with pre-commit hooks: [`flake8`](https://flake8.pycqa.org/en/latest/) and
 [`isort`](https://pycqa.github.io/isort/)
 
 ### [Release Notes](https://github.com/thevickypedia/Jarvis_UI/blob/main/release_notes.rst)
 **Requirement**
 ```shell
 python -m pip install gitverse
 ```
@@ -182,15 +185,15 @@
 
 ### Linting
 `PreCommit` will ensure linting, and the doc creation are run on every commit.
 
 **Requirement**
 <br>
 ```bash
-pip install --no-cache sphinx==5.1.1 pre-commit recommonmark
+python -m pip install sphinx==5.1.1 pre-commit recommonmark
 ```
 
 **Usage**
 <br>
 ```bash
 pre-commit run --all-files
 ```
@@ -203,10 +206,10 @@
 ### Runbook
 [![made-with-sphinx-doc](https://img.shields.io/badge/Code%20Docs-Sphinx-1f425f.svg)](https://www.sphinx-doc.org/en/master/man/sphinx-autogen.html)
 
 [https://thevickypedia.github.io/Jarvis_UI/](https://thevickypedia.github.io/Jarvis_UI/)
 
 ### License & copyright
 
-&copy; Vignesh Sivanandha Rao
+&copy; Vignesh Rao
 
 Licensed under the [MIT License](https://github.com/thevickypedia/Jarvis_UI/blob/main/LICENSE)
```

## Comparing `jarvis_ui-2.3.dist-info/RECORD` & `jarvis_ui-2.3.1.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,37 +1,39 @@
-jarvis_ui/__init__.py,sha256=tBQSgr45AuX0HjPOWMVCLOCg-uPgkNY_Qc7pbMTaZE4,689
-jarvis_ui/main.py,sha256=BmXMGYlpS7nBCK2ySmPyM0XOufYirZs0g74wOLSqwMw,2852
-jarvis_ui/test_listener.py,sha256=Hd-hfeqgmy9s9YNqFSnsnSK9DoqJH7-sgapCpyUYn7s,2144
-jarvis_ui/executables/api_handler.py,sha256=BN3fkWRG7XCW_vCYpFmmWNjamd_7y_guejGdxgbuQcI,2553
-jarvis_ui/executables/audio_driver.py,sha256=RgybF0CfEAmtZ1raNOjdsC0Cg9sfGgPT-wzswIypvfY,4352
-jarvis_ui/executables/display.py,sha256=kqm1XYA1v40HehRwIwQkaUVeyNc1x8jnl6OBAXkHoHo,779
-jarvis_ui/executables/helper.py,sha256=gk1-C9HteRkqcBTwUd3VkHIZFiRpEe_IJeFeUQrvDPI,2073
-jarvis_ui/executables/listener.py,sha256=a0iNX2GokfbH07lBP6OtOHNSW-cyl2pHfJQj1-gFwgM,2105
-jarvis_ui/executables/speaker.py,sha256=9Dm4h9Oyy7I-WtwnFycOau_4KcSeqS7gK9zvW13A4Ic,541
-jarvis_ui/executables/starter.py,sha256=wMxRtlbtO5p89eWRvvpU_CqJIYZdWvY5I3lqqckKROo,8873
+jarvis_ui/__init__.py,sha256=2gAPHxz0MOj0IgNgvaFrMWK7utD5aRILrGUtkVawutw,635
+jarvis_ui/main.py,sha256=SKrF7QQGft-RxDkz1uLCQNWNLZzoc0x5bOeM4Nig3Bo,2920
+jarvis_ui/test_listener.py,sha256=8Gy0TzDyDOW_pUmDK6V3jtz7X6k0MJG5aue2vvP8RMM,2145
+jarvis_ui/executables/api_handler.py,sha256=hooaAndxApUJfKaaHHzsbJjIyKne6D6x_cxYAFXNgBM,2474
+jarvis_ui/executables/audio_driver.py,sha256=MugplEdX2dfkR2wucKfLZaQf6Qx0UxzNH07Jqukuws0,2179
+jarvis_ui/executables/display.py,sha256=hPzZUKz7LLSGWh_drcgPO8NCzR59y6oB2c52pVrPlYI,801
+jarvis_ui/executables/helper.py,sha256=HUXNDneXYsSQ1DEE6l-dmtDmD7fnb_b5e_8KOEP1-NE,2072
+jarvis_ui/executables/listener.py,sha256=DeLrNJpIr1BRB7VBNLX8fdx5fQS9XuE2YmSGZlN_Ec8,2126
+jarvis_ui/executables/speaker.py,sha256=QG09p3WGu7oTH6FMgtmY6twFU2zjvraN1O_8TJfW5QI,541
+jarvis_ui/executables/starter.py,sha256=NgjYGR6IY6AN2x82qYD7yJ02Evh7g38TKHaozrGQukI,9012
 jarvis_ui/indicators/acknowledgement.wav,sha256=_KvA_KY5Cs1WcOWkmxwzJrvEt75113g4qQCKbeA6LYA,103102
 jarvis_ui/indicators/connection_restart_mac.wav,sha256=0b9pEDds1WRdORMZOvzKOwUfFdI9EWPl_boWniocgIk,233690
 jarvis_ui/indicators/connection_restart_ss.wav,sha256=upeuedV1GNSreDeMOLBtcpxcwmrhptL2xt36qooS4Ic,226348
 jarvis_ui/indicators/connection_restart_win.wav,sha256=TpcALpg4Wo6zftJMzWNEhuGnaro7fgXDBCE5EgW7zt0,224084
 jarvis_ui/indicators/failed_mac.wav,sha256=sA9IZxaLwaz7FCEadd03FqGOM3pXwXDytxZWosXs1Bw,106902
 jarvis_ui/indicators/failed_ss.wav,sha256=B9Gro32SnMc2WxEuaD238CUtk2v61CgD26Mt7brOTsE,99372
 jarvis_ui/indicators/failed_win.wav,sha256=V4gYEl3tOvyfvI9A0fUpuTWqi6Accrw8NChnAewPduY,103858
 jarvis_ui/indicators/restart_mac.wav,sha256=22CPSsqFACNgL9pfibSTuPz6t7-I7VSQ_77ZrcjP9QI,58530
 jarvis_ui/indicators/restart_ss.wav,sha256=i0f7_NLYh2gyT3ui30E5TMmWD1JuOFzZJloChtyixIo,48172
 jarvis_ui/indicators/restart_win.wav,sha256=J0nCm6nzEyxTW-zSYMSuO8zdszWHrSuVMjZ9ELLqwfQ,59106
 jarvis_ui/indicators/shutdown_mac.wav,sha256=5X509n-_vXmmCKCbwUVXdigJGbUlMn6KXm6WZuTGWYc,63820
 jarvis_ui/indicators/shutdown_ss.wav,sha256=BvZ6FAoB_Qy8fTPmHhzhLkBQFREFUb2Kp0QOMPJ8os0,50220
 jarvis_ui/indicators/shutdown_win.wav,sha256=pSMF0I5z5-fHk_8HEjifmfVBiSF9WxjC472ln1L1guY,63736
-jarvis_ui/lib/install.sh,sha256=CgUZ4pxO_eNruLC2badTwBaVIGBDMofyu5eFMDdTidY,4276
-jarvis_ui/lib/requirements.txt,sha256=zEencoThfZ1DLbDa71RP-kOZl5JLlzEg-Zxpo3frRfU,170
-jarvis_ui/modules/config.py,sha256=jVIaXo8K0E94uqVl3Yw4T3dvXcKzVB1Sqekk_C3l8L4,3876
-jarvis_ui/modules/exceptions.py,sha256=0MWISpz9E-CCObN8P0mkYI-Y6er8KJOXJi4CkdkLej4,2379
-jarvis_ui/modules/logger.py,sha256=FvF80SNXQOFL4S7T7H2DM_YfmAYkdThwNqYIES6TMuU,1454
-jarvis_ui/modules/models.py,sha256=FNIGORoIA2V_lxiIIBf8nNCdn4vnd067QeolFbPqtfA,6416
-jarvis_ui/modules/peripherals.py,sha256=rXM5MfZJHjuCLiAKMlh9HFqIx3VBAYpFisjTBodPUnc,1469
-jarvis_ui/modules/timer.py,sha256=zhgqMNK6WNWMLv51J3X37VN8aFv7HzLh4qBrUoIk7X0,1460
-jarvis_ui-2.3.data/scripts/install.sh,sha256=CgUZ4pxO_eNruLC2badTwBaVIGBDMofyu5eFMDdTidY,4276
-jarvis_ui-2.3.dist-info/LICENSE,sha256=gg8ZJZhenP19y9coBRHWLMCEVEKnQzkobEMpVhE7eDg,1079
-jarvis_ui-2.3.dist-info/METADATA,sha256=LodBUJmyqDgJLIAGEgpQKZNSHHvR5fo8HZSOODzK-ak,9622
-jarvis_ui-2.3.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-jarvis_ui-2.3.dist-info/top_level.txt,sha256=jSppTuWThuyhlfMRex4uG68JfFzX13ElLcV9ZUaaTBE,10
-jarvis_ui-2.3.dist-info/RECORD,,
+jarvis_ui/lib/install.sh,sha256=mpWIfmOfyM29zJ2JRNODB8dCQQeoQNWCF4I62-y6SOA,5487
+jarvis_ui/lib/requirements.txt,sha256=jttr0hM4ctp_SSe2W8WSXIzbCqVtxamtSvXS-jhYZHQ,145
+jarvis_ui/lib/squire/detector.sh,sha256=nEpQbzwMlMnnTmY-RSf7NltjhgYOhsX28rzeotPlZIE,1666
+jarvis_ui/modules/config.py,sha256=UyX8nfH2S7Q9dwKKcf_MbCWQpHSsQtPmiWmpv06_TcY,3910
+jarvis_ui/modules/exceptions.py,sha256=f2bV59nbeT2yTIcXXuVdGdyDuDQxdt4MrpEmbiBsCPA,2043
+jarvis_ui/modules/logger.py,sha256=ZjY7uXUoEpSYda7n6JIeID4SsrDSf_Xp1m1DFnqvtSg,1498
+jarvis_ui/modules/models.py,sha256=XPXGua6uZoZJbG5u6t6pyNrriCzxBNjxltqiFWWmTng,6702
+jarvis_ui/modules/peripherals.py,sha256=ZDesMQ_mlkb5y-ppfEjMwO4OXnLr3yLvnOL-vdjFTEU,1541
+jarvis_ui/modules/timer.py,sha256=qN2XNrGEyP3stsK3McvhE3VvIiUFh7mv4rbp5WDeyVU,1498
+jarvis_ui-2.3.1.data/scripts/detector.sh,sha256=nEpQbzwMlMnnTmY-RSf7NltjhgYOhsX28rzeotPlZIE,1666
+jarvis_ui-2.3.1.data/scripts/install.sh,sha256=mpWIfmOfyM29zJ2JRNODB8dCQQeoQNWCF4I62-y6SOA,5487
+jarvis_ui-2.3.1.dist-info/LICENSE,sha256=Mt4Kd3HfxBic9vkEe-Q9nwl27S_r0tv9ha4dcnFQXEk,1068
+jarvis_ui-2.3.1.dist-info/METADATA,sha256=RPWharwczdOdi5hhDSUhGeTPNTSOpXBbvYR31wJmgYs,9662
+jarvis_ui-2.3.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+jarvis_ui-2.3.1.dist-info/top_level.txt,sha256=jSppTuWThuyhlfMRex4uG68JfFzX13ElLcV9ZUaaTBE,10
+jarvis_ui-2.3.1.dist-info/RECORD,,
```

