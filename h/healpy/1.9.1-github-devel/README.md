# Comparing `tmp/healpy-1.9.1.tar.gz` & `tmp/healpy-github-devel.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/healpy-1.9.1.tar", last modified: Tue Nov 17 22:13:07 2015, max compression
+gzip compressed data, was "dist/healpy-github-devel.tar", last modified: Mon Apr 30 22:25:01 2012, max compression
```

## Comparing `healpy-1.9.1.tar` & `healpy-github-devel.tar`

### file list

```diff
@@ -1,425 +1,166 @@
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1171 2015-09-24 19:28:15.000000 healpy-1.9.1/CITATION
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/cfitsio/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    73540 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcoluk.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   144127 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcolj.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2157 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/region.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3534 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/README_OLD.win
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   114708 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getkey.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2144 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/README.MacOS
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    38454 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrsmem.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    47016 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fits_hcompress.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      871 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval_tab.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3319 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_var.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    75429 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcolsb.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6023 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/README
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5253 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_a.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    37942 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcold.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12754 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/makefile.bc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    15511 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/speed.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34849 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolsb.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2307 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/makepc.bat
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)    45044 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/config.guess
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    38506 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcole.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    74643 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/histo.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   243303 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval_y.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    63350 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fits_hdecompress.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6134 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/README.win
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    20544 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/longnam.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    18040 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/makefile.vcc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     9368 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/imcopy.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    30203 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cookbook.f
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    64410 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/modkey.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    31191 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/edithdu.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23366 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cfitsio_mac.sit.hqx
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    35267 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/wcssub.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   408960 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_b.fit
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34421 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcoluj.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1926 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/group.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    60603 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval_l.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    53206 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/buffers.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    66240 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testf77.std
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    72819 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcolk.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3782 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/vmsieee.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   174335 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/group.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    72946 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcoli.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2808 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/CMakeLists.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    76625 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcolb.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    16769 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/wcsutil.c
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)     5585 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/install-sh
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6007 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_c.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13733 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcoll.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    57452 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iraffits.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    21858 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cookbook.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   304272 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fitscore.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6874 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_a.f
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7155 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fpack.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    98687 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval_f.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    84665 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/editcol.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      787 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrgsiftp.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4464 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/funpack.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    36817 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrmem.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    17588 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/checksum.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    46698 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/grparser.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3076 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_image.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    16828 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/configure.in
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   135034 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cfortran.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4257 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/winDumpExts.mak
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6536 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrsmem.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    73668 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fpackutil.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   239145 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cfileio.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3581 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/sample.tpl
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34849 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcoli.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    35218 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/ricecomp.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10430 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77_wrap.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5813 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/grparser.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    73128 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcoluj.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1410 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/License.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23137 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcoll.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   129600 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_a.fit
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    39692 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcol.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8973 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/scalnull.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34285 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolui.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10525 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_c.f
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    32223 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testprog.out
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    21503 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolu.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5679 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_b.f
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    28160 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrfile.c
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)    35070 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/config.sub
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    67398 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcole.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10905 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcols.c
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)   196991 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/configure
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    73319 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcolui.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    67292 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcold.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5458 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/Makefile.in
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12950 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/windumpexts.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    35761 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolk.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    19454 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77_wrap4.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2642 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fitscopy.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   107504 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putkey.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    92160 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_c.fit
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      257 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/cfitsio.pc.in
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    55605 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/region.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    65448 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcol.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7703 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/swapproc.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    33427 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testf77.out
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   358320 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/imcompress.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13582 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrgsiftp.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2564 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/smem.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3209 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/FindPthreads.cmake
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    16152 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval.l
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    14664 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fpack.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    59070 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fitsio2.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4254 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval_defs.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    85934 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testprog.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    29034 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/getcols.c
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/cfitsio/zlib/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    67975 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/deflate.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    52623 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inflate.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    22622 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/infback.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7136 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zutil.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    79564 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zlib.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13769 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inftrees.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13353 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zconf.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6399 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inflate.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      427 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inffast.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5031 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/adler32.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    16425 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zuncompress.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2928 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inftrees.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    17603 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zcompress.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13439 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inffast.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1977 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/uncompr.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12655 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/deflate.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7296 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/zutil.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    13664 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/crc32.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8472 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/trees.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    45225 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/trees.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6343 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/inffixed.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    30568 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/zlib/crc32.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    71319 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/drvrnet.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   118459 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/quantize.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    35091 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcoluk.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      396 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testprog.tpt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    70165 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolj.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    36648 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/putcolb.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    80140 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testf77.f
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7067 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/pliocomp.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    33542 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77_wrap3.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   113409 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/fitsio.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   177704 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/eval.y
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      853 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77.inc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12497 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77_wrap1.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    32385 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/f77_wrap2.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    69120 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/testprog.std
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3702 2015-09-24 19:28:40.000000 healpy-1.9.1/cfitsio/iter_b.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      939 2015-11-17 22:13:07.000000 healpy-1.9.1/PKG-INFO
--rw-rw-r--   0 zonca     (1000) zonca     (1000)       59 2015-11-17 22:13:07.000000 healpy-1.9.1/setup.cfg
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)        7 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/top_level.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)        1 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/dependency_links.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      939 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/PKG-INFO
--rw-rw-r--   0 zonca     (1000) zonca     (1000)       20 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/requires.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    15921 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy.egg-info/SOURCES.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      638 2015-11-17 22:05:28.000000 healpy-1.9.1/MANIFEST.in
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2577 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/__init__.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34360 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/visufunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1633 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/cookbook.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    32253 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/sphtfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    19548 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/zoomtool.py
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy/test/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)        0 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/__init__.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6895 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_fitsfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4875 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_pixelfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3877 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_query_disc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6848 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_sphtfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      512 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_doctest_cython.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1058 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_visufunc.py
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy/test/data/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      268 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/anafast_3_11_config_test_anafast.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      205 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/smoothing_3_11_config_test_smoothing_masked.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_W_v4_udgraded32_masked.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      199 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/anafast_3_11_config_test_anafast_nomask.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/cl_wmap_band_iqumap_r9_7yr_WVxspec_v4_udgraded32_II_lmax64_rmmono_3iter.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      191 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/smoothing_3_11_config_test_smoothing_notmasked.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   158400 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_W_v4_udgraded32_smoothed10deg_fortran.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/cl_wmap_band_iqumap_r9_7yr_W_v4_udgraded32_II_lmax64_rmmono_3iter.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    20160 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/gaussbeam_10arcmin_lmax512_pol.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/cl_wmap_band_iqumap_r9_7yr_W_v4_udgraded32_II_lmax64_rmmono_3iter_nomask.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_V_v4_udgraded32.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_V_v4_udgraded32_masked.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_temperature_analysis_mask_r9_7yr_v4_udgraded32.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   158400 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_W_v4_udgraded32_masked_smoothed10deg_fortran.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      217 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/synfast_3_11_config_test_synfast.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    17280 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/cl_wmap_band_iqumap_r9_7yr_W_v4_udgraded32_IQU_lmax64_rmmono_3iter.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/wmap_band_iqumap_r9_7yr_W_v4_udgraded32.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      336 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/anafast_3_11_config_test_anafast_xspectra.par
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   155520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/data/map_synfast_seed12345.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    40656 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/test/test_spinfunc.py
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy/src/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    20144 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_healpy_pixel_lib.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    19506 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_sphtools.pyx
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3935 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_pixelfunc.pyx
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12435 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_query_disc.pyx
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    30740 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/src/_healpy_sph_transform_lib.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   425233 2015-09-24 19:31:53.000000 healpy-1.9.1/healpy/src/_query_disc.cpp
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3166 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_healpy_fitsio_lib.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      350 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_healpy_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4956 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/src/_common.pxd
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   324256 2015-09-24 19:32:04.000000 healpy-1.9.1/healpy/src/_pixelfunc.cpp
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   614918 2015-09-24 19:31:57.000000 healpy-1.9.1/healpy/src/_sphtools.cpp
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7037 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/newvisufunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    35027 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/rotator.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    33639 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/projector.py
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpy/data/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   138240 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n2048.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0004.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   109440 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n02048.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00032.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0008.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0032.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    14400 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00064.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   270720 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n4096.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    60480 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n01024.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    14400 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0128.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23040 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00256.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00002.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    17280 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00128.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   207360 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n04096.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    34560 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00512.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   134067 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/totcls.dat
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0016.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    40320 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0512.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   532800 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n8192.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23040 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0256.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0064.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)   403200 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n08192.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00016.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    72000 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n1024.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00008.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/weight_ring_n00004.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/data/pixel_window_n0002.fits
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    39161 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/projaxes.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    50970 2015-11-17 22:05:28.000000 healpy-1.9.1/healpy/pixelfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)       20 2015-11-17 22:09:06.000000 healpy-1.9.1/healpy/version.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    22507 2015-09-24 19:28:15.000000 healpy-1.9.1/healpy/fitsfunc.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6326 2015-09-24 19:28:15.000000 healpy-1.9.1/README.rst
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3924 2015-11-17 22:08:53.000000 healpy-1.9.1/CHANGELOG.rst
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)    20862 2015-11-17 22:05:28.000000 healpy-1.9.1/setup.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    18011 2015-09-24 19:28:15.000000 healpy-1.9.1/COPYING
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      276 2015-09-24 19:28:15.000000 healpy-1.9.1/run_pykg_config.py
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3823 2015-09-24 19:28:15.000000 healpy-1.9.1/INSTALL.rst
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11434 2015-09-24 19:28:15.000000 healpy-1.9.1/ez_setup.py
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6939 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Makefile.am
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)    10346 2015-09-24 19:30:09.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/missing
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5839 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/configure.ac
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)    44826 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/config.guess
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2870 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/sse_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2509 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/c_utils.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      297 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/planck.make
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1666 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/walltime_c.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4860 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/c_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1457 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/walltime_c.c
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5306 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_vecsupport.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1432 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2078 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_almhelpers.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8785 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core_inc.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3048 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_ylmgen_c.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6794 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_ylmgen_c.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10436 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_geomhelpers.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1886 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_internal.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1717 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_almhelpers.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      509 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/planck.make
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1283 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6813 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_cxx.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    28304 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3764 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/libsharp.dox
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3847 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_complex_hacks.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     9773 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_lowlevel.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6458 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_geomhelpers.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1270 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_vecutil.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    27016 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core_inc2.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7366 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1304 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core_inchelper.c
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)    13663 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/install-sh
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)    20334 2015-09-24 19:30:09.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/depcomp
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      324 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/make_release
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12529 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/fitshandle.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2313 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/geom_utils.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2182 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/announce.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5026 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/ls_image.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3119 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/error_handling.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2919 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/geom_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2629 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/linear_map.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3252 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/trafos.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7908 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/math_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2580 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/colour.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4088 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/string_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7526 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/bstream.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4817 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/vec3.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1403 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/xcomplex.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10132 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/string_utils.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12947 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/sse_utils_cxx.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4796 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/rotmatrix.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6542 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/walltimer.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4161 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/paramfile.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      586 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/planck.make
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4112 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/sort_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1763 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/error_handling.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3278 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/announce.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      671 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/levels_facilities.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2639 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/pointing.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3002 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/share_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4197 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/planck_rng.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3830 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/fftpack_support.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5982 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/wigner.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    16011 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/wigner.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1828 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/pointing.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6384 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/trafos.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      170 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/cxxsupport.dox
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5845 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/paramfile.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    14513 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/rangeset.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    40071 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/font_data.inc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5676 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/rotmatrix.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2982 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/lsconstants.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6100 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/compress_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7754 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/ls_image.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2669 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/alloc_utils.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2763 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/walltimer.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2152 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/openmp_support.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2114 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/safe_ptr.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2757 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/safe_cast.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23939 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/arr.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    11169 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/datatypes.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    23216 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/fitshandle.cc
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)    35454 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/config.sub
--rwxrwxr-x   0 zonca     (1000) zonca     (1000)   598235 2015-09-24 19:30:08.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/configure
--rw-r--r--   0 zonca     (1000) zonca     (1000)   283680 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/ltmain.sh
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    67003 2015-09-24 19:30:09.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Makefile.in
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7809 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_healpix_tools.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      192 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/smoothing_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3630 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec_fitsio.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4980 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/udgrade_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      196 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/median_filter_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7200 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_fitsio.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    10441 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      190 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/anafast_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2984 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/syn_alm_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4737 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/udgrade_harmonic_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2657 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/median_filter_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5806 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_tables.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    15087 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_healpix_tools.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    17012 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_base.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5256 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/mult_alm_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      869 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/syn_alm_cxx.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      199 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/udgrade_harmonic_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2918 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/moc_query.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4247 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      191 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/hotspots_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      191 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/calc_powspec.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2623 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/calc_powspec_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    40166 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_base.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1749 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_data_io.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    12191 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/moc_query.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1351 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/planck.make
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    15103 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_powspec_tools.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4571 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3247 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_data_io.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2690 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/moc_fitsio.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6965 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map_fitsio.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      903 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm2map_cxx.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3964 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/smoothing_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4647 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/anafast_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      186 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/map2tga.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2044 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/map2tga.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5237 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_powspec_tools.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    44298 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/hpxtest.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     9868 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/map2tga_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4866 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_fitsio.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      190 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/udgrade_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4111 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map_fitsio.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1588 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/moc_fitsio.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      911 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/smoothing_cxx.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      187 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/mult_alm.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2728 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4293 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/rotalm_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1314 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/anafast_cxx.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1398 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/mult_alm.par.txt
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      190 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/syn_alm_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5763 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     7192 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/moc.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      190 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm2map_cxx.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     2374 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec_fitsio.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1957 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_tables.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1518 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6054 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/Healpix_cxx.dox
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     3083 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/hotspots_cxx_module.cc
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     5128 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm2map_cxx_module.cc
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1637 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/README
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     4286 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/bluestein.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1868 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/fftpack.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     8511 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/fftpack_inc.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6419 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/ls_fft.h
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      375 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/planck.make
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    22235 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/fftpack.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)      102 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/libfftpack.dox
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     6966 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/ls_fft.c
--rw-rw-r--   0 zonca     (1000) zonca     (1000)     1413 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/bluestein.h
-drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2015-11-17 22:13:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/
--rw-r--r--   0 zonca     (1000) zonca     (1000)    12347 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/ltoptions.m4
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    14445 2015-09-24 19:28:49.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/m4_ax_create_pkgconfig_info.m4
--rw-r--r--   0 zonca     (1000) zonca     (1000)      690 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/ltversion.m4
--rw-r--r--   0 zonca     (1000) zonca     (1000)     4372 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/ltsugar.m4
--rw-r--r--   0 zonca     (1000) zonca     (1000)   287004 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/libtool.m4
--rw-r--r--   0 zonca     (1000) zonca     (1000)     6126 2015-09-24 19:30:05.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/m4/lt~obsolete.m4
--rw-rw-r--   0 zonca     (1000) zonca     (1000)    46293 2015-09-24 19:30:07.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/aclocal.m4
--rwxr-xr-x   0 zonca     (1000) zonca     (1000)     5675 2015-09-24 19:30:09.000000 healpy-1.9.1/healpixsubmodule/src/cxx/autotools/ar-lib
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2486 2012-04-19 17:56:56.000000 healpy-github-devel/INSTALL
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      272 2012-04-30 22:25:01.000000 healpy-github-devel/PKG-INFO
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/pshyt/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    20344 2012-04-04 21:48:07.000000 healpy-github-devel/pshyt/pshyt.pyx
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   507366 2012-04-04 23:50:37.000000 healpy-github-devel/pshyt/pshyt.c
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/cxxsupport/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    22767 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/arr.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2211 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/alloc_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2973 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/lsconstants.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      170 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/cxxsupport.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5669 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/math_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3095 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/error_handling.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1271 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/geom_utils.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1763 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/error_handling.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4817 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/vec3.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     6384 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/trafos.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2419 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/paramfile.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    10592 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/datatypes.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    13194 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/sse_utils_cxx.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3895 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/string_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4197 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/planck_rng.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2757 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/safe_cast.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2776 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/share_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    23120 2012-02-13 22:41:54.000000 healpy-github-devel/hpbeta/cxxsupport/fitshandle.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2919 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/geom_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5846 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/wigner.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      515 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4776 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/rotmatrix.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2076 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/openmp_support.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     9894 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/string_utils.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     7176 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/rangeset.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5496 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/paramfile.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3252 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/trafos.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2556 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/pointing.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     7560 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/xcomplex.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    15814 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/wigner.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5676 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/rotmatrix.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11649 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/fitshandle.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1766 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/cxxsupport/pointing.cc
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/libcfitsio/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      717 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libcfitsio/planck.make
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/libfftpack/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    22235 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/fftpack.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1868 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/fftpack.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      375 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4299 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/bluestein.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1349 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/bluestein.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      102 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/libfftpack.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8511 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/fftpack_inc.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     6422 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/ls_fft.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1637 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/README
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     6966 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libfftpack/ls_fft.c
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/libpsht/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     6618 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_cxx.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11273 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    33575 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/ylmgen_c.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8026 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_geomhelpers.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    15257 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4570 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/ylmgen_c.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4156 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_geomhelpers.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1694 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_almhelpers.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    37013 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_inc.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      406 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4776 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/libpsht.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2037 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/libpsht/psht_almhelpers.c
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/config/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      627 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/config/rules.common
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1344 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/config/config.healpy
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1363 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/config/config.healpy_osx
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/c_utils/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3818 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/c_utils/c_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2983 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/c_utils/sse_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      284 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/c_utils/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4124 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/c_utils/c_utils.c
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1185 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Makefile
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2062 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/README.compilation
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/docsrc/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      458 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/index_cxx.html
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     9722 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/cxxsupport.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     6517 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/sheet.css
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      123 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/footer.html
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      370 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     9760 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/Healpix_cxx.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     9685 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/libfftpack.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      240 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/docsrc/header.html
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    18011 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/COPYING
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/hpbeta/Healpix_cxx/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    14213 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_base.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4568 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/powspec.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1746 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_data_io.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1970 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_tables.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3244 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_data_io.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5427 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    13614 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm_powspec_tools.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    10255 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_map.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     7806 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm_healpix_tools.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4711 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm_powspec_tools.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4222 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/powspec.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1515 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    15265 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/alm_healpix_tools.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      498 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/planck.make
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    36175 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_base.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     5441 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/Healpix_cxx.dox
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2719 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_map.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     4859 2012-01-16 14:37:23.000000 healpy-github-devel/hpbeta/Healpix_cxx/healpix_tables.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    39186 2012-04-30 22:24:41.000000 healpy-github-devel/ChangeLog
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/healpy/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    26490 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/projector.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1002 2012-04-30 22:24:41.000000 healpy-github-devel/healpy/version.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    37441 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/projaxes.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    19372 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/zoomtool.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    26059 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/visufunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    31247 2012-04-30 21:09:43.000000 healpy-github-devel/healpy/sphtfunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1302 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/cookbook.py
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/healpy/src/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      112 2012-04-05 00:21:35.000000 healpy-github-devel/healpy/src/hack.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   451656 2012-04-19 17:27:30.000000 healpy-github-devel/healpy/src/_sphtools.cpp
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    30657 2012-04-19 17:26:53.000000 healpy-github-devel/healpy/src/_healpy_sph_transform_lib.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2877 2012-04-19 17:26:53.000000 healpy-github-devel/healpy/src/_healpy_fitsio_lib.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    14998 2012-04-19 17:26:53.000000 healpy-github-devel/healpy/src/_healpy_pixel_lib.cc
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      350 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/src/_healpy_utils.h
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   251710 2012-04-19 17:26:53.000000 healpy-github-devel/healpy/src/_query_disc.cpp
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    34807 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/rotator.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    15448 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/fitsfunc.py
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/healpy/data/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   207360 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n04096.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00002.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0016.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    17280 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00128.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   532800 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n8192.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    14400 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0128.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00032.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    40320 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0512.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0002.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    14400 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00064.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    23040 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00256.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    34560 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00512.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0008.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0032.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   403200 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n08192.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     8640 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0004.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00004.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   138240 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n2048.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    72000 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n1024.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    23040 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0256.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00008.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   270720 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n4096.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   134067 2012-04-05 00:21:35.000000 healpy-github-devel/healpy/data/totcls.dat
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    60480 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n01024.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n00016.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)   109440 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/weight_ring_n02048.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    11520 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/data/pixel_window_n0064.fits
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    42215 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/pixelfunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3208 2012-04-30 20:07:33.000000 healpy-github-devel/healpy/__init__.py
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/healpy/test/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      577 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/test/test_pixelfunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1071 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/test/test_query_disc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     2234 2012-01-16 14:37:23.000000 healpy-github-devel/healpy/test/test_fitsfunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     3041 2012-04-19 16:59:15.000000 healpy-github-devel/healpy/test/test_sphtfunc.py
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    18011 2012-01-16 14:37:23.000000 healpy-github-devel/COPYING
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)      365 2012-04-30 22:24:48.000000 healpy-github-devel/MANIFEST.in
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)    10569 2012-04-30 22:24:48.000000 healpy-github-devel/setup.py
+drwxrwxr-x   0 zonca     (1000) zonca     (1000)        0 2012-04-30 22:25:01.000000 healpy-github-devel/test/
+-rw-rw-r--   0 zonca     (1000) zonca     (1000)     1588 2012-01-16 14:37:23.000000 healpy-github-devel/test/test_fit_dipole.py
```

### Comparing `healpy-1.9.1/healpy/__init__.py` & `healpy-github-devel/healpy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -17,43 +17,73 @@
 # 
 #  For more information about Healpy, see http://code.google.com/p/healpy
 # 
 """HealPy is a package to manipulate Healpix maps (ang2pix, pix2ang) and
 compute spherical harmonics tranforms on them.
 """
 
-from .version import __version__
+import warnings
 
-from .pixelfunc import (ma, mask_good, mask_bad,
+try:
+    ImportWarning
+except NameError:
+    class ImportWarning(Warning):
+        pass
+
+from version import __version__
+
+from pixelfunc import (ma, mask_good, mask_bad,
                        ang2pix, pix2ang,
-                       xyf2pix, pix2xyf,
                        pix2vec, vec2pix,
                        vec2ang, ang2vec,
-                       nside2npix, npix2nside,
-                       nside2order, order2nside,
+                       nside2npix, npix2nside, 
                        isnsideok, isnpixok,
                        ring2nest, nest2ring, reorder,
-                       get_neighbours, get_all_neighbours, max_pixrad, get_interp_val,
-                       get_interp_weights,
+                       get_neighbours, get_all_neighbours, get_interp_val,
                        fit_dipole, fit_monopole,
                        remove_dipole, remove_monopole,
                        get_nside, maptype, ud_grade, nside2resol, nside2pixarea,
                        get_map_size)
 
-from .sphtfunc import (anafast, map2alm,
+from sphtfunc import (anafast, map2alm,
                       alm2map, Alm, synalm, synfast,
                       smoothing, smoothalm, almxfl, alm2cl,
-                      pixwin, alm2map_der1, gauss_beam)
-
-from ._query_disc import query_disc, query_strip, query_polygon, boundaries
-from ._pixelfunc import ringinfo, pix2ring
+                      pixwin, alm2map_der1)
 
-from ._sphtools import rotate_alm
-from ._sphtools import alm2map_spin_healpy as alm2map_spin
-from ._sphtools import map2alm_spin_healpy as map2alm_spin
-from .rotator import Rotator, vec2dir, dir2vec
-from ._healpy_pixel_lib import UNSEEN
-from .visufunc import (mollview,graticule,delgraticules,gnomview,
-                      projplot,projscatter, projtext, cartview, orthview)
-from .zoomtool import mollzoom,set_g_clim
-from .fitsfunc import write_map,read_map,mrdfits,mwrfits,read_alm,write_alm,write_cl,read_cl
+try:
+    from _query_disc import query_disc, query_strip, query_polygon
+except ImportError:
+    warnings.warn('Warning: cannot import query disc module')
+
+from zoomtool import mollzoom,set_g_clim
+
+from rotator import Rotator, vec2dir, dir2vec
+
+try:
+    from _healpy_pixel_lib import UNSEEN
+except ImportError:
+    warnings.warn('Warning: cannot import pixel lib module')
+
+try:
+    from pshyt import job
+    from pshyt import *
+except ImportError:
+    warnings.warn("Warning: Cannot import pshyt module)",
+                  category=ImportWarning)
+
+try:
+    from visufunc import (mollview,graticule,delgraticules,gnomview,
+                          projplot,projscatter, projtext, cartview)
+    if visufunc.matplotlib.__version__ == '0.98,3':
+        warnings.warn("Bug in matplotlib 0.98.3 prevents mollview from working\n"+
+                      "You should upgrade to matplotlib 0.98.4 or above",
+                      category=ImportWarning)
+except ImportError:
+    warnings.warn("Warning: Cannot import visualisation tools (needs matplotlib)",
+                  category=ImportWarning)
+
+try:
+    from fitsfunc import write_map,read_map,mrdfits,mwrfits,read_alm,write_alm,write_cl,read_cl
+except:
+    warnings.warn("Warning: Cannot import fits i/o tools (needs pyfits)",
+                  category=ImportWarning)
```

### Comparing `healpy-1.9.1/healpy/visufunc.py` & `healpy-github-devel/healpy/visufunc.py`

 * *Files 17% similar despite different names*

```diff
@@ -27,15 +27,14 @@
 
 Map projections
 ---------------
 
 - :func:`mollview` displays a map using Mollweide projection (full sky)
 - :func:`gnomview` displays a map using Gnomonic projection (local map)
 - :func:`cartview` displays a map using Cartesian projection
-- :func:`orthview` displays a map using Orthographic projection (full or half sky)
 
 Graticules
 ----------
 
 - :func:`graticule` adds a graticule to the current map
 - :func:`delgraticules` deletes all graticules of a map
 
@@ -43,41 +42,43 @@
 -----------------------
 
 - :func:`projplot` plots data points on the current map
 - :func:`projscatter` displays scatter points
 - :func:`projtext` display a text on the current map
 """
 
-__all__ = ['mollview', 'gnomview', 'cartview', 'orthview',
+__all__ = ['mollview', 'gnomview', 'cartview',
            'graticule', 'delgraticules',
            'projplot', 'projscatter', 'projtext']
 
-from . import projaxes as PA
+import projaxes as PA
+import pylab
 import numpy as np
 import matplotlib
-from . import pixelfunc
+import matplotlib.colors as colors
+import matplotlib.cbook as cbook
+import pixelfunc
 
 pi = np.pi
 dtor = pi/180.
 
 def mollview(map=None,fig=None,rot=None,coord=None,unit='',
              xsize=800,title='Mollweide view',nest=False,
              min=None,max=None,flip='astro',
              remove_dip=False,remove_mono=False,
              gal_cut=0,
              format='%g',format2='%g',
              cbar=True,cmap=None, notext=False,
-             norm=None,hold=False,margins=None,sub=None,
-             return_projected_map=False):
+             norm=None,hold=False,margins=None,sub=None):
     """Plot an healpix map (given as an array) in Mollweide projection.
     
     Parameters
     ----------
     map : float, array-like or None
-      An array containing the map, supports masked maps, see the `ma` function.
+      An array containing the map.
       If None, will display a blank map, useful for overplotting.
     fig : int or None, optional
       The figure number to use. Default: create a new figure
     rot : scalar or sequence, optional
       Describe the rotation to apply.
       In the form (lon, lat, psi) (unit: degrees) : the point at
       longitude *lon* and latitude *lat* will be at the center. An additional rotation
@@ -127,42 +128,39 @@
       Use only a zone of the current figure (same syntax as subplot).
       Default: None
     margins : None or sequence, optional
       Either None, or a sequence (left,bottom,right,top)
       giving the margins on left,bottom,right and top
       of the axes. Values are relative to figure (0-1).
       Default: None
-    return_projected_map : bool
-      if True returns the projected map in a 2d numpy array
 
     See Also
     --------
-    gnomview, cartview, orthview
+    gnomview, cartview
     """
     # Create the figure
-    import pylab
     if not (hold or sub):
         f=pylab.figure(fig,figsize=(8.5,5.4))
         extent = (0.02,0.05,0.96,0.9)
     elif hold:
         f=pylab.gcf()
         left,bottom,right,top = np.array(f.gca().get_position()).ravel()
         extent = (left,bottom,right-left,top-bottom)
         f.delaxes(f.gca())
     else: # using subplot syntax
         f=pylab.gcf()
         if hasattr(sub,'__len__'):
             nrows, ncols, idx = sub
         else:
-            nrows, ncols, idx = sub//100, (sub%100)//10, (sub%10)
+            nrows, ncols, idx = sub/100, (sub%100)/10, (sub%10)
         if idx < 1 or idx > ncols*nrows:
             raise ValueError('Wrong values for sub: %d, %d, %d'%(nrows,
                                                                  ncols,
                                                                  idx))
-        c,r = (idx-1)%ncols,(idx-1)//ncols
+        c,r = (idx-1)%ncols,(idx-1)/ncols
         if not margins:
             margins = (0.01,0.0,0.0,0.02)
         extent = (c*1./ncols+margins[0], 
                   1.-(r+1)*1./nrows+margins[1],
                   1./ncols-margins[2]-margins[0],
                   1./nrows-margins[3]-margins[1])
         extent = (extent[0]+margins[0],
@@ -175,26 +173,25 @@
     # Starting to draw : turn interactive off
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         if map is None:
             map = np.zeros(12)+np.inf
             cbar=False
-        map = pixelfunc.ma_to_array(map)
         ax=PA.HpxMollweideAxes(f,extent,coord=coord,rot=rot,
                                format=format2,flipconv=flip)
         f.add_axes(ax)
         if remove_dip:
             map=pixelfunc.remove_dipole(map,gal_cut=gal_cut,
                                         nest=nest,copy=True,
                                         verbose=True)
         elif remove_mono:
             map=pixelfunc.remove_monopole(map,gal_cut=gal_cut,nest=nest,
                                           copy=True,verbose=True)
-        img = ax.projmap(map,nest=nest,xsize=xsize,coord=coord,vmin=min,vmax=max,
+        ax.projmap(map,nest=nest,xsize=xsize,coord=coord,vmin=min,vmax=max,
                    cmap=cmap,norm=norm)
         if cbar:
             im = ax.get_images()[0]
             b = im.norm.inverse(np.linspace(0,1,im.cmap.N+1))
             v = np.linspace(im.norm.vmin,im.norm.vmax,im.cmap.N)
             if matplotlib.__version__ >= '0.91.0':
                 cb=f.colorbar(im,ax=ax,
@@ -204,47 +201,43 @@
                               format=format)
             else:
                 # for older matplotlib versions, no ax kwarg
                 cb=f.colorbar(im,orientation='horizontal',
                               shrink=0.5,aspect=25,ticks=PA.BoundaryLocator(),
                               pad=0.05,fraction=0.1,boundaries=b,values=v,
                               format=format)
-            cb.solids.set_rasterized(True)
         ax.set_title(title)
         if not notext:
             ax.text(0.86,0.05,ax.proj.coordsysstr,fontsize=14,
                     fontweight='bold',transform=ax.transAxes)
         if cbar:
             cb.ax.text(0.5,-1.0,unit,fontsize=14,
                        transform=cb.ax.transAxes,ha='center',va='center')
         f.sca(ax)
     finally:
         pylab.draw()
         if wasinteractive:
             pylab.ion()
             #pylab.show()
-    if return_projected_map:
-        return img
+
 
 def gnomview(map=None,fig=None,rot=None,coord=None,unit='',
-             xsize=200,ysize=None,reso=1.5,
+             xsize=200,ysize=None,reso=1.5,degree=False,
              title='Gnomonic view',nest=False,remove_dip=False,
              remove_mono=False,gal_cut=0,
              min=None,max=None,flip='astro',
              format='%.3g',cbar=True,
              cmap=None, norm=None,
-             hold=False,sub=None,margins=None,notext=False,
-             return_projected_map=False):
+             hold=False,sub=None,margins=None,notext=False):
     """Plot an healpix map (given as an array) in Gnomonic projection.
 
     Parameters
     ----------
     map : array-like
-      The map to project, supports masked maps, see the `ma` function.
-      If None, use a blank map, useful for
+      The map to project. If None, use a blank map, useful for
       overplotting.
     fig : None or int, optional
       A figure number. Default: None= create a new figure
     rot : scalar or sequence, optional
       Describe the rotation to apply.
       In the form (lon, lat, psi) (unit: degrees) : the point at
       longitude *lon* and latitude *lat* will be at the center. An additional rotation
@@ -256,15 +249,17 @@
     unit : str, optional
       A text describing the unit of the data. Default: ''
     xsize : int, optional
       The size of the image. Default: 200
     ysize : None or int, optional
       The size of the image. Default: None= xsize
     reso : float, optional
-      Resolution (in arcmin). Default: 1.5 arcmin
+      Resolution (in arcmin if degree is False). Default: 1.5 arcmin
+    degree : bool, optional
+      if True, reso is in degree. Default: False
     title : str, optional
       The title of the plot. Default: 'Gnomonic view'
     nest : bool, optional
       If True, ordering scheme is NESTED. Default: False (RING)
     min : float, scalar, optional
       The minimum range value
     max : float, scalar, optional
@@ -291,22 +286,19 @@
     margins : None or sequence, optional
       Either None, or a sequence (left,bottom,right,top)
       giving the margins on left,bottom,right and top
       of the axes. Values are relative to figure (0-1).
       Default: None
     notext: bool, optional
       If True: do not add resolution info text. Default=False
-    return_projected_map : bool
-      if True returns the projected map in a 2d numpy array
 
     See Also
     --------
-    mollview, cartview, orthview
+    mollview, cartview
     """
-    import pylab
     if not (hold or sub):
         f=pylab.figure(fig,figsize=(5.8,6.4))
         if not margins:
                 margins = (0.075,0.05,0.075,0.05)
         extent = (0.0,0.0,1.0,1.0)
     elif hold:
         f=pylab.gcf()
@@ -316,20 +308,20 @@
         extent = (left,bottom,right-left,top-bottom)
         f.delaxes(pylab.gca())
     else: # using subplot syntax
         f=pylab.gcf()
         if hasattr(sub,'__len__'):
             nrows, ncols, idx = sub
         else:
-            nrows, ncols, idx = sub//100, (sub%100)//10, (sub%10)
+            nrows, ncols, idx = sub/100, (sub%100)/10, (sub%10)
         if idx < 1 or idx > ncols*nrows:
             raise ValueError('Wrong values for sub: %d, %d, %d'%(nrows,
                                                                  ncols,
                                                                  idx))
-        c,r = (idx-1)%ncols,(idx-1)//ncols
+        c,r = (idx-1)%ncols,(idx-1)/ncols
         if not margins:
             margins = (0.01,0.0,0.0,0.02)
         extent = (c*1./ncols+margins[0], 
                   1.-(r+1)*1./nrows+margins[1],
                   1./ncols-margins[2]-margins[0],
                   1./nrows-margins[3]-margins[1])
     extent = (extent[0]+margins[0],
@@ -341,23 +333,22 @@
     # Starting to draw : turn interactive off
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         if map is None:
             map = np.zeros(12)+np.inf
             cbar=False
-        map = pixelfunc.ma_to_array(map)
         ax=PA.HpxGnomonicAxes(f,extent,coord=coord,rot=rot,
                               format=format,flipconv=flip)
         f.add_axes(ax)
         if remove_dip:
             map=pixelfunc.remove_dipole(map,gal_cut=gal_cut,nest=nest,copy=True)
         elif remove_mono:
             map=pixelfunc.remove_monopole(map,gal_cut=gal_cut,nest=nest,copy=True)
-        img = ax.projmap(map,nest=nest,coord=coord,vmin=min,vmax=max,
+        ax.projmap(map,nest=nest,coord=coord,vmin=min,vmax=max,
                    xsize=xsize,ysize=ysize,reso=reso,cmap=cmap,norm=norm)
         if cbar:
             im = ax.get_images()[0]
             b = im.norm.inverse(np.linspace(0,1,im.cmap.N+1))
             v = np.linspace(im.norm.vmin,im.norm.vmax,im.cmap.N)
             if matplotlib.__version__ >= '0.91.0':
                 cb=f.colorbar(im,ax=ax,
@@ -366,15 +357,14 @@
                               pad=0.08,fraction=0.1,boundaries=b,values=v,
                               format=format)
             else:
                 cb=f.colorbar(im,orientation='horizontal',
                               shrink=0.5,aspect=25,ticks=PA.BoundaryLocator(),
                               pad=0.08,fraction=0.1,boundaries=b,values=v,
                               format=format)
-            cb.solids.set_rasterized(True)                  
         ax.set_title(title)
         if not notext:
             ax.text(-0.07,0.02,
                      "%g '/pix,   %dx%d pix"%(ax.proj.arrayinfo['reso'],
                                               ax.proj.arrayinfo['xsize'],
                                               ax.proj.arrayinfo['ysize']),
                      fontsize=12,verticalalignment='bottom',
@@ -390,33 +380,30 @@
                        transform=cb.ax.transAxes,ha='left',va='center')
         f.sca(ax)
     finally:
         pylab.draw()
         if wasinteractive:
             pylab.ion()
             #pylab.show()
-    if return_projected_map:
-        return img
+
 
 def cartview(map=None,fig=None,rot=None,zat=None,coord=None,unit='',
              xsize=800,ysize=None,lonra=None,latra=None,
              title='Cartesian view',nest=False,remove_dip=False,
              remove_mono=False,gal_cut=0,
              min=None,max=None,flip='astro',
              format='%.3g',cbar=True,
              cmap=None, norm=None,aspect=None,
-             hold=False,sub=None,margins=None,notext=False,
-             return_projected_map=False):
+             hold=False,sub=None,margins=None,notext=False):
     """Plot an healpix map (given as an array) in Cartesian projection.
 
     Parameters
     ----------
     map : float, array-like or None
-      An array containing the map, 
-      supports masked maps, see the `ma` function.
+      An array containing the map.
       If None, will display a blank map, useful for overplotting.
     fig : int or None, optional
       The figure number to use. Default: create a new figure
     rot : scalar or sequence, optional
       Describe the rotation to apply.
       In the form (lon, lat, psi) (unit: degrees) : the point at
       longitude *lon* and latitude *lat* will be at the center. An additional rotation
@@ -468,22 +455,19 @@
       Use only a zone of the current figure (same syntax as subplot).
       Default: None
     margins : None or sequence, optional
       Either None, or a sequence (left,bottom,right,top)
       giving the margins on left,bottom,right and top
       of the axes. Values are relative to figure (0-1).
       Default: None
-    return_projected_map : bool
-      if True returns the projected map in a 2d numpy array
 
     See Also
     --------
-    mollview, gnomview, orthview
+    mollview, gnomview
     """
-    import pylab
     if not (hold or sub):
         f=pylab.figure(fig,figsize=(8.5,5.4))
         if not margins:
                 margins = (0.075,0.05,0.075,0.05)
         extent = (0.0,0.0,1.0,1.0)
     elif hold:
         f=pylab.gcf()
@@ -493,20 +477,20 @@
         extent = (left,bottom,right-left,top-bottom)
         f.delaxes(pylab.gca())
     else: # using subplot syntax
         f=pylab.gcf()
         if hasattr(sub,'__len__'):
             nrows, ncols, idx = sub
         else:
-            nrows, ncols, idx = sub//100, (sub%100)//10, (sub%10)
+            nrows, ncols, idx = sub/100, (sub%100)/10, (sub%10)
         if idx < 1 or idx > ncols*nrows:
             raise ValueError('Wrong values for sub: %d, %d, %d'%(nrows,
                                                                  ncols,
                                                                  idx))
-        c,r = (idx-1)%ncols,(idx-1)//ncols
+        c,r = (idx-1)%ncols,(idx-1)/ncols
         if not margins:
             margins = (0.01,0.0,0.0,0.02)
         extent = (c*1./ncols+margins[0], 
                   1.-(r+1)*1./nrows+margins[1],
                   1./ncols-margins[2]-margins[0],
                   1./nrows-margins[3]-margins[1])
     extent = (extent[0]+margins[0],
@@ -518,29 +502,28 @@
     # Starting to draw : turn interactive off
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         if map is None:
             map = np.zeros(12)+np.inf
             cbar=False
-        map = pixelfunc.ma_to_array(map)
         if zat and rot:
             raise ValueError('Only give rot or zat, not both')
         if zat:
             rot = np.array(zat,dtype=np.float64)
             rot.resize(3)
             rot[1] -= 90
         ax=PA.HpxCartesianAxes(f,extent,coord=coord,rot=rot,
                                format=format,flipconv=flip)
         f.add_axes(ax)
         if remove_dip:
             map=pixelfunc.remove_dipole(map,gal_cut=gal_cut,nest=nest,copy=True)
         elif remove_mono:
             map=pixelfunc.remove_monopole(map,gal_cut=gal_cut,nest=nest,copy=True)
-        img = ax.projmap(map,nest=nest,coord=coord,vmin=min,vmax=max,
+        ax.projmap(map,nest=nest,coord=coord,vmin=min,vmax=max,
                    xsize=xsize,ysize=ysize,lonra=lonra,latra=latra,
                    cmap=cmap,norm=norm,aspect=aspect)
         if cbar:
             im = ax.get_images()[0]
             b = im.norm.inverse(np.linspace(0,1,im.cmap.N+1))
             v = np.linspace(im.norm.vmin,im.norm.vmax,im.cmap.N)
             if matplotlib.__version__ >= '0.91.0':
@@ -550,200 +533,27 @@
                               pad=0.08,fraction=0.1,boundaries=b,values=v,
                               format=format)
             else:
                 cb=f.colorbar(im,orientation='horizontal',
                               shrink=0.5,aspect=25,ticks=PA.BoundaryLocator(),
                               pad=0.08,fraction=0.1,boundaries=b,values=v,
                               format=format)
-            cb.solids.set_rasterized(True)                 
         ax.set_title(title)
         if not notext:
             ax.text(-0.07,0.6,ax.proj.coordsysstr,fontsize=14,
                      fontweight='bold',rotation=90,transform=ax.transAxes)
         if cbar:
             cb.ax.text(1.05,0.30,unit,fontsize=14,fontweight='bold',
                        transform=cb.ax.transAxes,ha='left',va='center')
         f.sca(ax)
     finally:
         if wasinteractive:
             pylab.ion()
             pylab.draw()
             #pylab.show()
-    if return_projected_map:
-        return img
-
-def orthview(map=None,fig=None,rot=None,coord=None,unit='',
-             xsize=800,half_sky=False,
-             title='Orthographic view',nest=False,
-             min=None,max=None,flip='astro',
-             remove_dip=False,remove_mono=False,
-             gal_cut=0,
-             format='%g',format2='%g',
-             cbar=True,cmap=None, notext=False,
-             norm=None,hold=False,margins=None,sub=None,
-             return_projected_map=False):
-    """Plot an healpix map (given as an array) in Orthographic projection.
-    
-    Parameters
-    ----------
-    map : float, array-like or None
-      An array containing the map.
-      If None, will display a blank map, useful for overplotting.
-    fig : int or None, optional
-      The figure number to use. Default: create a new figure
-    rot : scalar or sequence, optional
-      Describe the rotation to apply.
-      In the form (lon, lat, psi) (unit: degrees) : the point at
-      longitude *lon* and latitude *lat* will be at the center. An additional rotation
-      of angle *psi* around this direction is applied.
-    coord : sequence of character, optional
-      Either one of 'G', 'E' or 'C' to describe the coordinate
-      system of the map, or a sequence of 2 of these to rotate
-      the map from the first to the second coordinate system.
-    half_sky : bool, optional
-      Plot only one side of the sphere. Default: False
-    unit : str, optional
-      A text describing the unit of the data. Default: ''
-    xsize : int, optional
-      The size of the image. Default: 800
-    title : str, optional
-      The title of the plot. Default: 'Orthographic view'
-    nest : bool, optional
-      If True, ordering scheme is NESTED. Default: False (RING)
-    min : float, optional
-      The minimum range value
-    max : float, optional
-      The maximum range value
-    flip : {'astro', 'geo'}, optional
-      Defines the convention of projection : 'astro' (default, east towards left, west towards right)
-      or 'geo' (east towards roght, west towards left)
-    remove_dip : bool, optional
-      If :const:`True`, remove the dipole+monopole
-    remove_mono : bool, optional
-      If :const:`True`, remove the monopole
-    gal_cut : float, scalar, optional
-      Symmetric galactic cut for the dipole/monopole fit.
-      Removes points in latitude range [-gal_cut, +gal_cut]
-    format : str, optional
-      The format of the scale label. Default: '%g'
-    format2 : str, optional
-      Format of the pixel value under mouse. Default: '%g'
-    cbar : bool, optional
-      Display the colorbar. Default: True
-    notext : bool, optional
-      If True, no text is printed around the map
-    norm : {'hist', 'log', None}
-      Color normalization, hist= histogram equalized color mapping,
-      log= logarithmic color mapping, default: None (linear color mapping)
-    hold : bool, optional
-      If True, replace the current Axes by an OrthographicAxes.
-      use this if you want to have multiple maps on the same
-      figure. Default: False
-    sub : int, scalar or sequence, optional
-      Use only a zone of the current figure (same syntax as subplot).
-      Default: None
-    margins : None or sequence, optional
-      Either None, or a sequence (left,bottom,right,top)
-      giving the margins on left,bottom,right and top
-      of the axes. Values are relative to figure (0-1).
-      Default: None
-    return_projected_map : bool
-      if True returns the projected map in a 2d numpy array
-    
-    See Also
-    --------
-    mollview, gnomview, cartview
-    """
-    # Create the figure
-    import pylab
-    if not (hold or sub):
-        f=pylab.figure(fig,figsize=(8.5,5.4))
-        extent = (0.02,0.05,0.96,0.9)
-    elif hold:
-        f=pylab.gcf()
-        left,bottom,right,top = np.array(f.gca().get_position()).ravel()
-        extent = (left,bottom,right-left,top-bottom)
-        f.delaxes(f.gca())
-    else: # using subplot syntax
-        f=pylab.gcf()
-        if hasattr(sub,'__len__'):
-            nrows, ncols, idx = sub
-        else:
-            nrows, ncols, idx = sub//100, (sub%100)//10, (sub%10)
-        if idx < 1 or idx > ncols*nrows:
-            raise ValueError('Wrong values for sub: %d, %d, %d'%(nrows,
-                                                                 ncols,
-                                                                 idx))
-        c,r = (idx-1)%ncols,(idx-1)//ncols
-        if not margins:
-            margins = (0.01,0.0,0.0,0.02)
-        extent = (c*1./ncols+margins[0],
-                  1.-(r+1)*1./nrows+margins[1],
-                  1./ncols-margins[2]-margins[0],
-                  1./nrows-margins[3]-margins[1])
-        extent = (extent[0]+margins[0],
-                  extent[1]+margins[1],
-                  extent[2]-margins[2]-margins[0],
-                  extent[3]-margins[3]-margins[1])
-        #extent = (c*1./ncols, 1.-(r+1)*1./nrows,1./ncols,1./nrows)
-    #f=pylab.figure(fig,figsize=(8.5,5.4))
-    
-    # Starting to draw : turn interactive off
-    wasinteractive = pylab.isinteractive()
-    pylab.ioff()
-    try:
-        if map is None:
-            map = np.zeros(12)+np.inf
-            cbar=False
-        ax=PA.HpxOrthographicAxes(f,extent,coord=coord,rot=rot,
-                                  format=format2,flipconv=flip)
-        f.add_axes(ax)
-        if remove_dip:
-            map=pixelfunc.remove_dipole(map,gal_cut=gal_cut,
-                                        nest=nest,copy=True,
-                                        verbose=True)
-        elif remove_mono:
-            map=pixelfunc.remove_monopole(map,gal_cut=gal_cut,nest=nest,
-                                          copy=True,verbose=True)
-        img = ax.projmap(map,nest=nest,xsize=xsize,half_sky=half_sky,
-                         coord=coord,vmin=min,vmax=max,
-                         cmap=cmap,norm=norm)
-        if cbar:
-            im = ax.get_images()[0]
-            b = im.norm.inverse(np.linspace(0,1,im.cmap.N+1))
-            v = np.linspace(im.norm.vmin,im.norm.vmax,im.cmap.N)
-            if matplotlib.__version__ >= '0.91.0':
-                cb=f.colorbar(im,ax=ax,
-                              orientation='horizontal',
-                              shrink=0.5,aspect=25,ticks=PA.BoundaryLocator(),
-                              pad=0.05,fraction=0.1,boundaries=b,values=v,
-                              format=format)
-            else:
-                # for older matplotlib versions, no ax kwarg
-                cb=f.colorbar(im,orientation='horizontal',
-                              shrink=0.5,aspect=25,ticks=PA.BoundaryLocator(),
-                              pad=0.05,fraction=0.1,boundaries=b,values=v,
-                              format=format)
-            cb.solids.set_rasterized(True)                  
-        ax.set_title(title)
-        if not notext:
-            ax.text(0.86,0.05,ax.proj.coordsysstr,fontsize=14,
-                    fontweight='bold',transform=ax.transAxes)
-        if cbar:
-            cb.ax.text(0.5,-1.0,unit,fontsize=14,
-                       transform=cb.ax.transAxes,ha='center',va='center')
-        f.sca(ax)
-    finally:
-        pylab.draw()
-        if wasinteractive:
-            pylab.ion()
-            #pylab.show()
-    if return_projected_map:
-        return img
-
 
 def graticule(dpar=None,dmer=None,coord=None,local=None,**kwds):
     """Draw a graticule on the current Axes.
 
     Parameters
     ----------
     dpar, dmer : float, scalars
@@ -759,15 +569,14 @@
     -----
     Other keyword parameters will be transmitted to the projplot function.
 
     See Also
     --------
     delgraticules
     """
-    import pylab
     f = pylab.gcf()
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         if len(f.get_axes()) == 0:
             ax=PA.HpxMollweideAxes(f,(0.02,0.05,0.96,0.9),coord=coord)
             f.add_axes(ax)
@@ -777,38 +586,37 @@
             if isinstance(ax,PA.SphericalProjAxes):
                 ax.graticule(dpar=dpar,dmer=dmer,coord=coord,
                              local=local,**kwds)
     finally:
         pylab.draw()
         if wasinteractive:
             pylab.ion()
+            #pylab.show()
     
 def delgraticules():
     """Delete all graticules previously created on the Axes.
 
     See Also
     --------
     graticule
     """
-    import pylab
     f = pylab.gcf()
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         for ax in f.get_axes():
             if isinstance(ax,PA.SphericalProjAxes):
                 ax.delgraticules()
     finally:
         pylab.draw()
         if wasinteractive:
             pylab.ion()
             #pylab.show()
 
 def projplot(*args,**kwds):
-    import pylab
     f = pylab.gcf()
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     ret = None
     try:
         for ax in f.get_axes():
             if isinstance(ax,PA.SphericalProjAxes):
@@ -818,15 +626,14 @@
         if wasinteractive:
             pylab.ion()
             #pylab.show()
     return ret
 projplot.__doc__ = PA.SphericalProjAxes.projplot.__doc__
     
 def projscatter(*args,**kwds):
-    import pylab
     f = pylab.gcf()
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     ret=None
     try:
         for ax in f.get_axes():
             if isinstance(ax,PA.SphericalProjAxes):
@@ -836,15 +643,14 @@
         if wasinteractive:
             pylab.ion()
             #pylab.show()
     return ret
 projscatter.__doc__ = PA.SphericalProjAxes.projscatter.__doc__
 
 def projtext(*args,**kwds):
-    import pylab
     f = pylab.gcf()
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     ret = None
     try:
         for ax in f.get_axes():
             if isinstance(ax,PA.SphericalProjAxes):
@@ -852,7 +658,9 @@
     finally:
         pylab.draw()
         if wasinteractive:
             pylab.ion()
             #pylab.show()
     return ret
 projtext.__doc__ = PA.SphericalProjAxes.projtext.__doc__
+
+
```

### Comparing `healpy-1.9.1/healpy/cookbook.py` & `healpy-github-devel/healpy/cookbook.py`

 * *Files 14% similar despite different names*

```diff
@@ -57,25 +57,8 @@
         if not is_seq(s):
             return False
         if size is None:
             size = len(s)
         if len(s) != size:
             return False
     return True
-
-
-def len_array_or_arrays(o):
-    """Returns the length of a single array or list of arrays
     
-    Parameters
-    ----------
-    o : either array or sequence of arrays
-
-    Returns
-    -------
-    length : length of array
-    """
-    if is_seq_of_seq(o):
-        length = len(o[0])
-    else:
-        length = len(o)
-    return length
```

### Comparing `healpy-1.9.1/healpy/sphtfunc.py` & `healpy-github-devel/healpy/sphtfunc.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,46 +14,39 @@
 #  You should have received a copy of the GNU General Public License
 #  along with Healpy; if not, write to the Free Software
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 # 
 #  For more information about Healpy, see http://code.google.com/p/healpy
 # 
 import warnings
+import exceptions
 import numpy as np
-import six
 pi = np.pi
-import warnings
 
-try:
-    import astropy.io.fits as pf
-except ImportError:
-    import pyfits as pf
-
-from . import _healpy_sph_transform_lib as sphtlib
-from . import _healpy_fitsio_lib as hfitslib
-from . import _sphtools as _sphtools
-from . import cookbook as cb
+import _healpy_sph_transform_lib as sphtlib
+import _healpy_fitsio_lib as hfitslib
+import _sphtools as _sphtools
+import healpy.cookbook as cb
 
 import os.path
-from . import pixelfunc
+import healpy.pixelfunc as pixelfunc
 
-from .pixelfunc import maptype, UNSEEN, ma_to_array, accept_ma
+from healpy.pixelfunc import mask_bad, maptype, UNSEEN
 
 class FutureChangeWarning(UserWarning):
     pass
 
 DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
 
 # Spherical harmonics transformation
 def anafast(map1, map2 = None, nspec = None, lmax = None, mmax = None, 
             iter = 3, alm = False, pol = True, use_weights = False,
-            datapath = None):
+            regression = True, datapath = None):
     """Computes the power spectrum of an Healpix map, or the cross-spectrum
     between two maps if *map2* is given.
-    No removal of monopole or dipole is performed.
 
     Parameters
     ----------
     map1 : float, array-like shape (Npix,) or (3, Npix)
       Either an array representing a map, or a sequence of 3 arrays
       representing I, Q, U maps
     map2 : float, array-like shape (Npix,) or (3, Npix)
@@ -72,36 +65,35 @@
       If True, returns both cl and alm, otherwise only cl is returned
     pol : bool, optional
       If True, assumes input maps are TQU. Output will be TEB cl's and
       correlations (input must be 1 or 3 maps).
       If False, maps are assumed to be described by spin 0 spherical harmonics.
       (input can be any number of maps)
       If there is only one input map, it has no effect. Default: True.
+    regression : bool, scalar, optional
+      If True, map average is removed before computing alm. Default: True.
     datapath : None or str, optional
       If given, the directory where to find the weights data.
 
     Returns
     -------
     res : array or sequence of arrays
       If *alm* is False, returns cl or a list of cl's (TT, EE, BB, TE, EB, TB for
       polarized input map)
       Otherwise, returns a tuple (cl, alm), where cl is as above and
       alm is the spherical harmonic transform or a list of almT, almE, almB
       for polarized input
     """
-
-    map1 = ma_to_array(map1)
     alms1 = map2alm(map1, lmax = lmax, mmax = mmax, pol = pol, iter = iter, 
-                    use_weights = use_weights,
+                    use_weights = use_weights, regression = regression, 
                     datapath = datapath)
     if map2 is not None:
-        map2 = ma_to_array(map2)
         alms2 = map2alm(map2, lmax = lmax, mmax = mmax, pol = pol,
                         iter = iter, use_weights = use_weights, 
-                        datapath = datapath)
+                        regression = regression, datapath = datapath)
     else:
         alms2 = None
     
     cls = alm2cl(alms1, alms2 = alms2, lmax = lmax, mmax = mmax,
                  lmax_out = lmax, nspec = nspec)
 
     if alm:
@@ -109,15 +101,15 @@
             return (cls, alms1, alms2)
         else:
             return (cls, alms1)
     else:
         return cls
 
 def map2alm(maps, lmax = None, mmax = None, iter = 3, pol = True, 
-            use_weights = False, datapath = None):
+            use_weights = False, regression = True, datapath = None):
     """Computes the alm of an Healpix map.
     
     Parameters
     ----------
     maps : array-like, shape (Npix,) or (n, Npix)
       The input map or a list of n input maps.
     lmax : int, scalar, optional
@@ -130,14 +122,16 @@
       If True, assumes input maps are TQU. Output will be TEB alm's.
       (input must be 1 or 3 maps)
       If False, apply spin 0 harmonic transform to each map.
       (input can be any number of maps)
       If there is only one input map, it has no effect. Default: True.
     use_weights: bool, scalar, optional
       If True, use the ring weighting. Default: False.
+    regression: bool, scalar, optional
+      If True, subtract map average before computing alm. Default: True.
     datapath : None or str, optional
       If given, the directory where to find the weights data.
     
     Returns
     -------
     alms : array or tuple of array
       alm or a tuple of 3 alm (almT, almE, almB) if polarized input.
@@ -145,31 +139,32 @@
     Notes
     -----
     The pixels which have the special `UNSEEN` value are replaced by zeros
     before spherical harmonic transform. They are converted back to `UNSEEN`
     value, so that the input maps are not modified. Each map have its own, 
     independent mask.
     """
-    maps = ma_to_array(maps)
     info = maptype(maps)
+    if info < 0:
+        raise TypeError("Input must be a map or a sequence of maps")
     if pol or info in (0, 1):
-        alms = _sphtools.map2alm(maps, niter = iter, 
+        alms = _sphtools.map2alm(maps, niter = iter, regression = regression, 
                                  datapath = datapath, use_weights = use_weights,
                                  lmax = lmax, mmax = mmax)
     else:
         # info >= 2 and pol is False : spin 0 spht for each map
-        alms = [_sphtools.map2alm(mm, niter = iter,
+        alms = [_sphtools.map2alm(mm, niter = iter, regression = regression,
                                   datapath = datapath, use_weights = use_weights,
                                   lmax = lmax, mmax = mmax)
-               for mm in maps]
+               for mm in m]
     return alms
 
 def alm2map(alms, nside, lmax = None, mmax = None, pixwin = False,
-            fwhm = 0.0, sigma = None,  pol = True,
-            inplace = False, verbose=True):
+            fwhm = 0.0, sigma = None, invert = False, pol = True,
+            inplace = False):
     """Computes an Healpix map given the alm.
 
     The alm are given as a complex array. You can specify lmax
     and mmax, or they will be computed from array size (assuming
     lmax==mmax).
 
     Parameters
@@ -187,14 +182,18 @@
       Smooth the alm using the pixel window functions. Default: False.
     fwhm : float, scalar, optional
       The fwhm of the Gaussian used to smooth the map (applied on alm)
       [in radians]
     sigma : float, scalar, optional
       The sigma of the Gaussian used to smooth the map (applied on alm)
       [in radians]
+    invert : bool, optional
+      If True, alms are divided by Gaussian beam function (un-smooth).
+      Otherwise, alms are multiplied by Gaussian beam function (smooth).
+      Default: False.
     pol : bool, optional
       If True, assumes input alms are TEB. Output will be TQU maps.
       (input must be 1 or 3 alms)
       If False, apply spin 0 harmonic transform to each alm.
       (input can be any number of alms)
       If there is only one input alm, it has no effect. Default: True.
     inplace : bool, optional
@@ -208,16 +207,16 @@
     maps : array or list of arrays
       An Healpix map in RING scheme at nside or a list of T,Q,U maps (if
       polarized input)
     """
     if not cb.is_seq(alms):
         raise TypeError("alms must be a sequence")
 
-    alms = smoothalm(alms, fwhm = fwhm, sigma = sigma,  
-                     pol = pol, inplace = inplace, verbose=verbose)
+    alms = smoothalm(alms, fwhm = fwhm, sigma = sigma, invert = invert, 
+                     pol = pol, inplace = inplace)
 
     if not cb.is_seq_of_seq(alms):
         alms = [alms]
         lonely = True
     else:
         lonely = False
     
@@ -243,15 +242,15 @@
         output = [sphtlib._alm2map(alm, nside, lmax = lmax, mmax = mmax)
                   for alm in alms_new]
     if lonely:
         return output[0]
     else:
         return output
 
-def synalm(cls, lmax = None, mmax = None, new = False, verbose=True):
+def synalm(cls, lmax = None, mmax = None, new = False):
     """Generate a set of alm given cl.
     The cl are given as a float array. Corresponding alm are generated.
     If lmax is None, it is assumed lmax=cl.size-1
     If mmax is None, it is assumed mmax=lmax.
 
     Parameters
     ----------
@@ -284,15 +283,15 @@
     In the next version of healpy, the default will be new=True.
     This change is done for consistency between the different tools
     (alm2cl, synfast, anafast).
     In the new order, the spectra are ordered by diagonal of the correlation
     matrix. Eg, if fields are T, E, B, the spectra are TT, EE, BB, TE, EB, TB
     with new=True, and TT, TE, TB, EE, EB, BB if new=False.
     """
-    if (not new) and verbose:
+    if not new:
         warnings.warn("The order of the input cl's will change in a future "
                       "release.\n"
                       "Use new=True keyword to start using the new order.\n"
                       "See documentation of healpy.synalm.",
                       category=FutureChangeWarning)
     if not cb.is_seq(cls):
         raise TypeError('cls must be an array or a sequence of arrays')
@@ -332,42 +331,42 @@
             Nspec = 3
         else:
             raise TypeError("The sequence of arrays must have either 4 elements "
                             "or n(n+1)/2 elements (some may be None)")
     
     szalm = Alm.getsize(lmax,mmax)
     alms_list = []
-    for i in six.moves.xrange(Nspec):
+    for i in xrange(Nspec):
         alm = np.zeros(szalm,'D')
         alm.real = np.random.standard_normal(szalm)
         alm.imag = np.random.standard_normal(szalm)
         alms_list.append(alm)
     if new: # new input order: input given by diagonal, should be given by row
         cls_list = new_to_old_spectra_order(cls_list)
     # ensure cls are float64
     cls_list = [(np.asarray(cl, dtype = np.float64) if cl is not None else None)
                 for cl in cls_list]
     sphtlib._synalm(cls_list, alms_list, lmax, mmax)
     return alms_list
 
 def synfast(cls, nside, lmax = None, mmax = None, alm = False,
             pol = True, pixwin = False, fwhm = 0.0, sigma = None,
-            new = False, verbose=True):
+            new = False):
     """Create a map(s) from cl(s).
 
     Parameters
     ----------
     cls : array or tuple of array
       A cl or a list of cl (either 4 or 6, see :func:`synalm`)
     nside : int, scalar
       The nside of the output map(s)
     lmax : int, scalar, optional
-      Maximum l for alm. Default: min of 3*nside-1 or length of the cls - 1
+      Maximum l for alm. Default: 3*nside-1
     mmax : int, scalar, optional
-      Maximum m for alm.
+      Maximum m for alm. Default: 3*nside-1
     alm : bool, scalar, optional
       If True, return also alm(s). Default: False.
     pol : bool, optional
       If True, assumes input cls are TEB and correlation. Output will be TQU maps.
       (input must be 1, 4 or 6 cl's)
       If False, fields are assumed to be described by spin 0 spherical harmonics.
       (input can be any number of cl's)
@@ -398,20 +397,19 @@
     (alm2cl, synfast, anafast).
     In the new order, the spectra are ordered by diagonal of the correlation
     matrix. Eg, if fields are T, E, B, the spectra are TT, EE, BB, TE, EB, TB
     with new=True, and TT, TE, TB, EE, EB, BB if new=False.
     """
     if not pixelfunc.isnsideok(nside):
         raise ValueError("Wrong nside value (must be a power of two).")
-    cls_lmax = cb.len_array_or_arrays(cls) -1
     if lmax is None or lmax < 0:
-        lmax = min(cls_lmax, 3 * nside - 1)
-    alms = synalm(cls, lmax = lmax, mmax = mmax, new = new, verbose=verbose)
+        lmax = 3 * nside - 1
+    alms = synalm(cls, lmax = lmax, mmax = mmax, new = new)
     maps = alm2map(alms, nside, lmax = lmax, mmax = mmax, pixwin = pixwin,
-                   pol = pol, fwhm = fwhm, sigma = sigma, inplace = True, verbose=verbose)
+                   pol = pol, fwhm = fwhm, sigma = sigma, inplace = True)
     if alm:
         return maps, alms
     else:
         return maps
     
 class Alm(object):
     """This class provides some static methods for alm index computation.
@@ -437,15 +435,15 @@
         i : int or None
           The index for which to compute the l and m.
           If None, the function return l and m for i=0..Alm.getsize(lmax)
         """
         if i is None:
             i=np.arange(Alm.getsize(lmax))
         m=(np.ceil(((2*lmax+1)-np.sqrt((2*lmax+1)**2-8*(i-lmax)))/2)).astype(int)
-        l = i-m*(2*lmax+1-m)//2
+        l = i-m*(2*lmax+1-m)/2
         return (l,m)
 
     @staticmethod
     def getidx(lmax,l,m):
         """Returns index corresponding to (l,m) in an array describing alm up to lmax.
         
         Parameters
@@ -458,15 +456,15 @@
           The m for which to get the index
 
         Returns
         -------
         idx : int
           The index corresponding to (l,m)
         """
-        return m*(2*lmax+1-m)//2+l
+        return m*(2*lmax+1-m)/2+l
 
     @staticmethod
     def getsize(lmax,mmax = None):
         """Returns the size of the array needed to store alm up to *lmax* and *mmax*
 
         Parameters
         ----------
@@ -478,15 +476,15 @@
         Returns
         -------
         size : int
           The size of the array needed to store alm up to lmax, mmax.
         """
         if mmax is None or mmax < 0 or mmax > lmax:
             mmax = lmax
-        return mmax * (2 * lmax + 1 - mmax) // 2 + lmax + 1
+        return mmax * (2 * lmax + 1 - mmax) / 2 + lmax + 1
 
     @staticmethod
     def getlmax(s, mmax = None):
         """Returns the lmax corresponding to a given array size.
         
         Parameters
         ----------
@@ -573,56 +571,60 @@
     alm : array
       The modified alm, either a new array or a reference to input alm, 
       if inplace is True.
     """
     almout = _sphtools.almxfl(alm, fl, mmax = mmax, inplace = inplace)
     return almout
 
-def smoothalm(alms, fwhm = 0.0, sigma = None,  pol = True,
-              mmax = None, verbose = True, inplace = True):
+def smoothalm(alms, fwhm = 0.0, sigma = None, invert = False, pol = True,
+              mmax = None, verbose = False, inplace = True):
     """Smooth alm with a Gaussian symmetric beam function.
 
     Parameters
     ----------
     alms : array or sequence of 3 arrays
       Either an array representing one alm, or a sequence of arrays.
       See *pol* parameter.
     fwhm : float, optional
       The full width half max parameter of the Gaussian. Default:0.0
       [in radians]
     sigma : float, optional
       The sigma of the Gaussian. Override fwhm.
       [in radians]
+    invert : bool, optional
+      If True, alms are divided by Gaussian beam function (un-smooth).
+      Otherwise, alms are multiplied by Gaussian beam function (smooth).
+      Default: False.
     pol : bool, optional
       If True, assumes input alms are TEB. Output will be TQU maps.
       (input must be 1 or 3 alms)
       If False, apply spin 0 harmonic transform to each alm.
       (input can be any number of alms)
       If there is only one input alm, it has no effect. Default: True.
     mmax : None or int, optional
       The maximum m for alm. Default: mmax=lmax
     inplace : bool, optional
       If True, the alm's are modified inplace if they are contiguous arrays
       of type complex128. Otherwise, a copy of alm is made. Default: True.
     verbose : bool, optional
-      If True prints diagnostic information. Default: True
+      If True prints diagnostic information. Default: False
 
     Returns
     -------
     alms : array or sequence of 3 arrays
       The smoothed alm. If alm[i] is a contiguous array of type complex128,
       and *inplace* is True the smoothing is applied inplace.
       Otherwise, a copy is made.
     """
     if sigma is None:
         sigma = fwhm / (2.*np.sqrt(2.*np.log(2.)))
 
     if verbose:
-        print("Sigma is {0:f} arcmin ({1:f} rad) ".format(sigma*60*180/pi,sigma))
-        print("-> fwhm is {0:f} arcmin".format(sigma*60*180/pi*(2.*np.sqrt(2.*np.log(2.)))))
+        print "Sigma is %f arcmin (%f rad) " %  (sigma*60*180/pi,sigma)
+        print "-> fwhm is %f arcmin" % (sigma*60*180/pi*(2.*np.sqrt(2.*np.log(2.))))
 
     # Check alms
     if not cb.is_seq(alms):
         raise ValueError("alm must be a sequence")
 
     if sigma == 0:
         # nothing to be done
@@ -650,106 +652,98 @@
         res = almxfl(alm, fact, mmax = mmax, inplace = inplace)
         retalm.append(res)
     # Test what to return (inplace/not inplace...)
     # Case 1: 1d input, return 1d output
     if lonely:
         return retalm[0]
     # case 2: 2d input, check if in-place smoothing for all alm's
-    for i in six.moves.xrange(len(alms)):
+    for i in xrange(len(alms)):
         samearray = alms[i] is retalm[i]
         if not samearray:
             # Case 2a:
             # at least one of the alm could not be smoothed in place:
             # return the list of alm
             return retalm
     # Case 2b:
     # all smoothing have been performed in place:
     # return the input alms
     return alms
 
-@accept_ma
-def smoothing(map_in, fwhm = 0.0, sigma = None,  pol = True,
+def smoothing(maps, fwhm = 0.0, sigma = None, invert = False, pol = True,
               iter = 3, lmax = None, mmax = None, use_weights = False,
-              datapath = None, verbose = True):
+              regression = True, datapath = None):
     """Smooth a map with a Gaussian symmetric beam.
 
-    No removal of monopole or dipole is performed.
-
     Parameters
     ----------
-    map_in : array or sequence of 3 arrays
+    maps : array or sequence of 3 arrays
       Either an array representing one map, or a sequence of
-      3 arrays representing 3 maps, accepts masked arrays
+      3 arrays representing 3 maps
     fwhm : float, optional
-      The full width half max parameter of the Gaussian [in 
-      radians]. Default:0.0
+      The full width half max parameter of the Gaussian. Default:0.0
     sigma : float, optional
-      The sigma of the Gaussian [in radians]. Override fwhm.
+      The sigma of the Gaussian. Override fwhm.
+    invert : bool, optional
+      If True, alms are divided by Gaussian beam function (un-smooth).
+      Otherwise, alms are multiplied by Gaussian beam function (smooth).
+      Default: False.
     pol : bool, optional
       If True, assumes input maps are TQU. Output will be TQU maps.
       (input must be 1 or 3 alms)
       If False, each map is assumed to be a spin 0 map and is 
       treated independently (input can be any number of alms).
       If there is only one input map, it has no effect. Default: True.
     iter : int, scalar, optional
       Number of iteration (default: 3)
     lmax : int, scalar, optional
       Maximum l of the power spectrum. Default: 3*nside-1
     mmax : int, scalar, optional
       Maximum m of the alm. Default: lmax
     use_weights: bool, scalar, optional
       If True, use the ring weighting. Default: False.
+    regression: bool, scalar, optional
+      If True, subtract map average before computing alm. Default: True.
     datapath : None or str, optional
       If given, the directory where to find the weights data.
-    verbose : bool, optional
-      If True prints diagnostic information. Default: True
 
     Returns
     -------
     maps : array or list of 3 arrays
       The smoothed map(s)
     """
+    if not cb.is_seq(maps):
+        raise TypeError("maps must be a sequence")
 
-    if not cb.is_seq(map_in):
-        raise TypeError("map_in must be a sequence")
-
-    # save the masks of inputs
-    masks = pixelfunc.mask_bad(map_in) 
-
-    if cb.is_seq_of_seq(map_in):
-        nside = pixelfunc.npix2nside(len(map_in[0]))
-        n_maps = len(map_in)
+    if cb.is_seq_of_seq(maps):
+        nside = pixelfunc.npix2nside(len(maps[0]))
+        n_maps = len(maps)
     else:
-        nside = pixelfunc.npix2nside(len(map_in))
+        nside = pixelfunc.npix2nside(len(maps))
         n_maps = 0
 
     if pol or n_maps in (0, 1):
         # Treat the maps together (1 or 3 maps)
-        alms = map2alm(map_in, lmax = lmax, mmax = mmax, iter = iter,
+        alms = map2alm(maps, lmax = lmax, mmax = mmax, iter = iter,
                        pol = pol, use_weights = use_weights,
-                       datapath = datapath)
-        smoothalm(alms, fwhm = fwhm, sigma = sigma, 
-                  inplace = True, verbose = verbose)
-        output_map = alm2map(alms, nside, pixwin = False, verbose=verbose)
+                       regression = regression, datapath = datapath)
+        smoothalm(alms, fwhm = fwhm, sigma = sigma, invert = invert,
+                  inplace = True)
+        return alm2map(alms, nside, pixwin = False)
     else:
         # Treat each map independently (any number)
-        output_map = []
-        for m in map_in:
-            alm = map2alm(m, lmax = lmax, mmax = mmax, iter = iter, pol = pol,
-                          use_weights = use_weights, datapath = datapath)
-            smoothalm(alm, fwhm = fwhm, sigma = sigma, 
-                      inplace = True, verbose = verbose)
-            output_map.append(alm2map(alm, nside, pixwin = False, verbose=verbose))
-    if pixelfunc.maptype(output_map) == 0:
-        output_map[masks.flatten()] = UNSEEN
-    else:
-        for m, mask in zip(output_map, masks):
-            m[mask] = UNSEEN
-        
-    return output_map
+        retmaps = []
+        for m in maps:
+            alm = map2alm(maps, iter = iter, pol = pol,
+                          use_weights = use_weights,
+                       regression = regression, datapath = datapath)
+            smoothalm(alm, fwhm = fwhm, sigma = sigma, invert = invert,
+                      inplace = True)
+            retmaps.append(alm2map(alm, nside, pixwin = False))
+        return retmaps
+
 
 def pixwin(nside, pol = False):
     """Return the pixel window function for the given nside.
 
     Parameters
     ----------
     nside : int
@@ -767,15 +761,22 @@
     if not pixelfunc.isnsideok(nside):
         raise ValueError("Wrong nside value (must be a power of two).")
     fname = os.path.join(datapath, 'pixel_window_n%04d.fits'%nside)
     if not os.path.isfile(fname):
         raise ValueError("No pixel window for this nside "
                          "or data files missing")
     # return hfitslib._pixwin(nside,datapath,pol)  ## BROKEN -> seg fault...
-    pw = pf.getdata(fname)
+    try:
+        import pyfits
+    except ImportError:
+        print "*********************************************************"
+        print "**   You need to install pyfits to use this function   **"
+        print "*********************************************************"
+        raise
+    pw = pyfits.getdata(fname)
     pw_temp, pw_pol = pw.field(0), pw.field(1)
     if pol:
         return pw_temp, pw_pol
     else:
         return pw_temp
 
 def alm2map_der1(alm, nside, lmax = None, mmax = None):
@@ -796,35 +797,36 @@
    mmax : None or int, optional
      Explicitly define mmax (needed if mmax!=lmax)
 
    Returns
    -------
    m, d_theta, d_phi : tuple of arrays
      The maps correponding to alm, and its derivatives with respect to
-     theta and phi. d_phi is already divided by sin(theta)
+     theta and phi.
    """
    if lmax is None:
        lmax = -1
    if mmax is None:
        mmax = -1
    return sphtlib._alm2map_der1(alm,nside,lmax=lmax,mmax=mmax)
 
+
 def new_to_old_spectra_order(cls_new_order):
     """Reorder the cls from new order (by diagonal) to old order (by row).
     For example : TT, EE, BB, TE, EB, BB => TT, TE, TB, EE, EB, BB
     """
     Nspec = sphtlib._getn(len(cls_new_order))
     if Nspec < 0:
         raise ValueError("Input must be a list of n(n+1)/2 arrays")
     cls_old_order = []
-    for i in six.moves.xrange(Nspec):
-        for j in six.moves.xrange(i, Nspec):
+    for i in xrange(Nspec):
+        for j in xrange(i, Nspec):
             p = j - i
             q = i
-            idx_new = p * (2 * Nspec + 1 - p) // 2 + q
+            idx_new = p * (2 * Nspec + 1 - p) / 2 + q
             cls_old_order.append(cls_new_order[idx_new])
     return cls_old_order
 
 def load_sample_spectra():
     """Read a sample power spectra for testing and demo purpose.
     Based on LambdaCDM. Gives TT, EE, BB, TE.
 
@@ -837,52 +839,7 @@
     """
     cls = np.loadtxt(os.path.join(DATAPATH, 'totcls.dat'), unpack = True)
     ell = cls[0]
     f = ell * (ell + 1) / 2 / np.pi
     cls[1:, 1:] /= f[1:]
     return ell, f, cls[1:]
 
-def gauss_beam(fwhm, lmax=512, pol=False):
-    """Gaussian beam window function
-
-    Computes the spherical transform of an axisimmetric gaussian beam
-
-    For a sky of underlying power spectrum C(l) observed with beam of  
-    given FWHM, the measured power spectrum will be 
-    C(l)_meas = C(l) B(l)^2
-    where B(l) is given by gaussbeam(Fwhm,Lmax). 
-    The polarization beam is also provided (when pol = True ) assuming 
-    a perfectly co-polarized beam 
-    (e.g., Challinor et al 2000, astro-ph/0008228)
-
-    Parameters
-    ----------
-    fwhm : float
-        full width half max in radians
-    lmax : integer
-        ell max
-    pol : bool
-        if False, output has size (lmax+1) and is temperature beam
-        if True output has size (lmax+1, 4) with components:
-        * temperature beam
-        * grad/electric polarization beam
-        * curl/magnetic polarization beam
-        * temperature * grad beam
-
-    Returns
-    -------
-    beam : array
-        beam window function [0, lmax] if dim not specified
-        otherwise (lmax+1, 4) contains polarized beam
-    """
-
-    sigma = fwhm / np.sqrt(8. * np.log(2.))
-    ell = np.arange(lmax + 1)
-    sigma2 = sigma ** 2
-    g = np.exp(-.5 * ell * (ell + 1) * sigma2)
-
-    if not pol: # temperature-only beam
-        return g
-    else: # polarization beam
-        # polarization factors [1, 2 sigma^2, 2 sigma^2, sigma^2]
-        pol_factor = np.exp([0., 2*sigma2, 2*sigma2, sigma2])
-        return g[:, np.newaxis] * pol_factor
```

### Comparing `healpy-1.9.1/healpy/zoomtool.py` & `healpy-github-devel/healpy/zoomtool.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,20 +14,23 @@
 #  You should have received a copy of the GNU General Public License
 #  along with Healpy; if not, write to the Free Software
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 # 
 #  For more information about Healpy, see http://code.google.com/p/healpy
 # 
 
-from . import projaxes as PA
-from . import rotator as R
+import projaxes as PA
+import rotator as R
+import pylab
 import numpy as np
 import matplotlib
-from ._healpy_pixel_lib import UNSEEN
-from . import pixelfunc
+import matplotlib.colors as colors
+import matplotlib.cbook as cbook
+from _healpy_pixel_lib import UNSEEN
+import pixelfunc
 
 pi = np.pi
 dtor = pi/180.
 
 def mollzoom(map=None,fig=None,rot=None,coord=None,unit='',
              xsize=800,title='Mollweide view',nest=False,
              min=None,max=None,flip='astro',
@@ -36,16 +39,14 @@
              format='%g',cmap=None,
              norm=None,hold=False,margins=None,sub=None):
     """Interactive mollweide plot with zoomed gnomview.
     
     Parameters:
     -----------
     map : float, array-like shape (Npix,)
-      An array containing the map, 
-      supports masked maps, see the `ma` function.
       if None, use map with inf value (white map), useful for
       overplotting
     fig : a figure number. 
       Default: create a new figure
     rot : scalar or sequence, optional
       Describe the rotation to apply.
       In the form (lon, lat, psi) (unit: degrees) : the point at
@@ -76,25 +77,23 @@
       If :const:`True`, remove the monopole
     gal_cut : float, scalar, optional
       Symmetric galactic cut for the dipole/monopole fit.
       Removes points in latitude range [-gal_cut, +gal_cut]
     format : str, optional
       The format of the scale label. Default: '%g'
     """
-    import pylab
     # create the figure (if interactive, it will open the window now)
     f=pylab.figure(fig,figsize=(10.5,5.4))
     extent = (0.02,0.25,0.56,0.72)
     # Starting to draw : turn interactive off
     wasinteractive = pylab.isinteractive()
     pylab.ioff()
     try:
         if map is None:
             map = np.zeros(12)+np.inf
-        map = pixelfunc.ma_to_array(map)
         ax=PA.HpxMollweideAxes(f,extent,coord=coord,rot=rot,
                                format=format,flipconv=flip)
         f.add_axes(ax)
         if remove_dip:
             map=pixelfunc.remove_dipole(map,gal_cut=gal_cut,
                                         nest=nest,copy=True,
                                         verbose=True)
@@ -185,15 +184,14 @@
         pylab.draw()
         if wasinteractive:
             pylab.ion()
 
 def set_g_clim(vmin,vmax):
     """Set min/max value of the gnomview part of a mollzoom.
     """
-    import pylab
     f=pylab.gcf()
     if not hasattr(f,'zoomtool'):
         raise TypeError('The current figure has no zoomtool')
     f.zoomtool.save_min = vmin
     f.zoomtool.save_max = vmax
     f.zoomtool._range_status = 2
     f.zoomtool.draw_gnom()
@@ -203,15 +201,14 @@
     and a Gnomonic axis.
     """
     def __init__(self,m,fig=None,nest=False,cmap=None,norm=None,
                  coord=None):
         """m: the map to be zoomed (already plotted in Mollweide view)
         fig: the figure to instrument (None->gcf())
         """
-        import pylab
         self.reso_list = [0.05,0.1,0.2,0.3,0.5,0.75,1.,1.5,3.,5.,10.,15.,
                           30.,45.,60.]
         self._map = m
         self._nest = nest
         self._cmap = cmap
         self._norm = norm
         self._coord = coord
@@ -239,15 +236,15 @@
          self._gnom_ax, self._gnom_cb_ax) = f.get_axes()[:4]
         self._grat_ax = f.get_axes()[4]
         self._text_reso, self._text_coord, self._text_loc = self._gnom_ax.texts
         self._xsize = self._gnom_ax.proj.arrayinfo['xsize']
         self._ysize = self._gnom_ax.proj.arrayinfo['ysize']
         try:
             self._reso_idx = self.reso_list.index(self._gnom_ax.proj._arrayinfo['reso'])
-        except ValueError as e:
+        except ValueError,e:
             raise ValueError('Resolution not in %s'%self.reso_list)
         self.zoomcenter, = self._moll_ax.plot([0],[0],'ok',
                                               mew=1,ms=15,alpha=0.1)
         self.zoomcenter2, = self._moll_ax.plot([0], [0], 'xr',
                                                ms=15, alpha=0.5, mew=3)
         self._text_range = self._gnom_ax.text(-0.4, -0.2, 'scale mode: loc',
                                                transform=
@@ -255,42 +252,41 @@
                                                va='baseline',
                                                ha='left')
         self.draw_gnom(0,0)
         self._connected = False
         self.connect_callbacks()
         
     def _zoom_on_click(self, ev):
-        import pylab
         try:
             ax = ev.inaxes
             lon,lat = ax.get_lonlat(ev.xdata,ev.ydata)
             if np.isnan(lon) or np.isnan(lat):
                 raise ValueError('invalid position')
             val = ax.get_value(ev.xdata,ev.ydata)
             self.lastval = val
             self._move_zoom_center(lon,lat)
             self.draw_gnom(lon,lat)            
-        except Exception as s:
+        except Exception,s:
             self._move_zoom_center(0,0,False)
             pylab.draw_if_interactive()
             #print s
         return
 
     def _reso_on_key(self, ev):
         if ev.key == 'r':
             self._decrease_reso()
         elif ev.key == 't':
             self._increase_reso()
         elif ev.key == 'p':
-            print('lon,lat = %.17g,%.17g'%(self.lon,self.lat))
+            print 'lon,lat = %.17g,%.17g'%(self.lon,self.lat)
         elif ev.key == 'c':
             self._move_zoom_center(0,0)
             self.draw_gnom(0,0)
         elif ev.key == 'v':
-            print('val = %.17g'%(self.lastval))
+            print 'val = %.17g'%(self.lastval)
         elif ev.key == 'f':
             self._range_status += 1
             self._range_status %= 3
             self.draw_gnom()
         elif ev.key == 'k':
             self.save_min = self._gnom_ax.images[0].norm.vmin
             self.save_max = self._gnom_ax.images[0].norm.vmax
@@ -373,15 +369,14 @@
         if self.zoomcenter2:
             x,y = self._moll_ax.proj.ang2xy(lon,lat,lonlat=True)
             self.zoomcenter2.set_xdata([x])
             self.zoomcenter2.set_ydata([y])
             self.zoomcenter2.set_visible(visible)
 
     def draw_gnom(self,lon=None,lat=None):
-        import pylab
         wasinteractive = pylab.isinteractive()
         pylab.ioff()
         try:
             # modify rot of the gnom_ax
             if lon is None:
                 lon = self._lon
             else:
@@ -439,15 +434,15 @@
             ysize  = self._gnom_ax.proj.arrayinfo['ysize']
             self._text_reso.set_text("%g '/pix,   %dx%d pix"%
                                      (reso, xsize, ysize))
             mode = ['loc','map','sav'][self._range_status]
             self._text_range.set_text('scale mode: %s'%mode)
             self.lon,self.lat = lon,lat
             self._update_grat_info()
-        except Exception as e:
+        except Exception, e:
             pass #print e
         finally:
             if wasinteractive:
                 pylab.ion()
                 pylab.draw()
                 pylab.show()
```

### Comparing `healpy-1.9.1/healpy/test/data/cl_wmap_band_iqumap_r9_7yr_W_v4_udgraded32_II_lmax64_rmmono_3iter.fits` & `healpy-github-devel/healpy/data/weight_ring_n00016.fits`

 * *Files 26% similar despite different names*

```diff
@@ -24,16 +24,16 @@
 00000170: 2066 6f72 6d61 7420 6973 2064 6566 696e   format is defin
 00000180: 6564 2069 6e20 2741 7374 726f 6e6f 6d79  ed in 'Astronomy
 00000190: 434f 4d4d 454e 5420 2020 616e 6420 4173  COMMENT   and As
 000001a0: 7472 6f70 6879 7369 6373 272c 2076 6f6c  trophysics', vol
 000001b0: 756d 6520 3337 362c 2070 6167 6520 3335  ume 376, page 35
 000001c0: 393b 2062 6962 636f 6465 3a20 3230 3031  9; bibcode: 2001
 000001d0: 4126 412e 2e2e 3337 362e 2e33 3539 4820  A&A...376..359H 
-000001e0: 4441 5445 2020 2020 3d20 2732 3031 342d  DATE    = '2014-
-000001f0: 3031 2d31 3454 3138 3a35 373a 3537 2720  01-14T18:57:57' 
+000001e0: 4441 5445 2020 2020 3d20 2732 3030 352d  DATE    = '2005-
+000001f0: 3038 2d31 3754 3233 3a30 333a 3537 2720  08-17T23:03:57' 
 00000200: 2f20 6669 6c65 2063 7265 6174 696f 6e20  / file creation 
 00000210: 6461 7465 2028 5959 5959 2d4d 4d2d 4444  date (YYYY-MM-DD
 00000220: 5468 683a 6d6d 3a73 7320 5554 2920 2020  Thh:mm:ss UT)   
 00000230: 454e 4420 2020 2020 2020 2020 2020 2020  END             
 00000240: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000260: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -174,220 +174,220 @@
 00000ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000b40: 5854 454e 5349 4f4e 3d20 2754 4142 4c45  XTENSION= 'TABLE
-00000b50: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
-00000b60: 2041 5343 4949 2074 6162 6c65 2065 7874   ASCII table ext
-00000b70: 656e 7369 6f6e 2020 2020 2020 2020 2020  ension          
+00000b40: 5854 454e 5349 4f4e 3d20 2742 494e 5441  XTENSION= 'BINTA
+00000b50: 424c 4527 2020 2020 2020 2020 2020 202f  BLE'           /
+00000b60: 2062 696e 6172 7920 7461 626c 6520 6578   binary table ex
+00000b70: 7465 6e73 696f 6e20 2020 2020 2020 2020  tension         
 00000b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000b90: 4249 5450 4958 2020 3d20 2020 2020 2020  BITPIX  =       
 00000ba0: 2020 2020 2020 2020 2020 2020 2038 202f               8 /
-00000bb0: 2038 2d62 6974 2041 5343 4949 2063 6861   8-bit ASCII cha
-00000bc0: 7261 6374 6572 7320 2020 2020 2020 2020  racters         
+00000bb0: 2038 2d62 6974 2062 7974 6573 2020 2020   8-bit bytes    
+00000bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000be0: 4e41 5849 5320 2020 3d20 2020 2020 2020  NAXIS   =       
 00000bf0: 2020 2020 2020 2020 2020 2020 2032 202f               2 /
-00000c00: 2032 2d64 696d 656e 7369 6f6e 616c 2041   2-dimensional A
-00000c10: 5343 4949 2074 6162 6c65 2020 2020 2020  SCII table      
+00000c00: 2032 2d64 696d 656e 7369 6f6e 616c 2062   2-dimensional b
+00000c10: 696e 6172 7920 7461 626c 6520 2020 2020  inary table     
 00000c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000c30: 4e41 5849 5331 2020 3d20 2020 2020 2020  NAXIS1  =       
-00000c40: 2020 2020 2020 2020 2020 2020 3135 202f              15 /
+00000c40: 2020 2020 2020 2020 2020 2020 3234 202f              24 /
 00000c50: 2077 6964 7468 206f 6620 7461 626c 6520   width of table 
-00000c60: 696e 2063 6861 7261 6374 6572 7320 2020  in characters   
+00000c60: 696e 2062 7974 6573 2020 2020 2020 2020  in bytes        
 00000c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000c80: 4e41 5849 5332 2020 3d20 2020 2020 2020  NAXIS2  =       
-00000c90: 2020 2020 2020 2020 2020 2020 3635 202f              65 /
+00000c90: 2020 2020 2020 2020 2020 2020 3332 202f              32 /
 00000ca0: 206e 756d 6265 7220 6f66 2072 6f77 7320   number of rows 
 00000cb0: 696e 2074 6162 6c65 2020 2020 2020 2020  in table        
 00000cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000cd0: 5043 4f55 4e54 2020 3d20 2020 2020 2020  PCOUNT  =       
 00000ce0: 2020 2020 2020 2020 2020 2020 2030 202f               0 /
-00000cf0: 206e 6f20 6772 6f75 7020 7061 7261 6d65   no group parame
-00000d00: 7465 7273 2028 7265 7175 6972 6564 206b  ters (required k
-00000d10: 6579 776f 7264 2920 2020 2020 2020 2020  eyword)         
+00000cf0: 2073 697a 6520 6f66 2073 7065 6369 616c   size of special
+00000d00: 2064 6174 6120 6172 6561 2020 2020 2020   data area      
+00000d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000d20: 4743 4f55 4e54 2020 3d20 2020 2020 2020  GCOUNT  =       
 00000d30: 2020 2020 2020 2020 2020 2020 2031 202f               1 /
 00000d40: 206f 6e65 2064 6174 6120 6772 6f75 7020   one data group 
 00000d50: 2872 6571 7569 7265 6420 6b65 7977 6f72  (required keywor
 00000d60: 6429 2020 2020 2020 2020 2020 2020 2020  d)              
 00000d70: 5446 4945 4c44 5320 3d20 2020 2020 2020  TFIELDS =       
-00000d80: 2020 2020 2020 2020 2020 2020 2031 202f               1 /
+00000d80: 2020 2020 2020 2020 2020 2020 2033 202f               3 /
 00000d90: 206e 756d 6265 7220 6f66 2066 6965 6c64   number of field
 00000da0: 7320 696e 2065 6163 6820 726f 7720 2020  s in each row   
 00000db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000dc0: 434f 4d4d 454e 5420 202d 2d2d 2d2d 2d2d  COMMENT  -------
-00000dd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000df0: 2d2d 2d2d 2d2d 2d2d 2020 2020 2020 2020  --------        
-00000e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000e10: 434f 4d4d 454e 5420 204d 6170 2041 6e61  COMMENT  Map Ana
-00000e20: 6c79 7369 7320 5370 6563 6966 6963 204b  lysis Specific K
-00000e30: 6579 776f 7264 7320 2020 2020 2020 2020  eywords         
-00000e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000dc0: 4e53 4944 4520 2020 3d20 2020 2020 2020  NSIDE   =       
+00000dd0: 2020 2020 2020 2020 2020 2020 3136 202f              16 /
+00000de0: 2052 6573 6f6c 7574 696f 6e20 7061 7261   Resolution para
+00000df0: 6d65 7465 7220 666f 7220 4845 414c 5049  meter for HEALPI
+00000e00: 5820 2020 2020 2020 2020 2020 2020 2020  X               
+00000e10: 4352 4541 544f 5220 3d20 2751 5541 445f  CREATOR = 'QUAD_
+00000e20: 5249 4e47 2720 2020 2020 2020 2020 202f  RING'          /
+00000e30: 2053 6f66 7477 6172 6520 6372 6561 7469   Software creati
+00000e40: 6e67 2074 6865 2046 4954 5320 6669 6c65  ng the FITS file
 00000e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000e60: 434f 4d4d 454e 5420 202d 2d2d 2d2d 2d2d  COMMENT  -------
-00000e70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000e80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000e90: 2d2d 2d2d 2d2d 2d2d 2020 2020 2020 2020  --------        
-00000ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000eb0: 4558 544e 414d 4520 3d20 2741 4e41 4c59  EXTNAME = 'ANALY
-00000ec0: 5345 4420 4155 544f 2050 4f57 4552 2053  SED AUTO POWER S
-00000ed0: 5045 4354 5255 4d27 2020 2020 2020 2020  PECTRUM'        
-00000ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000e60: 5645 5253 494f 4e20 3d20 2731 2e33 2e30  VERSION = '1.3.0
+00000e70: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
+00000e80: 2056 6572 7369 6f6e 206f 6620 7468 6520   Version of the 
+00000e90: 7369 6d75 6c61 7469 6f6e 2073 6f66 7477  simulation softw
+00000ea0: 6172 6520 2020 2020 2020 2020 2020 2020  are             
+00000eb0: 4d41 582d 4c50 4f4c 3d20 2020 2020 2020  MAX-LPOL=       
+00000ec0: 2020 2020 2020 2020 2020 2020 3438 202f              48 /
+00000ed0: 204d 6178 696d 756d 206d 756c 7469 706f   Maximum multipo
+00000ee0: 6c65 206c 2075 7365 6420 696e 206d 6170  le l used in map
+00000ef0: 2073 796e 7468 6573 6973 2020 2020 2020   synthesis      
 00000f00: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 00000f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000f50: 4352 4541 544f 5220 3d20 2741 4e41 4641  CREATOR = 'ANAFA
-00000f60: 5354 2027 2020 2020 2020 2020 2020 202f  ST '           /
-00000f70: 2053 6f66 7477 6172 6520 6372 6561 7469   Software creati
-00000f80: 6e67 2074 6865 2046 4954 5320 6669 6c65  ng the FITS file
+00000f50: 434f 4d4d 454e 5420 2d2d 2d2d 2d2d 2d2d  COMMENT --------
+00000f60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000f70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000f80: 2d2d 2d2d 2d2d 2d20 2020 2020 2020 2020  -------         
 00000f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000fa0: 5645 5253 494f 4e20 3d20 2733 2e31 3120  VERSION = '3.11 
-00000fb0: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
-00000fc0: 2056 6572 7369 6f6e 206f 6620 7468 6520   Version of the 
-00000fd0: 7369 6d75 6c61 7469 6f6e 2073 6f66 7477  simulation softw
-00000fe0: 6172 6520 2020 2020 2020 2020 2020 2020  are             
-00000ff0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
-00001000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000fa0: 434f 4d4d 454e 5420 4461 7461 2044 6573  COMMENT Data Des
+00000fb0: 6372 6970 7469 6f6e 2053 7065 6369 6669  cription Specifi
+00000fc0: 6320 4b65 7977 6f72 6473 2020 2020 2020  c Keywords      
+00000fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000ff0: 434f 4d4d 454e 5420 2d2d 2d2d 2d2d 2d2d  COMMENT --------
+00001000: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001020: 2d2d 2d2d 2d2d 2d20 2020 2020 2020 2020  -------         
 00001030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001040: 4d41 582d 4c50 4f4c 3d20 2020 2020 2020  MAX-LPOL=       
-00001050: 2020 2020 2020 2020 2020 2020 3634 202f              64 /
-00001060: 204d 6178 696d 756d 204c 6567 656e 6472   Maximum Legendr
-00001070: 6520 6f72 6465 7220 4c20 2020 2020 2020  e order L       
+00001040: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
+00001050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001070: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001090: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
-000010a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001090: 434f 4d4d 454e 5420 636f 6e74 6169 6e73  COMMENT contains
+000010a0: 2044 5f77 6569 6768 7420 666f 7220 7468   D_weight for th
+000010b0: 6520 6e6f 7274 6820 6865 6d69 7370 6865  e north hemisphe
+000010c0: 7265 206f 6620 4845 414c 5049 5820 2020  re of HEALPIX   
 000010d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010e0: 504f 4c41 5220 2020 3d20 2020 2020 2020  POLAR   =       
-000010f0: 2020 2020 2020 2020 2020 2020 2046 202f               F /
-00001100: 2050 6f6c 6172 6973 6174 696f 6e20 696e   Polarisation in
-00001110: 636c 7564 6564 2028 5472 7565 2f46 616c  cluded (True/Fal
-00001120: 7365 2920 2020 2020 2020 2020 2020 2020  se)             
-00001130: 4243 524f 5353 2020 3d20 2020 2020 2020  BCROSS  =       
-00001140: 2020 2020 2020 2020 2020 2020 2046 202f               F /
-00001150: 204d 6167 6e65 7469 6320 6372 6f73 7320   Magnetic cross 
-00001160: 7465 726d 7320 696e 636c 7564 6564 2028  terms included (
-00001170: 5472 7565 2f46 616c 7365 2920 2020 2020  True/False)     
+000010e0: 434f 4d4d 454e 5420 6561 6368 2072 696e  COMMENT each rin
+000010f0: 6720 6861 7320 746f 2062 6520 6d75 6c74  g has to be mult
+00001100: 6970 6c69 6564 2062 7920 2831 2b44 5f77  iplied by (1+D_w
+00001110: 6569 6768 7429 2020 2020 2020 2020 2020  eight)          
+00001120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001130: 434f 4d4d 454e 5420 696e 206f 7264 6572  COMMENT in order
+00001140: 2074 6f20 696d 7072 6f76 6520 7468 6520   to improve the 
+00001150: 7175 6164 7261 7475 7265 2077 6865 6e20  quadrature when 
+00001160: 616e 616c 797a 696e 6720 6120 6d61 7020  analyzing a map 
+00001170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001180: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 00001190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000011a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000011b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000011c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000011d0: 4e53 4944 4520 2020 3d20 2020 2020 2020  NSIDE   =       
-000011e0: 2020 2020 2020 2020 2020 2020 3332 202f              32 /
-000011f0: 2052 6573 6f6c 7574 696f 6e20 5061 7261   Resolution Para
-00001200: 6d65 7465 7220 6f66 2049 6e70 7574 204d  meter of Input M
-00001210: 6170 2020 2020 2020 2020 2020 2020 2020  ap              
-00001220: 434f 4f52 4453 5953 3d20 2775 6e6b 6e6f  COORDSYS= 'unkno
-00001230: 776e 2027 2020 2020 2020 2020 2020 202f  wn '           /
-00001240: 2049 6e70 7574 204d 6170 2043 6f6f 7264   Input Map Coord
-00001250: 696e 6174 6520 7379 7374 656d 2020 2020  inate system    
+000011d0: 434f 4d4d 454e 5420 636f 6d70 7574 6564  COMMENT computed
+000011e0: 2062 7920 5356 4420 7573 696e 6720 4447   by SVD using DG
+000011f0: 4553 4444 2020 6672 6f6d 204c 6170 6163  ESDD  from Lapac
+00001200: 6b20 6c69 6272 6172 7920 2020 2020 2020  k library       
+00001210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001220: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
+00001230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001270: 434f 4d4d 454e 5420 2047 203d 2047 616c  COMMENT  G = Gal
-00001280: 6163 7469 632c 2045 203d 2065 636c 6970  actic, E = eclip
-00001290: 7469 632c 2043 203d 2063 656c 6573 7469  tic, C = celesti
-000012a0: 616c 203d 2065 7175 6174 6f72 6961 6c20  al = equatorial 
+00001270: 5454 5950 4531 2020 3d20 2754 454d 5045  TTYPE1  = 'TEMPE
+00001280: 5241 5455 5245 2057 4549 4748 5453 2720  RATURE WEIGHTS' 
+00001290: 2f20 5465 6d70 6572 6174 7572 6520 7765  / Temperature we
+000012a0: 6967 6874 7320 2020 2020 2020 2020 2020  ights           
 000012b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000012c0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
-000012d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000012e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000012c0: 5455 4e49 5431 2020 3d20 2731 2020 2020  TUNIT1  = '1    
+000012d0: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
+000012e0: 2075 6e69 7420 2020 2020 2020 2020 2020   unit           
 000012f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001310: 5442 434f 4c31 2020 3d20 2020 2020 2020  TBCOL1  =       
-00001320: 2020 2020 2020 2020 2020 2020 2031 202f               1 /
-00001330: 2062 6567 696e 6e69 6e67 2063 6f6c 756d   beginning colum
-00001340: 6e20 6f66 2066 6965 6c64 2020 2031 2020  n of field   1  
+00001310: 5446 4f52 4d31 2020 3d20 2731 4420 2020  TFORM1  = '1D   
+00001320: 2020 2027 2020 2020 2020 2020 2020 2020     '            
+00001330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001340: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001360: 5446 4f52 4d31 2020 3d20 2745 3135 2e37  TFORM1  = 'E15.7
-00001370: 2020 2027 2020 2020 2020 2020 2020 2020     '            
-00001380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001360: 4d41 5856 414c 3120 3d20 2020 312e 3635  MAXVAL1 =   1.65
+00001370: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001380: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
+00001390: 6620 5420 7765 6967 6874 7320 2020 2020  f T weights     
 000013a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000013b0: 5454 5950 4531 2020 3d20 2754 454d 5045  TTYPE1  = 'TEMPE
-000013c0: 5241 5455 5245 2720 2020 2020 2020 202f  RATURE'        /
-000013d0: 2054 656d 7065 7261 7475 7265 2043 286c   Temperature C(l
-000013e0: 2920 2020 2020 2020 2020 2020 2020 2020  )               
+000013b0: 4d49 4e56 414c 3120 3d20 202d 372e 3234  MINVAL1 =  -7.24
+000013c0: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+000013d0: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
+000013e0: 6620 5420 7765 6967 6874 7320 2020 2020  f T weights     
 000013f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001400: 5455 4e49 5431 2020 3d20 275e 3220 2020  TUNIT1  = '^2   
-00001410: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
-00001420: 2073 7175 6172 6520 6f66 206d 6170 2075   square of map u
-00001430: 6e69 7473 2020 2020 2020 2020 2020 2020  nits            
+00001400: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
+00001410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001430: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001450: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
-00001460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001450: 5454 5950 4532 2020 3d20 2751 2d50 4f4c  TTYPE2  = 'Q-POL
+00001460: 4152 4953 4154 494f 4e20 5745 4947 4854  ARISATION WEIGHT
+00001470: 5327 202f 2051 2050 6f6c 6172 6973 6174  S' / Q Polarisat
+00001480: 696f 6e20 7765 6967 6874 7320 2020 2020  ion weights     
 00001490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000014a0: 4355 542d 534b 5920 3d20 2020 302e 3030  CUT-SKY =   0.00
-000014b0: 3030 3030 3030 3030 3030 452b 3030 202f  0000000000E+00 /
-000014c0: 205b 6465 675d 2053 796d 6d65 7472 6963   [deg] Symmetric
-000014d0: 2043 7574 2053 6b79 2020 2020 2020 2020   Cut Sky        
+000014a0: 5455 4e49 5432 2020 3d20 2731 2020 2020  TUNIT2  = '1    
+000014b0: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
+000014c0: 2075 6e69 7420 2020 2020 2020 2020 2020   unit           
+000014d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000014e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000014f0: 4e49 5445 5241 4c4d 3d20 2020 2020 2020  NITERALM=       
-00001500: 2020 2020 2020 2020 2020 2020 2033 202f               3 /
-00001510: 204e 756d 6265 7220 6f66 2069 7465 7261   Number of itera
-00001520: 7469 6f6e 7320 666f 7220 615f 6c6d 7320  tions for a_lms 
-00001530: 6578 7472 6163 7469 6f6e 2020 2020 2020  extraction      
-00001540: 4c52 4547 5245 5353 3d20 2020 2020 2020  LREGRESS=       
-00001550: 2020 2020 2020 2020 2020 2020 2031 202f               1 /
-00001560: 2052 6567 7265 7373 696f 6e20 6f66 206c   Regression of l
-00001570: 6f77 206d 756c 7469 706f 6c65 7320 2830  ow multipoles (0
-00001580: 2f31 2f32 2920 2020 2020 2020 2020 2020  /1/2)           
-00001590: 4e4d 4150 535f 494e 3d20 2020 2020 2020  NMAPS_IN=       
-000015a0: 2020 2020 2020 2020 2020 2020 2031 202f               1 /
-000015b0: 204e 756d 6265 7220 6f66 206d 6170 7320   Number of maps 
-000015c0: 2863 6f2d 2961 6e61 6c79 7365 6420 2831  (co-)analysed (1
-000015d0: 2f32 2920 2020 2020 2020 2020 2020 2020  /2)             
+000014f0: 5446 4f52 4d32 2020 3d20 2731 4420 2020  TFORM2  = '1D   
+00001500: 2020 2027 2020 2020 2020 2020 2020 2020     '            
+00001510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001540: 4d41 5856 414c 3220 3d20 2020 312e 3635  MAXVAL2 =   1.65
+00001550: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001560: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
+00001570: 6620 5120 7765 6967 6874 7320 2020 2020  f Q weights     
+00001580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001590: 4d49 4e56 414c 3220 3d20 202d 372e 3234  MINVAL2 =  -7.24
+000015a0: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+000015b0: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
+000015c0: 6620 5120 7765 6967 6874 7320 2020 2020  f Q weights     
+000015d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000015e0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 000015f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001600: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001610: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001630: 4849 5354 4f52 5920 2049 6e70 7574 204d  HISTORY  Input M
-00001640: 6170 203d 2077 6d61 705f 6261 6e64 5f69  ap = wmap_band_i
-00001650: 7175 6d61 705f 7239 5f37 7972 5f57 5f76  qumap_r9_7yr_W_v
-00001660: 345f 7564 6772 6164 6564 3332 5f6d 6173  4_udgraded32_mas
-00001670: 6b65 642e 6669 7473 2020 2020 2020 2020  ked.fits        
-00001680: 454e 4420 2020 2020 2020 2020 2020 2020  END             
-00001690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000016a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001630: 5454 5950 4533 2020 3d20 2755 2d50 4f4c  TTYPE3  = 'U-POL
+00001640: 4152 4953 4154 494f 4e20 5745 4947 4854  ARISATION WEIGHT
+00001650: 5327 202f 2055 2050 6f6c 6172 6973 6174  S' / U Polarisat
+00001660: 696f 6e20 7765 6967 6874 7320 2020 2020  ion weights     
+00001670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001680: 5455 4e49 5433 2020 3d20 2731 2020 2020  TUNIT3  = '1    
+00001690: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
+000016a0: 2075 6e69 7420 2020 2020 2020 2020 2020   unit           
 000016b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000016c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000016d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000016e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000016d0: 5446 4f52 4d33 2020 3d20 2731 4420 2020  TFORM3  = '1D   
+000016e0: 2020 2027 2020 2020 2020 2020 2020 2020     '            
 000016f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001720: 4d41 5856 414c 3320 3d20 2020 312e 3635  MAXVAL3 =   1.65
+00001730: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001740: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
+00001750: 6620 5520 7765 6967 6874 7320 2020 2020  f U weights     
 00001760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000017a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001770: 4d49 4e56 414c 3320 3d20 202d 372e 3234  MINVAL3 =  -7.24
+00001780: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+00001790: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
+000017a0: 6620 5520 7765 6967 6874 7320 2020 2020  f U weights     
 000017b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000017c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000017c0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 000017d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000017e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001810: 454e 4420 2020 2020 2020 2020 2020 2020  END             
 00001820: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001830: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001840: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001850: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001860: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001870: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001880: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -534,187 +534,187 @@
 00002150: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002180: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000021a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000021b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000021c0: 2020 332e 3334 3134 3537 3345 2d31 3120    3.3414573E-11 
-000021d0: 2033 2e33 3531 3735 3538 452d 3036 2020   3.3517558E-06  
-000021e0: 342e 3839 3839 3433 3045 2d30 3520 2031  4.8989430E-05  1
-000021f0: 2e30 3136 3934 3737 452d 3034 2020 312e  .0169477E-04  1.
-00002200: 3230 3632 3433 3345 2d30 3420 2031 2e31  2062433E-04  1.1
-00002210: 3332 3535 3936 452d 3034 2020 342e 3731  325596E-04  4.71
-00002220: 3937 3437 3145 2d30 3520 2034 2e36 3732  97471E-05  4.672
-00002230: 3138 3338 452d 3035 2020 332e 3133 3733  1838E-05  3.1373
-00002240: 3234 3945 2d30 3520 2032 2e39 3137 3930  249E-05  2.91790
-00002250: 3137 452d 3035 2020 312e 3632 3833 3739  17E-05  1.628379
-00002260: 3745 2d30 3520 2032 2e38 3435 3532 3739  7E-05  2.8455279
-00002270: 452d 3035 2020 312e 3535 3635 3534 3245  E-05  1.5565542E
-00002280: 2d30 3520 2031 2e37 3436 3933 3437 452d  -05  1.7469347E-
-00002290: 3035 2020 312e 3737 3136 3937 3345 2d30  05  1.7716973E-0
-000022a0: 3520 2031 2e32 3931 3035 3735 452d 3035  5  1.2910575E-05
-000022b0: 2020 312e 3234 3039 3539 3745 2d30 3520    1.2409597E-05 
-000022c0: 2031 2e31 3833 3133 3831 452d 3035 2020   1.1831381E-05  
-000022d0: 362e 3333 3039 3034 3445 2d30 3620 2039  6.3309044E-06  9
-000022e0: 2e35 3232 3837 3235 452d 3036 2020 352e  .5228725E-06  5.
-000022f0: 3537 3539 3436 3545 2d30 3620 2035 2e30  5759465E-06  5.0
-00002300: 3533 3336 3637 452d 3036 2020 342e 3031  533667E-06  4.01
-00002310: 3934 3631 3445 2d30 3620 2034 2e36 3238  94614E-06  4.628
-00002320: 3536 3732 452d 3036 2020 352e 3732 3734  5672E-06  5.7274
-00002330: 3934 3245 2d30 3620 2034 2e36 3231 3538  942E-06  4.62158
-00002340: 3238 452d 3036 2020 352e 3135 3130 3534  28E-06  5.151054
-00002350: 3745 2d30 3620 2035 2e30 3837 3630 3730  7E-06  5.0876070
-00002360: 452d 3036 2020 342e 3637 3831 3437 3045  E-06  4.6781470E
-00002370: 2d30 3620 2034 2e35 3131 3036 3333 452d  -06  4.5110633E-
-00002380: 3036 2020 332e 3731 3934 3432 3545 2d30  06  3.7194425E-0
-00002390: 3620 2034 2e33 3334 3037 3130 452d 3036  6  4.3340710E-06
-000023a0: 2020 352e 3333 3936 3432 3945 2d30 3620    5.3396429E-06 
-000023b0: 2033 2e34 3331 3234 3133 452d 3036 2020   3.4312413E-06  
-000023c0: 332e 3637 3935 3730 3545 2d30 3620 2032  3.6795705E-06  2
-000023d0: 2e33 3835 3839 3633 452d 3036 2020 332e  .3858963E-06  3.
-000023e0: 3533 3632 3236 3645 2d30 3620 2032 2e35  5362266E-06  2.5
-000023f0: 3830 3934 3131 452d 3036 2020 332e 3535  809411E-06  3.55
-00002400: 3236 3437 3145 2d30 3620 2033 2e35 3736  26471E-06  3.576
-00002410: 3730 3938 452d 3036 2020 332e 3336 3739  7098E-06  3.3679
-00002420: 3738 3545 2d30 3620 2033 2e35 3736 3337  785E-06  3.57637
-00002430: 3939 452d 3036 2020 332e 3635 3736 3834  99E-06  3.657684
-00002440: 3145 2d30 3620 2033 2e33 3133 3932 3232  1E-06  3.3139222
-00002450: 452d 3036 2020 322e 3238 3530 3335 3445  E-06  2.2850354E
-00002460: 2d30 3620 2032 2e32 3630 3236 3531 452d  -06  2.2602651E-
-00002470: 3036 2020 322e 3430 3738 3134 3245 2d30  06  2.4078142E-0
-00002480: 3620 2032 2e35 3839 3236 3339 452d 3036  6  2.5892639E-06
-00002490: 2020 312e 3831 3133 3038 3245 2d30 3620    1.8113082E-06 
-000024a0: 2032 2e34 3231 3435 3033 452d 3036 2020   2.4214503E-06  
-000024b0: 322e 3039 3934 3131 3245 2d30 3620 2032  2.0994112E-06  2
-000024c0: 2e31 3236 3332 3439 452d 3036 2020 322e  .1263249E-06  2.
-000024d0: 3137 3134 3238 3845 2d30 3620 2031 2e36  1714288E-06  1.6
-000024e0: 3630 3538 3733 452d 3036 2020 312e 3937  605873E-06  1.97
-000024f0: 3033 3333 3045 2d30 3620 2032 2e31 3035  03330E-06  2.105
-00002500: 3731 3331 452d 3036 2020 312e 3731 3734  7131E-06  1.7174
-00002510: 3130 3045 2d30 3620 2031 2e36 3938 3137  100E-06  1.69817
-00002520: 3336 452d 3036 2020 312e 3637 3033 3737  36E-06  1.670377
-00002530: 3345 2d30 3620 2031 2e36 3231 3235 3338  3E-06  1.6212538
-00002540: 452d 3036 2020 312e 3830 3439 3730 3045  E-06  1.8049700E
-00002550: 2d30 3620 2031 2e36 3131 3831 3737 452d  -06  1.6118177E-
-00002560: 3036 2020 312e 3537 3831 3539 3245 2d30  06  1.5781592E-0
-00002570: 3620 2031 2e32 3337 3238 3136 452d 3036  6  1.2372816E-06
-00002580: 2020 312e 3137 3134 3130 3845 2d30 3620    1.1714108E-06 
-00002590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000021c0: 3fc5 382b aa70 ce1d 3fc5 382b aa70 ce1d  ?.8+.p..?.8+.p..
+000021d0: 3fc5 382b aa70 ce1d bfb2 89b3 8337 d466  ?.8+.p.......7.f
+000021e0: bfb2 89b3 8337 d466 bfb2 89b3 8337 d466  .....7.f.....7.f
+000021f0: 3fa0 caeb 0c50 0127 3fa0 caeb 0c50 0127  ?....P.'?....P.'
+00002200: 3fa0 caeb 0c50 0127 bf87 e694 5197 3abe  ?....P.'....Q.:.
+00002210: bf87 e694 5197 3abe bf87 e694 5197 3abe  ....Q.:.....Q.:.
+00002220: 3f3d 28f5 9b6b 2ef6 3f3d 28f5 9b6b 2ef6  ?=(..k..?=(..k..
+00002230: 3f3d 28f5 9b6b 2ef6 3f72 93a4 dc48 9006  ?=(..k..?r...H..
+00002240: 3f72 93a4 dc48 9006 3f72 93a4 dc48 9006  ?r...H..?r...H..
+00002250: bf76 f43d 9bf4 da5f bf76 f43d 9bf4 da5f  .v.=..._.v.=..._
+00002260: bf76 f43d 9bf4 da5f 3f72 95a3 fddf 852b  .v.=..._?r.....+
+00002270: 3f72 95a3 fddf 852b 3f72 95a3 fddf 852b  ?r.....+?r.....+
+00002280: bf65 e477 4fd5 1938 bf65 e477 4fd5 1938  .e.wO..8.e.wO..8
+00002290: bf65 e477 4fd5 1938 3f4d 7da3 09c4 990e  .e.wO..8?M}.....
+000022a0: 3f4d 7da3 09c4 990e 3f4d 7da3 09c4 990e  ?M}.....?M}.....
+000022b0: 3f34 e10b 070b 36cc 3f34 e10b 070b 36cc  ?4....6.?4....6.
+000022c0: 3f34 e10b 070b 36cc bf4c c1d1 3392 0fcb  ?4....6..L..3...
+000022d0: bf4c c1d1 3392 0fcb bf4c c1d1 3392 0fcb  .L..3....L..3...
+000022e0: 3f4e 4dc8 7dc2 a9be 3f4e 4dc8 7dc2 a9be  ?NM.}...?NM.}...
+000022f0: 3f4e 4dc8 7dc2 a9be bf4a 1688 9b06 c74e  ?NM.}....J.....N
+00002300: bf4a 1688 9b06 c74e bf4a 1688 9b06 c74e  .J.....N.J.....N
+00002310: 3f54 0c15 96f2 8c2b 3f54 0c15 96f2 8c2b  ?T.....+?T.....+
+00002320: 3f54 0c15 96f2 8c2b bf7a 4800 78b4 dc0d  ?T.....+.zH.x...
+00002330: bf7a 4800 78b4 dc0d bf7a 4800 78b4 dc0d  .zH.x....zH.x...
+00002340: bf3d e0b2 7bc5 224c bf3d e0b2 7bc5 224c  .=..{."L.=..{."L
+00002350: bf3d e0b2 7bc5 224c 3f61 a4d1 6816 9109  .=..{."L?a..h...
+00002360: 3f61 a4d1 6816 9109 3f61 a4d1 6816 9109  ?a..h...?a..h...
+00002370: bf64 44d4 af5c a317 bf64 44d4 af5c a317  .dD..\...dD..\..
+00002380: bf64 44d4 af5c a317 3f5b be82 667c aeef  .dD..\..?[..f|..
+00002390: 3f5b be82 667c aeef 3f5b be82 667c aeef  ?[..f|..?[..f|..
+000023a0: bf26 52a9 5b9d 506d bf26 52a9 5b9d 506d  .&R.[.Pm.&R.[.Pm
+000023b0: bf26 52a9 5b9d 506d bf54 c359 ddd7 7024  .&R.[.Pm.T.Y..p$
+000023c0: bf54 c359 ddd7 7024 bf54 c359 ddd7 7024  .T.Y..p$.T.Y..p$
+000023d0: 3f5b a57c 08c5 cbe6 3f5b a57c 08c5 cbe6  ?[.|....?[.|....
+000023e0: 3f5b a57c 08c5 cbe6 bf49 985d 8d8d 3e66  ?[.|.....I.]..>f
+000023f0: bf49 985d 8d8d 3e66 bf49 985d 8d8d 3e66  .I.]..>f.I.]..>f
+00002400: bf47 7d9e 8fc9 91ee bf47 7d9e 8fc9 91ee  .G}......G}.....
+00002410: bf47 7d9e 8fc9 91ee 3f58 9043 e794 8050  .G}.....?X.C...P
+00002420: 3f58 9043 e794 8050 3f58 9043 e794 8050  ?X.C...P?X.C...P
+00002430: bf4b 8a37 e6a8 a0cc bf4b 8a37 e6a8 a0cc  .K.7.....K.7....
+00002440: bf4b 8a37 e6a8 a0cc bf44 7149 d787 c641  .K.7.....DqI...A
+00002450: bf44 7149 d787 c641 bf44 7149 d787 c641  .DqI...A.DqI...A
+00002460: 3f57 2ce1 2d00 b2b0 3f57 2ce1 2d00 b2b0  ?W,.-...?W,.-...
+00002470: 3f57 2ce1 2d00 b2b0 bf46 2fc2 b146 52c5  ?W,.-....F/..FR.
+00002480: bf46 2fc2 b146 52c5 bf46 2fc2 b146 52c5  .F/..FR..F/..FR.
+00002490: bf4c ee5f cc92 55ef bf4c ee5f cc92 55ef  .L._..U..L._..U.
+000024a0: bf4c ee5f cc92 55ef 3f5b 7542 4965 7a78  .L._..U.?[uBIezx
+000024b0: 3f5b 7542 4965 7a78 3f5b 7542 4965 7a78  ?[uBIezx?[uBIezx
+000024c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000024d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000024e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000024f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002500: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002510: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002520: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002530: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002540: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002550: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002560: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002570: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002580: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002590: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000025f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002600: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002610: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002620: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002630: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002640: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002650: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002660: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002670: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002680: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002690: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000026f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002700: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002710: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002720: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002730: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002740: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002750: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002760: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002770: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002780: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002790: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000027f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002800: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002810: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002820: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002830: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002840: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002850: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002860: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002870: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002880: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002890: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000028f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002900: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002910: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002920: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002930: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002940: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002950: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002960: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002970: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002980: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002990: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000029f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a00: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a10: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a20: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a30: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a40: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a50: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a60: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a70: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a80: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002a90: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002aa0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ab0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ac0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ad0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ae0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002af0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b00: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b10: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b20: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b30: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b40: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b50: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b60: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b70: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b80: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002b90: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ba0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002bb0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002bc0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002bd0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002be0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002bf0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c00: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c10: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c20: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c30: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c40: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c50: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c60: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c70: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c80: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002c90: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ca0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002cb0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002cc0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002cd0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002ce0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002cf0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
```

### Comparing `healpy-1.9.1/healpy/src/_healpy_sph_transform_lib.cc` & `healpy-github-devel/healpy/src/_healpy_sph_transform_lib.cc`

 * *Files 2% similar despite different names*

```diff
@@ -42,15 +42,15 @@
 #include "healpix_data_io.h"
 #include "_healpy_utils.h"
 
 #define IS_DEBUG_ON 0
 
 /* Some helpful macro */
 #define XMALLOC(X,Y,Z) if( !(X = (Y*)malloc(Z*sizeof(Y))) ) { PyErr_NoMemory(); goto fail;}
-#define XNEW(X,Y,Z) if( !(X = new Y[Z]) ) { PyErr_NoMemory(); goto fail; }
+#define XNEW(X,Y,Z) if( !(X = new(Y[Z])) ) { PyErr_NoMemory(); goto fail; }
 #define XFREE(X) if( X ) free(X);
 #define XDELETE(X) if( X ) delete[] X;
 #define DBGPRINTF(X,...) if( IS_DEBUG_ON ) printf(X, ## __VA_ARGS__)
 
 
 static long nside2npix(long nside)
 {
@@ -149,30 +149,31 @@
   int nside=-1;
   int npix=-1;
   int num_iter=3;
   int docl=0;
   int use_weights=0;
   char * datapath=NULL;
   int polarisation = 0; /* not polarised by default */
+  int regression=1;
 
   static const char* kwlist[] = {"","lmax", "mmax","cl","iter",
-                           "use_weights", "data_path", NULL};
+                           "use_weights", "data_path", "regression", NULL};
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "O!|iiiiisi", (char **)kwlist,
                                    &PyArray_Type, &mapIin,
                                    &lmax, &mmax, &docl,
-                                   &num_iter,&use_weights,&datapath))
+                                   &num_iter,&use_weights,&datapath,&regression))
     {
       PyErr_Clear(); /* I want to try the other calling way */
 
       PyObject *t = NULL;
       if( !PyArg_ParseTupleAndKeywords(args, kwds, "O|iiiiisi", (char **)kwlist,
                                    &t,
                                    &lmax, &mmax, &docl,
-                                       &num_iter,&use_weights,&datapath))
+                                       &num_iter,&use_weights,&datapath,&regression) )
         return NULL;
       else
         {
           healpyAssertType(PySequence_Size(t)==3,
             "First argument must be a sequence with three elements.");
           PyObject *o1 = PySequence_GetItem(t, 0),
                    *o2 = PySequence_GetItem(t, 1),
@@ -305,20 +306,31 @@
     {
       read_weight_ring(datapath, nside, weight);
       for (tsize m=0; m<weight.size(); ++m) weight[m]+=1;
     }
   else
       weight.allocAndFill(2*nside,1.);
 
+  double avg = 0.0;
+  if( regression ) {
+    avg = mapI.average();
+    mapI.Add(-avg);
+  }
+
   if( !polarisation )
     map2alm_iter(mapI,almIalm,num_iter,weight);
   else
     map2alm_pol_iter(mapI, mapQ, mapU, almIalm, almGalm, almCalm, num_iter,
                      weight);
 
+  if( regression ) {
+    almIalm(0,0) += avg*sqrt(fourpi);
+    mapI.Add(avg);
+  }
+
   if( !docl )
     {
       if( !polarisation )
         return Py_BuildValue("N",almIout);
       else
         return Py_BuildValue("NNN", almIout, almGout, almCout);
     }
@@ -916,42 +928,43 @@
 
       /* m=0 */
       DBGPRINTF("   m=%d: ", 0);
       for( int i=nalm-1; i>=0; i-- )
         {
           double x;
           x = 0.0;
-          almalms[i](l,0)=xcomplex<double>(almalms[i](l,0).real(),0.0);
+          almalms[i](l,0).im = 0.0;
           for( int j=0; j<=i; j++ )
-            x += res[getidx(nalm,i,j)]*almalms[j](l,0).real();
-          almalms[i](l,0)=xcomplex<double>(x,0.);
-          DBGPRINTF(" %lg %lg ;", almalms[i](l,0).real(), almalms[i](l,0).imag());
+            x += res[getidx(nalm,i,j)]*almalms[j](l,0).re;
+          almalms[i](l,0).re = x;
+          DBGPRINTF(" %lg %lg ;", almalms[i](l,0).re, almalms[i](l,0).im);
         }
       DBGPRINTF("\n");
 
       /* m > 1 */
       for( int m=1; m<=l; m++ )
         {
           DBGPRINTF("   m=%d: ", m);
           for( int i=nalm-1; i>=0; i-- )
             {
               double xr, xi;
               xi = xr = 0.0;
               for( int j=0; j<=i; j++ )
                 {
-                  xr += res[getidx(nalm,i,j)]*almalms[j](l,m).real();
-                  xi += res[getidx(nalm,i,j)]*almalms[j](l,m).imag();
+                  xr += res[getidx(nalm,i,j)]*almalms[j](l,m).re;
+                  xi += res[getidx(nalm,i,j)]*almalms[j](l,m).im;
                   DBGPRINTF("(res[%d]=%lg, alm=%lg,%lg) %lg %lg", (int)getidx(nalm,i,j),
                             res[getidx(nalm,i,j)],
-                            almalms[j](l,m).real(), almalms[j](l,m).imag(),
+                            almalms[j](l,m).re, almalms[j](l,m).im,
                             xr, xi);
                 }
-              almalms[i](l,m)=xcomplex<double>(xr/sqrt_two,xi/sqrt_two);
+              almalms[i](l,m).re = xr/sqrt_two;
+              almalms[i](l,m).im = xi/sqrt_two;
               DBGPRINTF(" xre,xim[%d]: %lg %lg ;", i,
-                        almalms[i](l,m).real(), almalms[i](l,m).imag());
+                        almalms[i](l,m).re, almalms[i](l,m).im);
             }
           DBGPRINTF("\n");
       }
    }
 
   /* Should be finished now... */
   XFREE(cls);
@@ -978,20 +991,20 @@
   long s;
   healpyAssertType (PyArg_ParseTuple(args, "l", &s),
     "This function takes an integer as argument.");
   long n = getn(s);
   return Py_BuildValue("l",n);
 }
 
-static PyMethodDef methods[] = {
+static PyMethodDef SphtMethods[] = {
   {"_map2alm", (PyCFunction)healpy_map2alm, METH_VARARGS | METH_KEYWORDS,
    "Compute alm or cl from an input map.\n"
    "The input map is assumed to be ordered in RING.\n"
    "anafast(map,lmax=3*nside-1,mmax=lmax,cl=False,\n"
-   "        iter=3,use_weights=False,data_path=None"},
+   "        iter=3,use_weights=False,data_path=None,regression=True)"},
   {"_alm2map", (PyCFunction)healpy_alm2map, METH_VARARGS | METH_KEYWORDS,
    "Compute a map from alm.\n"
    "The output map is ordered in RING scheme.\n"
    "alm2map(alm,nside=64,lmax=-1,mmax=-1)"},
   {"_alm2map_der1", (PyCFunction)healpy_alm2map_der1, METH_VARARGS | METH_KEYWORDS,
    "Compute a map and derivatives from alm.\n"
    "The output map is ordered in RING scheme.\n"
@@ -999,30 +1012,16 @@
   {"_synalm", (PyCFunction)healpy_synalm, METH_VARARGS | METH_KEYWORDS,
    "Compute alm's given cl's and unit variance random arrays.\n"},
   {"_getn", healpy_getn, METH_VARARGS,
    "Compute number n such that n(n+1)/2 is equal to the argument.\n"},
   {NULL, NULL, 0, NULL} /* Sentinel */
 };
 
-#if PY_MAJOR_VERSION >= 3
-static PyModuleDef moduledef = {
-  PyModuleDef_HEAD_INIT,
-  "_healpy_sph_transform_lib",
-  NULL, -1, methods
-};
-#endif
 
 PyMODINIT_FUNC
-#if PY_MAJOR_VERSION < 3
 init_healpy_sph_transform_lib(void)
-#else
-PyInit__healpy_sph_transform_lib(void)
-#endif
 {
-  import_array();
+  PyObject *m;
+  m =  Py_InitModule("_healpy_sph_transform_lib", SphtMethods);
 
-#if PY_MAJOR_VERSION < 3
-  Py_InitModule("_healpy_sph_transform_lib", methods);
-#else
-  return PyModule_Create(&moduledef);
-#endif
+  import_array();
 }
```

### Comparing `healpy-1.9.1/healpy/src/_healpy_fitsio_lib.cc` & `healpy-github-devel/healpy/src/_healpy_fitsio_lib.cc`

 * *Files 6% similar despite different names*

```diff
@@ -52,15 +52,15 @@
   static const char* kwlist[] = {"","", "pol", NULL};
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "is|i", (char **)kwlist,
                                    &nside, &datapath, &polarisation))
     return NULL;
 
   healpyAssertValue((nside&(nside-1))==0,
-    "Wrong nside value (must be a power of 2, less than 2**30)");
+    "Wrong nside value (must be a power of 2)");
 
   arr<double> pw_temp, pw_pol;
   read_pixwin(datapath, nside, pw_temp, pw_pol);
 
   npy_intp szpw;
 
   szpw = pw_temp.size();
@@ -86,37 +86,20 @@
       Py_DECREF(pixwin_pol);
       return Py_BuildValue("N",pixwin_temp);
     }
   else
     return Py_BuildValue("NN",pixwin_temp,pixwin_pol);
 }
 
-static PyMethodDef methods[] = {
+static PyMethodDef HEALFITSMethods[] = {
   {"_pixwin", (PyCFunction)healpy_pixwin, METH_VARARGS | METH_KEYWORDS,
    "Return the pixel window for some nside\n"
    "_pixwin(nside,data_path,pol=False)"},
   {NULL, NULL, 0, NULL} /* Sentinel */
 };
 
-#if PY_MAJOR_VERSION >= 3
-static PyModuleDef moduledef = {
-	PyModuleDef_HEAD_INIT,
-	"_healpy_sph_transform_lib",
-	NULL, -1, methods
-};
-#endif
-
 PyMODINIT_FUNC
-#if PY_MAJOR_VERSION < 3
 init_healpy_fitsio_lib(void)
-#else
-PyInit__healpy_fitsio_lib(void)
-#endif
 {
+  Py_InitModule("_healpy_fitsio_lib", HEALFITSMethods);
   import_array();
-
-#if PY_MAJOR_VERSION < 3
-	Py_InitModule("_healpy_fitsio_lib", methods);
-#else
-	return PyModule_Create(&moduledef);
-#endif
 }
```

### Comparing `healpy-1.9.1/healpy/src/_pixelfunc.cpp` & `healpy-github-devel/healpy/src/_query_disc.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,186 +1,118 @@
-/* Generated by Cython 0.20 on Thu Sep 24 12:31:48 2015 */
+/* Generated by Cython 0.15.1 on Mon Feb 13 14:03:59 2012 */
 
 #define PY_SSIZE_T_CLEAN
-#ifndef CYTHON_USE_PYLONG_INTERNALS
-#ifdef PYLONG_BITS_IN_DIGIT
-#define CYTHON_USE_PYLONG_INTERNALS 0
-#else
-#include "pyconfig.h"
-#ifdef PYLONG_BITS_IN_DIGIT
-#define CYTHON_USE_PYLONG_INTERNALS 1
-#else
-#define CYTHON_USE_PYLONG_INTERNALS 0
-#endif
-#endif
-#endif
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02040000
-    #error Cython requires Python 2.4+.
 #else
-#define CYTHON_ABI "0_20"
+
 #include <stddef.h> /* For offsetof */
 #ifndef offsetof
 #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
+
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
     #define __fastcall
   #endif
 #endif
+
 #ifndef DL_IMPORT
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
+
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
-#ifndef Py_HUGE_VAL
-  #define Py_HUGE_VAL HUGE_VAL
-#endif
-#ifdef PYPY_VERSION
-#define CYTHON_COMPILING_IN_PYPY 1
-#define CYTHON_COMPILING_IN_CPYTHON 0
-#else
-#define CYTHON_COMPILING_IN_PYPY 0
-#define CYTHON_COMPILING_IN_CPYTHON 1
-#endif
-#if CYTHON_COMPILING_IN_PYPY
-#define Py_OptimizeFlag 0
+
+#if PY_VERSION_HEX < 0x02040000
+  #define METH_COEXIST 0
+  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
+  #define PyDict_Contains(d,o)   PySequence_Contains(d,o)
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   typedef int Py_ssize_t;
   #define PY_SSIZE_T_MAX INT_MAX
   #define PY_SSIZE_T_MIN INT_MIN
   #define PY_FORMAT_SIZE_T ""
-  #define CYTHON_FORMAT_SSIZE_T ""
   #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
-  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_As_int(o)
-  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
-                                (PyErr_Format(PyExc_TypeError, \
-                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
-                                 (PyObject*)0))
-  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
-                                  !PyComplex_Check(o))
-  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    PyNumber_Int(o)
+  #define PyIndex_Check(o)     PyNumber_Check(o)
   #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
-  #define __PYX_BUILD_PY_SSIZE_T "i"
-#else
-  #define __PYX_BUILD_PY_SSIZE_T "n"
-  #define CYTHON_FORMAT_SSIZE_T "z"
-  #define __Pyx_PyIndex_Check PyIndex_Check
 #endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
   #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
   #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
   #define PyVarObject_HEAD_INIT(type, size) \
           PyObject_HEAD_INIT(type) size,
   #define PyType_Modified(t)
+
   typedef struct {
      void *buf;
      PyObject *obj;
      Py_ssize_t len;
      Py_ssize_t itemsize;
      int readonly;
      int ndim;
      char *format;
      Py_ssize_t *shape;
      Py_ssize_t *strides;
      Py_ssize_t *suboffsets;
      void *internal;
   } Py_buffer;
+
   #define PyBUF_SIMPLE 0
   #define PyBUF_WRITABLE 0x0001
   #define PyBUF_FORMAT 0x0004
   #define PyBUF_ND 0x0008
   #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
   #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
   #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
   #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
   #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
-  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
-  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
-  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
-  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+
 #endif
+
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
-          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-  #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
-          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-  #define __Pyx_DefaultClassType PyType_Type
-#endif
-#if PY_VERSION_HEX < 0x02060000
-  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define Py_TPFLAGS_CHECKTYPES 0
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
+
 #if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
-#if PY_VERSION_HEX < 0x02060000
-  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
-#endif
-#if PY_VERSION_HEX < 0x02060000 && !defined(Py_TPFLAGS_IS_ABSTRACT)
-  #define Py_TPFLAGS_IS_ABSTRACT 0
-#endif
-#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
-  #define Py_TPFLAGS_HAVE_FINALIZE 0
-#endif
-#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
-  #define CYTHON_PEP393_ENABLED 1
-  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
-                                              0 : _PyUnicode_Ready((PyObject *)(op)))
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
-  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
-  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-#else
-  #define CYTHON_PEP393_ENABLED 0
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-#endif
-#define __Pyx_PyString_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
-#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
-#define __Pyx_PyUnicode_Concat(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
-    PyNumber_Add(a, b) : PyUnicode_Concat(a, b))
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
-#else
-  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
-#endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyBaseString_Type            PyUnicode_Type
   #define PyStringObject               PyUnicodeObject
   #define PyString_Type                PyUnicode_Type
   #define PyString_Check               PyUnicode_Check
   #define PyString_CheckExact          PyUnicode_CheckExact
 #endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define PyBytesObject                PyStringObject
   #define PyBytes_Type                 PyString_Type
   #define PyBytes_Check                PyString_Check
   #define PyBytes_CheckExact           PyString_CheckExact
   #define PyBytes_FromString           PyString_FromString
   #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
@@ -191,30 +123,25 @@
   #define PyBytes_Size                 PyString_Size
   #define PyBytes_AS_STRING            PyString_AS_STRING
   #define PyBytes_GET_SIZE             PyString_GET_SIZE
   #define PyBytes_Repr                 PyString_Repr
   #define PyBytes_Concat               PyString_Concat
   #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
 #endif
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
-  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
-#else
-  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
-                                         PyString_Check(obj) || PyUnicode_Check(obj))
-  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
-#endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
   #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
 #endif
 #ifndef PySet_CheckExact
   #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
+
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
@@ -222,27 +149,38 @@
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
-  #define PyNumber_Int                 PyNumber_Long
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
+
 #if PY_VERSION_HEX < 0x03020000
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
   #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
   #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
 #endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
 #if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
   #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
   #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
   #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
 #else
   #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
         (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
@@ -253,268 +191,116 @@
         (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
             (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
   #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
         (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
         (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
             (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
   #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
   #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
 #else
   #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
   #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
   #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   #define __Pyx_NAMESTR(n) ((char *)(n))
   #define __Pyx_DOCSTR(n)  ((char *)(n))
 #else
   #define __Pyx_NAMESTR(n) (n)
   #define __Pyx_DOCSTR(n)  (n)
 #endif
-#ifndef CYTHON_INLINE
-  #if defined(__GNUC__)
-    #define CYTHON_INLINE __inline__
-  #elif defined(_MSC_VER)
-    #define CYTHON_INLINE __inline
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_INLINE inline
-  #else
-    #define CYTHON_INLINE
-  #endif
-#endif
-#ifndef CYTHON_RESTRICT
-  #if defined(__GNUC__)
-    #define CYTHON_RESTRICT __restrict__
-  #elif defined(_MSC_VER) && _MSC_VER >= 1400
-    #define CYTHON_RESTRICT __restrict
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_RESTRICT restrict
-  #else
-    #define CYTHON_RESTRICT
-  #endif
-#endif
-#ifdef NAN
-#define __PYX_NAN() ((float) NAN)
-#else
-static CYTHON_INLINE float __PYX_NAN() {
-  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
-   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
-   a quiet NaN. */
-  float value;
-  memset(&value, 0xFF, sizeof(value));
-  return value;
-}
-#endif
-
-
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
-#else
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
-#endif
 
 #ifndef __PYX_EXTERN_C
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
 #if defined(WIN32) || defined(MS_WINDOWS)
 #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
-#define __PYX_HAVE__healpy___pixelfunc
-#define __PYX_HAVE_API__healpy___pixelfunc
-#include "string.h"
+#define __PYX_HAVE__healpy___query_disc
+#define __PYX_HAVE_API__healpy___query_disc
 #include "stdio.h"
 #include "stdlib.h"
 #include "numpy/arrayobject.h"
 #include "numpy/ufuncobject.h"
 #include <vector>
-#include "ios"
-#include "new"
-#include "stdexcept"
-#include "typeinfo"
-#include "stddef.h"
-#include "datatypes.h"
-#include "xcomplex.h"
-#include "arr.h"
+#include "healpix_base.h"
 #include "rangeset.h"
+#include "arr.h"
 #include "vec3.h"
 #include "pointing.h"
-#include "healpix_base.h"
-#include "healpix_map.h"
-#include "alm.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #ifdef PYREX_WITHOUT_ASSERTIONS
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
 
+
+/* inline attribute */
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+
+/* unused attribute */
 #ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
-# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+# elif defined(__ICC) || defined(__INTEL_COMPILER)
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
-                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
 
-#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
-#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
-#define __PYX_DEFAULT_STRING_ENCODING ""
-#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
-#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
-#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
-    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
-    (sizeof(type) > sizeof(Py_ssize_t) &&               \
-          likely(v < (type)PY_SSIZE_T_MAX ||            \
-                 v == (type)PY_SSIZE_T_MAX)  &&         \
-          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
-                                v == (type)PY_SSIZE_T_MIN)))  ||  \
-    (sizeof(type) == sizeof(Py_ssize_t) &&              \
-          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
-                               v == (type)PY_SSIZE_T_MAX)))  )
-static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
-static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
-#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
-#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
-#define __Pyx_PyBytes_FromString        PyBytes_FromString
-#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
-#if PY_MAJOR_VERSION < 3
-    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
-#else
-    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
-#endif
-#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
-#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
-#define __Pyx_PyByteArray_FromUString(s)   __Pyx_PyByteArray_FromString((char*)s)
-#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
-#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
-#if PY_MAJOR_VERSION < 3
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return u_end - u - 1;
-}
-#else
-#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
-#endif
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
-#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+
+/* Type Conversion Predeclarations */
+
+#define __Pyx_PyBytes_FromUString(s) PyBytes_FromString((char*)s)
+#define __Pyx_PyBytes_AsUString(s)   ((unsigned char*) PyBytes_AsString(s))
+
 #define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
 #define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
-#else
-#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
-#endif
-#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-static int __Pyx_sys_getdefaultencoding_not_ascii;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys = NULL;
-    PyObject* default_encoding = NULL;
-    PyObject* ascii_chars_u = NULL;
-    PyObject* ascii_chars_b = NULL;
-    sys = PyImport_ImportModule("sys");
-    if (sys == NULL) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
-    if (default_encoding == NULL) goto bad;
-    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
-        __Pyx_sys_getdefaultencoding_not_ascii = 0;
-    } else {
-        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
-        char ascii_chars[128];
-        int c;
-        for (c = 0; c < 128; c++) {
-            ascii_chars[c] = c;
-        }
-        __Pyx_sys_getdefaultencoding_not_ascii = 1;
-        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
-        if (ascii_chars_u == NULL) goto bad;
-        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
-        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
-            PyErr_Format(
-                PyExc_ValueError,
-                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
-                default_encoding_c);
-            goto bad;
-        }
-    }
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    Py_XDECREF(ascii_chars_u);
-    Py_XDECREF(ascii_chars_b);
-    return 0;
-bad:
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    Py_XDECREF(ascii_chars_u);
-    Py_XDECREF(ascii_chars_b);
-    return -1;
-}
-#endif
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
-#else
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-static char* __PYX_DEFAULT_STRING_ENCODING;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys = NULL;
-    PyObject* default_encoding = NULL;
-    char* default_encoding_c;
-    sys = PyImport_ImportModule("sys");
-    if (sys == NULL) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
-    if (default_encoding == NULL) goto bad;
-    default_encoding_c = PyBytes_AS_STRING(default_encoding);
-    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
-    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
-    Py_DECREF(sys);
-    Py_DECREF(default_encoding);
-    return 0;
-bad:
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    return -1;
-}
-#endif
-#endif
 
 
 #ifdef __GNUC__
   /* Test for GCC > 2.95 */
   #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
     #define likely(x)   __builtin_expect(!!(x), 1)
     #define unlikely(x) __builtin_expect(!!(x), 0)
@@ -522,304 +308,242 @@
     #define likely(x)   (x)
     #define unlikely(x) (x)
   #endif /* __GNUC__ > 2 ... */
 #else /* __GNUC__ */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
-
+    
 static PyObject *__pyx_m;
-static PyObject *__pyx_d;
 static PyObject *__pyx_b;
 static PyObject *__pyx_empty_tuple;
 static PyObject *__pyx_empty_bytes;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
+
 #if !defined(CYTHON_CCOMPLEX)
   #if defined(__cplusplus)
     #define CYTHON_CCOMPLEX 1
   #elif defined(_Complex_I)
     #define CYTHON_CCOMPLEX 1
   #else
     #define CYTHON_CCOMPLEX 0
   #endif
 #endif
+
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #include <complex>
   #else
     #include <complex.h>
   #endif
 #endif
+
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
-
 static const char *__pyx_f[] = {
-  "_pixelfunc.pyx",
-  "_common.pxd",
-  "__init__.pxd",
-  "type.pxd",
+  "_query_disc.pyx",
+  "numpy.pxd",
 };
-#define IS_UNSIGNED(type) (((type) -1) > 0)
-struct __Pyx_StructField_;
-#define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
-typedef struct {
-  const char* name; /* for error messages only */
-  struct __Pyx_StructField_* fields;
-  size_t size;     /* sizeof(type) */
-  size_t arraysize[8]; /* length of array in each dimension */
-  int ndim;
-  char typegroup; /* _R_eal, _C_omplex, Signed _I_nt, _U_nsigned int, _S_truct, _P_ointer, _O_bject, c_H_ar */
-  char is_unsigned;
-  int flags;
-} __Pyx_TypeInfo;
-typedef struct __Pyx_StructField_ {
-  __Pyx_TypeInfo* type;
-  const char* name;
-  size_t offset;
-} __Pyx_StructField;
-typedef struct {
-  __Pyx_StructField* field;
-  size_t parent_offset;
-} __Pyx_BufFmt_StackElem;
-typedef struct {
-  __Pyx_StructField root;
-  __Pyx_BufFmt_StackElem* head;
-  size_t fmt_offset;
-  size_t new_count, enc_count;
-  size_t struct_alignment;
-  int is_complex;
-  char enc_type;
-  char new_packmode;
-  char enc_packmode;
-  char is_valid_array;
-} __Pyx_BufFmt_Context;
 
-
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":723
+/* "numpy.pxd":719
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":724
+/* "numpy.pxd":720
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":725
+/* "numpy.pxd":721
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":726
+/* "numpy.pxd":722
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":730
+/* "numpy.pxd":726
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":731
+/* "numpy.pxd":727
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":732
+/* "numpy.pxd":728
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":733
+/* "numpy.pxd":729
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":737
+/* "numpy.pxd":733
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":738
+/* "numpy.pxd":734
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":747
+/* "numpy.pxd":743
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":748
+/* "numpy.pxd":744
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":749
+/* "numpy.pxd":745
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":751
+/* "numpy.pxd":747
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":752
+/* "numpy.pxd":748
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":753
+/* "numpy.pxd":749
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":755
+/* "numpy.pxd":751
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":756
+/* "numpy.pxd":752
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":758
+/* "numpy.pxd":754
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":759
+/* "numpy.pxd":755
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":760
+/* "numpy.pxd":756
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
 
-/* "_common.pxd":6
- * from libcpp.vector cimport vector
- * 
- * ctypedef unsigned size_t             # <<<<<<<<<<<<<<
- * ctypedef size_t tsize
- * 
- */
-typedef unsigned int __pyx_t_7_common_size_t;
-
-/* "_common.pxd":7
- * 
- * ctypedef unsigned size_t
- * ctypedef size_t tsize             # <<<<<<<<<<<<<<
- * 
- * cdef extern from "stddef.h":
- */
-typedef size_t __pyx_t_7_common_tsize;
-
-/* "_common.pxd":11
- * cdef extern from "stddef.h":
- *     ctypedef long ptrdiff_t
- * ctypedef ptrdiff_t tdiff             # <<<<<<<<<<<<<<
- * 
- * cdef extern from "datatypes.h":
- */
-typedef ptrdiff_t __pyx_t_7_common_tdiff;
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     typedef ::std::complex< float > __pyx_t_float_complex;
   #else
     typedef float _Complex __pyx_t_float_complex;
   #endif
 #else
@@ -832,222 +556,249 @@
   #else
     typedef double _Complex __pyx_t_double_complex;
   #endif
 #else
     typedef struct { double real, imag; } __pyx_t_double_complex;
 #endif
 
-
 /*--- Type declarations ---*/
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":762
+/* "numpy.pxd":758
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":763
+/* "numpy.pxd":759
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":764
+/* "numpy.pxd":760
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":766
+/* "numpy.pxd":762
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
+
+
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
+
 #if CYTHON_REFNANNY
   typedef struct {
     void (*INCREF)(void*, PyObject*, int);
     void (*DECREF)(void*, PyObject*, int);
     void (*GOTREF)(void*, PyObject*, int);
     void (*GIVEREF)(void*, PyObject*, int);
     void* (*SetupContext)(const char*, int, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
-#ifdef WITH_THREAD
-  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
-          if (acquire_gil) { \
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
-              PyGILState_Release(__pyx_gilstate_save); \
-          } else { \
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
-          }
-#else
-  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
-#endif
-  #define __Pyx_RefNannyFinishContext() \
-          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_RefNannySetupContext(name)           __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+  #define __Pyx_RefNannyFinishContext()           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
   #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
   #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
   #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
   #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
-  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannySetupContext(name)
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif /* CYTHON_REFNANNY */
-#define __Pyx_XDECREF_SET(r, v) do {                            \
-        PyObject *tmp = (PyObject *) r;                         \
-        r = v; __Pyx_XDECREF(tmp);                              \
-    } while (0)
-#define __Pyx_DECREF_SET(r, v) do {                             \
-        PyObject *tmp = (PyObject *) r;                         \
-        r = v; __Pyx_DECREF(tmp);                               \
-    } while (0)
-#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
-#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
-
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
-#endif
-    return PyObject_GetAttr(obj, attr_name);
-}
-#else
-#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
-#endif
 
-static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/
 
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
 
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
-
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
-    const char* function_name); /*proto*/
-
-static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
-    const char *name, int exact); /*proto*/
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name, PyObject* kw_name); /*proto*/
 
-static CYTHON_INLINE int  __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj,
-    __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
-static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/
 
 static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
 static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
 
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
 
-static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
 
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
 
-static void __Pyx_RaiseBufferIndexError(int axis); /*proto*/
 
-#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback); /*proto*/
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_List_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
 
-#define __Pyx_BufPtrCContig1d(type, buf, i0, s0) ((type)buf + i0)
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+            PyObject *r = PyList_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyList_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyList_GET_ITEM(o, PyList_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
 
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Tuple_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
 
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyTuple_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyTuple_GET_ITEM(o, PyTuple_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+
+#define __Pyx_GetItemInt(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i) {
+    PyObject *r;
+    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
+    }
+    else if (PyTuple_CheckExact(o) && ((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+    }
+    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_item && (likely(i >= 0))) {
+        r = PySequence_GetItem(o, i);
+    }
+    else {
+        r = __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+    }
+    return r;
+}
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+
+/* Run-time type information about structs used with buffers */
+struct __Pyx_StructField_;
 
 typedef struct {
-  Py_ssize_t shape, strides, suboffsets;
-} __Pyx_Buf_DimInfo;
-typedef struct {
-  size_t refcount;
-  Py_buffer pybuffer;
-} __Pyx_Buffer;
+  const char* name; /* for error messages only */
+  struct __Pyx_StructField_* fields;
+  size_t size;     /* sizeof(type) */
+  char typegroup; /* _R_eal, _C_omplex, Signed _I_nt, _U_nsigned int, _S_truct, _P_ointer, _O_bject */
+} __Pyx_TypeInfo;
+
+typedef struct __Pyx_StructField_ {
+  __Pyx_TypeInfo* type;
+  const char* name;
+  size_t offset;
+} __Pyx_StructField;
+
 typedef struct {
-  __Pyx_Buffer *rcbuffer;
-  char *data;
-  __Pyx_Buf_DimInfo diminfo[8];
-} __Pyx_LocalBuf_ND;
+  __Pyx_StructField* field;
+  size_t parent_offset;
+} __Pyx_BufFmt_StackElem;
 
-#if PY_MAJOR_VERSION < 3
-    static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
-    static void __Pyx_ReleaseBuffer(Py_buffer *view);
-#else
-    #define __Pyx_GetBuffer PyObject_GetBuffer
-    #define __Pyx_ReleaseBuffer PyBuffer_Release
-#endif
 
+static CYTHON_INLINE int  __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
+static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
+static void __Pyx_RaiseBufferIndexError(int axis); /*proto*/
+#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
 
-static Py_ssize_t __Pyx_zeros[] = {0, 0, 0, 0, 0, 0, 0, 0};
-static Py_ssize_t __Pyx_minusones[] = {-1, -1, -1, -1, -1, -1, -1, -1};
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
-static CYTHON_INLINE int64 __Pyx_PyInt_As_int64(PyObject *);
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index); /*proto*/
+#if PY_MAJOR_VERSION < 3
+static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
+static void __Pyx_ReleaseBuffer(Py_buffer *view);
+#else
+#define __Pyx_GetBuffer PyObject_GetBuffer
+#define __Pyx_ReleaseBuffer PyBuffer_Release
+#endif
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_Py_intptr_t(Py_intptr_t value);
+Py_ssize_t __Pyx_zeros[] = {0};
+Py_ssize_t __Pyx_minusones[] = {-1};
 
-static CYTHON_INLINE Py_intptr_t __Pyx_PyInt_As_Py_intptr_t(PyObject *);
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, long level); /*proto*/
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
+static CYTHON_INLINE int64 __Pyx_PyInt_from_py_int64(PyObject *);
 
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_int64(int64);
 
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #define __Pyx_CREAL(z) ((z).real())
     #define __Pyx_CIMAG(z) ((z).imag())
   #else
     #define __Pyx_CREAL(z) (__real__(z))
     #define __Pyx_CIMAG(z) (__imag__(z))
   #endif
 #else
     #define __Pyx_CREAL(z) ((z).real)
     #define __Pyx_CIMAG(z) ((z).imag)
 #endif
-#if (defined(_WIN32) || defined(__clang__)) && defined(__cplusplus) && CYTHON_CCOMPLEX
+
+#if defined(_WIN32) && defined(__cplusplus) && CYTHON_CCOMPLEX
     #define __Pyx_SET_CREAL(z,x) ((z).real(x))
     #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
 #else
     #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
     #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
 #endif
 
@@ -1125,1541 +876,1288 @@
     static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex);
     #if 1
         static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex);
         static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex, __pyx_t_double_complex);
     #endif
 #endif
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
 
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
 
-static int __Pyx_check_binary_version(void);
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
 
-#if !defined(__Pyx_PyIdentifier_FromString)
-#if PY_MAJOR_VERSION < 3
-  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
-#else
-  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
-#endif
-#endif
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
 
-static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename); /*proto*/
+
+static int __Pyx_check_binary_version(void);
 
 static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
 
-typedef struct {
-    int code_line;
-    PyCodeObject* code_object;
-} __Pyx_CodeObjectCacheEntry;
-struct __Pyx_CodeObjectCache {
-    int count;
-    int max_count;
-    __Pyx_CodeObjectCacheEntry* entries;
-};
-static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
-static PyCodeObject *__pyx_find_code_object(int code_line);
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
 
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename); /*proto*/
+static void __Pyx_AddTraceback(const char *funcname, int __pyx_clineno,
+                               int __pyx_lineno, const char *__pyx_filename); /*proto*/
 
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
 
-
 /* Module declarations from 'cpython.buffer' */
 
 /* Module declarations from 'cpython.ref' */
 
-/* Module declarations from 'libc.string' */
-
 /* Module declarations from 'libc.stdio' */
 
 /* Module declarations from 'cpython.object' */
 
-/* Module declarations from '__builtin__' */
-
-/* Module declarations from 'cpython.type' */
-static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
-
 /* Module declarations from 'libc.stdlib' */
 
 /* Module declarations from 'numpy' */
 
 /* Module declarations from 'numpy' */
 static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
 static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
 static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
 static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
 static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *, PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *, PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
 static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/
+static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *); /*proto*/
 
 /* Module declarations from 'libcpp' */
 
-/* Module declarations from 'cython' */
-
 /* Module declarations from 'libcpp.vector' */
 
-/* Module declarations from '_common' */
+/* Module declarations from 'cython.cython.view' */
+
+/* Module declarations from 'cython' */
 
-/* Module declarations from 'healpy._pixelfunc' */
-static bool __pyx_f_6healpy_10_pixelfunc_isnsideok(int); /*proto*/
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn_int64 = { "int64", NULL, sizeof(int64), { 0 }, 0, IS_UNSIGNED(int64) ? 'U' : 'I', IS_UNSIGNED(int64), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn_bool = { "bool", NULL, sizeof(bool), { 0 }, 0, IS_UNSIGNED(bool) ? 'U' : 'I', IS_UNSIGNED(bool), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t = { "float64_t", NULL, sizeof(__pyx_t_5numpy_float64_t), { 0 }, 0, 'R', 0, 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo___pyx_t_double_complex = { "double complex", NULL, sizeof(__pyx_t_double_complex), { 0 }, 0, 'C', 0, 0 };
-#define __Pyx_MODULE_NAME "healpy._pixelfunc"
-int __pyx_module_is_main_healpy___pixelfunc = 0;
+/* Module declarations from 'healpy._query_disc' */
+static PyObject *__pyx_f_6healpy_11_query_disc_pixset_to_array(rangeset<int64> &); /*proto*/
+static bool __pyx_f_6healpy_11_query_disc_isnsideok(int); /*proto*/
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_int64_t = { "int64_t", NULL, sizeof(__pyx_t_5numpy_int64_t), 'I' };
+#define __Pyx_MODULE_NAME "healpy._query_disc"
+int __pyx_module_is_main_healpy___query_disc = 0;
 
-/* Implementation of 'healpy._pixelfunc' */
+/* Implementation of 'healpy._query_disc' */
 static PyObject *__pyx_builtin_ValueError;
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_round;
 static PyObject *__pyx_builtin_RuntimeError;
-static PyObject *__pyx_pf_6healpy_10_pixelfunc_ringinfo(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nside, PyArrayObject *__pyx_v_ring); /* proto */
-static PyObject *__pyx_pf_6healpy_10_pixelfunc_2pix2ring(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nside, PyArrayObject *__pyx_v_pix, PyObject *__pyx_v_nest); /* proto */
-static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
-static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
-static char __pyx_k_B[] = "B";
-static char __pyx_k_H[] = "H";
-static char __pyx_k_I[] = "I";
-static char __pyx_k_L[] = "L";
-static char __pyx_k_O[] = "O";
-static char __pyx_k_Q[] = "Q";
-static char __pyx_k_b[] = "b";
-static char __pyx_k_d[] = "d";
-static char __pyx_k_f[] = "f";
-static char __pyx_k_g[] = "g";
-static char __pyx_k_h[] = "h";
-static char __pyx_k_i[] = "i";
-static char __pyx_k_l[] = "l";
-static char __pyx_k_q[] = "q";
-static char __pyx_k_Zd[] = "Zd";
-static char __pyx_k_Zf[] = "Zf";
-static char __pyx_k_Zg[] = "Zg";
-static char __pyx_k_hb[] = "hb";
-static char __pyx_k_np[] = "np";
-static char __pyx_k_num[] = "num";
-static char __pyx_k_pix[] = "pix";
-static char __pyx_k_bool[] = "bool";
-static char __pyx_k_log2[] = "log2";
-static char __pyx_k_main[] = "__main__";
-static char __pyx_k_nest[] = "nest";
-static char __pyx_k_ring[] = "ring";
-static char __pyx_k_size[] = "size";
-static char __pyx_k_test[] = "__test__";
-static char __pyx_k_dtype[] = "dtype";
-static char __pyx_k_empty[] = "empty";
-static char __pyx_k_float[] = "float";
-static char __pyx_k_int64[] = "int64";
-static char __pyx_k_nside[] = "nside";
-static char __pyx_k_numpy[] = "numpy";
-static char __pyx_k_range[] = "range";
-static char __pyx_k_round[] = "round";
-static char __pyx_k_import[] = "__import__";
-static char __pyx_k_scheme[] = "scheme";
-static char __pyx_k_ringpix[] = "ringpix";
-static char __pyx_k_shifted[] = "shifted";
-static char __pyx_k_costheta[] = "costheta";
-static char __pyx_k_pix2ring[] = "pix2ring";
-static char __pyx_k_ringinfo[] = "ringinfo";
-static char __pyx_k_sintheta[] = "sintheta";
-static char __pyx_k_startpix[] = "startpix";
-static char __pyx_k_ValueError[] = "ValueError";
-static char __pyx_k_RuntimeError[] = "RuntimeError";
-static char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
-static char __pyx_k_ringinfo_line_9[] = "ringinfo (line 9)";
-static char __pyx_k_pix2ring_line_58[] = "pix2ring (line 58)";
-static char __pyx_k_healpy__pixelfunc[] = "healpy._pixelfunc";
-static char __pyx_k_pyx_releasebuffer[] = "__pyx_releasebuffer";
-static char __pyx_k_ndarray_is_not_C_contiguous[] = "ndarray is not C contiguous";
-static char __pyx_k_Get_information_for_rings_Rings[] = "Get information for rings\n\n    Rings are specified by a positive integer, 1 <= ring <= 4*nside-1.\n\n    Parameters\n    ----------\n    nside : int\n      The healpix nside parameter, must be a power of 2, less than 2**30\n    ring : int, scalar or array-like\n      The ring number\n\n    Returns\n    -------\n    startpix : int64, length equal to that of *ring*\n      Starting pixel identifier (NEST ordering)\n    ringpix : int64, length equal to that of *ring*\n      Number of pixels in ring\n    costheta : float, length equal to that of *ring*\n      Cosine of the co-latitude\n    sintheta : float, length equal to that of *ring*\n      Sine of the co-latitude\n    shifted : bool, length equal to that of *ring*\n      If True, the center of the first pixel is not at phi=0\n\n    Example\n    -------\n    >>> import healpy as hp\n    >>> import numpy as np\n    >>> nside = 2\n    >>> hp.ringinfo(nside, np.arange(4*nside-1))\n    (array([ 0,  0,  4, 12, 20, 28, 36]), array([0, 4, 8, 8, 8, 8, 8]), array([ 1.        ,  0.91666667,  0.66666667,  0.33333333,  0.        ,\n           -0.33333333, -0.66666667]), array([ 0.        ,  0.39965263,  0.74535599,  0.94280904,  1.        ,\n            0.94280904,  0.74535599]), array([ True,  True,  True, False,  True, False,  True], dtype=bool))\n    ";
-static char __pyx_k_home_zonca_healpy_healpy_src__p[] = "/home/zonca/healpy/healpy/src/_pixelfunc.pyx";
-static char __pyx_k_unknown_dtype_code_in_numpy_pxd[] = "unknown dtype code in numpy.pxd (%d)";
-static char __pyx_k_Convert_pixel_identifier_to_ring[] = "Convert pixel identifier to ring number\n\n    Rings are specified by a positive integer, 1 <= ring <= 4*nside-1.\n\n    Parameters\n    ----------\n    nside : int\n      The healpix nside parameter, must be a power of 2, less than 2**30\n    pix : int64, scalar or array-like\n      The pixel identifier(s)\n    nest : bool\n      Is *pix* specified in the NEST ordering scheme?\n\n    Returns\n    -------\n    ring : int, length equal to that of *pix*\n      Ring number\n\n    Example\n    -------\n    >>> import healpy as hp\n    >>> import numpy as np\n    >>> nside = 2\n    >>> hp.pix2ring(nside, np.arange(hp.nside2npix(nside)))\n    array([1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,\n           4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,\n           7, 7])\n    ";
-static char __pyx_k_Format_string_allocated_too_shor[] = "Format string allocated too short, see comment in numpy.pxd";
-static char __pyx_k_Non_native_byte_order_not_suppor[] = "Non-native byte order not supported";
-static char __pyx_k_Wrong_nside_value_must_be_a_powe[] = "Wrong nside value, must be a power of 2, less than 2**30";
-static char __pyx_k_ndarray_is_not_Fortran_contiguou[] = "ndarray is not Fortran contiguous";
-static char __pyx_k_Format_string_allocated_too_shor_2[] = "Format string allocated too short.";
-static PyObject *__pyx_kp_u_Convert_pixel_identifier_to_ring;
-static PyObject *__pyx_kp_u_Format_string_allocated_too_shor;
-static PyObject *__pyx_kp_u_Format_string_allocated_too_shor_2;
-static PyObject *__pyx_kp_u_Get_information_for_rings_Rings;
-static PyObject *__pyx_kp_u_Non_native_byte_order_not_suppor;
-static PyObject *__pyx_n_s_RuntimeError;
-static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_kp_s_Wrong_nside_value_must_be_a_powe;
-static PyObject *__pyx_n_s_bool;
-static PyObject *__pyx_n_s_costheta;
-static PyObject *__pyx_n_s_dtype;
-static PyObject *__pyx_n_s_empty;
-static PyObject *__pyx_n_s_float;
-static PyObject *__pyx_n_s_hb;
-static PyObject *__pyx_n_s_healpy__pixelfunc;
-static PyObject *__pyx_kp_s_home_zonca_healpy_healpy_src__p;
-static PyObject *__pyx_n_s_i;
-static PyObject *__pyx_n_s_import;
-static PyObject *__pyx_n_s_int64;
-static PyObject *__pyx_n_s_log2;
-static PyObject *__pyx_n_s_main;
-static PyObject *__pyx_kp_u_ndarray_is_not_C_contiguous;
-static PyObject *__pyx_kp_u_ndarray_is_not_Fortran_contiguou;
-static PyObject *__pyx_n_s_nest;
-static PyObject *__pyx_n_s_np;
-static PyObject *__pyx_n_s_nside;
-static PyObject *__pyx_n_s_num;
-static PyObject *__pyx_n_s_numpy;
-static PyObject *__pyx_n_s_pix;
-static PyObject *__pyx_n_s_pix2ring;
-static PyObject *__pyx_kp_u_pix2ring_line_58;
-static PyObject *__pyx_n_s_pyx_getbuffer;
-static PyObject *__pyx_n_s_pyx_releasebuffer;
-static PyObject *__pyx_n_s_range;
-static PyObject *__pyx_n_s_ring;
-static PyObject *__pyx_n_s_ringinfo;
-static PyObject *__pyx_kp_u_ringinfo_line_9;
-static PyObject *__pyx_n_s_ringpix;
-static PyObject *__pyx_n_s_round;
-static PyObject *__pyx_n_s_scheme;
-static PyObject *__pyx_n_s_shifted;
-static PyObject *__pyx_n_s_sintheta;
-static PyObject *__pyx_n_s_size;
-static PyObject *__pyx_n_s_startpix;
-static PyObject *__pyx_n_s_test;
-static PyObject *__pyx_kp_u_unknown_dtype_code_in_numpy_pxd;
+static char __pyx_k_3[] = "Wrong nside value, must be a power of 2";
+static char __pyx_k_11[] = "ndarray is not C contiguous";
+static char __pyx_k_13[] = "ndarray is not Fortran contiguous";
+static char __pyx_k_15[] = "Non-native byte order not supported";
+static char __pyx_k_17[] = "unknown dtype code in numpy.pxd (%d)";
+static char __pyx_k_18[] = "Format string allocated too short, see comment in numpy.pxd";
+static char __pyx_k_21[] = "Format string allocated too short.";
+static char __pyx_k_23[] = "healpy._query_disc";
+static char __pyx_k__B[] = "B";
+static char __pyx_k__H[] = "H";
+static char __pyx_k__I[] = "I";
+static char __pyx_k__L[] = "L";
+static char __pyx_k__O[] = "O";
+static char __pyx_k__Q[] = "Q";
+static char __pyx_k__b[] = "b";
+static char __pyx_k__d[] = "d";
+static char __pyx_k__f[] = "f";
+static char __pyx_k__g[] = "g";
+static char __pyx_k__h[] = "h";
+static char __pyx_k__i[] = "i";
+static char __pyx_k__l[] = "l";
+static char __pyx_k__q[] = "q";
+static char __pyx_k__Zd[] = "Zd";
+static char __pyx_k__Zf[] = "Zf";
+static char __pyx_k__Zg[] = "Zg";
+static char __pyx_k__np[] = "np";
+static char __pyx_k__vec[] = "vec";
+static char __pyx_k__log2[] = "log2";
+static char __pyx_k__nest[] = "nest";
+static char __pyx_k__dtype[] = "dtype";
+static char __pyx_k__empty[] = "empty";
+static char __pyx_k__int64[] = "int64";
+static char __pyx_k__nside[] = "nside";
+static char __pyx_k__numpy[] = "numpy";
+static char __pyx_k__range[] = "range";
+static char __pyx_k__round[] = "round";
+static char __pyx_k__radius[] = "radius";
+static char __pyx_k__theta1[] = "theta1";
+static char __pyx_k__theta2[] = "theta2";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__vertices[] = "vertices";
+static char __pyx_k__inclusive[] = "inclusive";
+static char __pyx_k__ValueError[] = "ValueError";
+static char __pyx_k__query_disc[] = "query_disc";
+static char __pyx_k__query_strip[] = "query_strip";
+static char __pyx_k__RuntimeError[] = "RuntimeError";
+static char __pyx_k__query_polygon[] = "query_polygon";
+static PyObject *__pyx_kp_u_11;
+static PyObject *__pyx_kp_u_13;
+static PyObject *__pyx_kp_u_15;
+static PyObject *__pyx_kp_u_17;
+static PyObject *__pyx_kp_u_18;
+static PyObject *__pyx_kp_u_21;
+static PyObject *__pyx_n_s_23;
+static PyObject *__pyx_kp_s_3;
+static PyObject *__pyx_n_s__RuntimeError;
+static PyObject *__pyx_n_s__ValueError;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__dtype;
+static PyObject *__pyx_n_s__empty;
+static PyObject *__pyx_n_s__inclusive;
+static PyObject *__pyx_n_s__int64;
+static PyObject *__pyx_n_s__log2;
+static PyObject *__pyx_n_s__nest;
+static PyObject *__pyx_n_s__np;
+static PyObject *__pyx_n_s__nside;
+static PyObject *__pyx_n_s__numpy;
+static PyObject *__pyx_n_s__query_disc;
+static PyObject *__pyx_n_s__query_polygon;
+static PyObject *__pyx_n_s__query_strip;
+static PyObject *__pyx_n_s__radius;
+static PyObject *__pyx_n_s__range;
+static PyObject *__pyx_n_s__round;
+static PyObject *__pyx_n_s__theta1;
+static PyObject *__pyx_n_s__theta2;
+static PyObject *__pyx_n_s__vec;
+static PyObject *__pyx_n_s__vertices;
 static PyObject *__pyx_int_2;
-static PyObject *__pyx_tuple_;
-static PyObject *__pyx_tuple__2;
-static PyObject *__pyx_tuple__3;
-static PyObject *__pyx_tuple__4;
-static PyObject *__pyx_tuple__5;
-static PyObject *__pyx_tuple__6;
-static PyObject *__pyx_tuple__7;
-static PyObject *__pyx_tuple__8;
-static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_tuple__11;
-static PyObject *__pyx_codeobj__10;
-static PyObject *__pyx_codeobj__12;
-
-/* "healpy/src/_pixelfunc.pyx":9
- * from _common cimport int64, Healpix_Ordering_Scheme, RING, NEST, SET_NSIDE, T_Healpix_Base
- * 
- * def ringinfo(nside, np.ndarray[int64, ndim=1] ring not None):             # <<<<<<<<<<<<<<
- *     """Get information for rings
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_10_pixelfunc_1ringinfo(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_10_pixelfunc_ringinfo[] = "Get information for rings\n\n    Rings are specified by a positive integer, 1 <= ring <= 4*nside-1.\n\n    Parameters\n    ----------\n    nside : int\n      The healpix nside parameter, must be a power of 2, less than 2**30\n    ring : int, scalar or array-like\n      The ring number\n\n    Returns\n    -------\n    startpix : int64, length equal to that of *ring*\n      Starting pixel identifier (NEST ordering)\n    ringpix : int64, length equal to that of *ring*\n      Number of pixels in ring\n    costheta : float, length equal to that of *ring*\n      Cosine of the co-latitude\n    sintheta : float, length equal to that of *ring*\n      Sine of the co-latitude\n    shifted : bool, length equal to that of *ring*\n      If True, the center of the first pixel is not at phi=0\n\n    Example\n    -------\n    >>> import healpy as hp\n    >>> import numpy as np\n    >>> nside = 2\n    >>> hp.ringinfo(nside, np.arange(4*nside-1))\n    (array([ 0,  0,  4, 12, 20, 28, 36]), array([0, 4, 8, 8, 8, 8, 8]), array([ 1.        ,  0.91666667,  0.66666667,  0.33333333,  0.        ,\n           -0.33333333, -0.66666667]), array([ 0.        ,  0.39965263,  0.74535599,  0.94280904,  1.        ,\n            0.94280904,  0.74535599]), array([ True,  True,  True, False,  True, False,  True], dtype=bool))\n    ";
-static PyMethodDef __pyx_mdef_6healpy_10_pixelfunc_1ringinfo = {__Pyx_NAMESTR("ringinfo"), (PyCFunction)__pyx_pw_6healpy_10_pixelfunc_1ringinfo, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_10_pixelfunc_ringinfo)};
-static PyObject *__pyx_pw_6healpy_10_pixelfunc_1ringinfo(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_int_15;
+static PyObject *__pyx_k_1;
+static PyObject *__pyx_k_2;
+static PyObject *__pyx_k_5;
+static PyObject *__pyx_k_6;
+static PyObject *__pyx_k_8;
+static PyObject *__pyx_k_9;
+static PyObject *__pyx_k_tuple_4;
+static PyObject *__pyx_k_tuple_7;
+static PyObject *__pyx_k_tuple_10;
+static PyObject *__pyx_k_tuple_12;
+static PyObject *__pyx_k_tuple_14;
+static PyObject *__pyx_k_tuple_16;
+static PyObject *__pyx_k_tuple_19;
+static PyObject *__pyx_k_tuple_20;
+static PyObject *__pyx_k_tuple_22;
+
+/* "healpy/src/_query_disc.pyx":102
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def query_disc(nside, vec, radius, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """Returns pixels whose centers lie within the disk defined by
+ *     *vec* and *radius* (in radians) (if *inclusive* is False), or which
+ */
+
+static PyObject *__pyx_pf_6healpy_11_query_disc_query_disc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_11_query_disc_query_disc[] = "query_disc(nside, vec, radius, inclusive=False, nest=False)\nReturns pixels whose centers lie within the disk defined by\n    *vec* and *radius* (in radians) (if *inclusive* is False), or which\n    overlap with this disk (if *inclusive* is True).\n\n    Parameters\n    ----------\n    nside : int\n      The nside of the Healpix map.\n    vec : float, sequence of 3 elements\n      The coordinates of unit vector defining the disk center.\n    radius : float\n      The radius (in radians) of the disk\n    inclusive : bool\n      If False, return the exact set of pixels whose pixel centers lie \n      within the disk; if True, return all pixels that overlap with the disk,\n      and maybe a few more.\n    nest: bool, optional\n      if True, assume NESTED pixel ordering, otherwise, RING pixel ordering\n\n    Returns\n    -------\n    ipix : int, array\n      The pixels which lie within the given disk.\n\n    Note\n    ----\n    This method is more efficient in the RING scheme, but the algorithm\n    used for inclusive==True returns fewer false positives in the NEST scheme.\n    ";
+static PyMethodDef __pyx_mdef_6healpy_11_query_disc_query_disc = {__Pyx_NAMESTR("query_disc"), (PyCFunction)__pyx_pf_6healpy_11_query_disc_query_disc, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_11_query_disc_query_disc)};
+static PyObject *__pyx_pf_6healpy_11_query_disc_query_disc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_nside = 0;
-  PyArrayObject *__pyx_v_ring = 0;
+  PyObject *__pyx_v_vec = 0;
+  PyObject *__pyx_v_radius = 0;
+  PyObject *__pyx_v_inclusive = 0;
+  PyObject *__pyx_v_nest = 0;
+  vec3 __pyx_v_v;
+  enum Healpix_Ordering_Scheme __pyx_v_scheme;
+  T_Healpix_Base<int64> __pyx_v_hb;
+  rangeset<int64> __pyx_v_pixset;
+  bool __pyx_v_inc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  double __pyx_t_4;
+  double __pyx_t_5;
+  double __pyx_t_6;
+  int64 __pyx_t_7;
+  bool __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("ringinfo (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nside,&__pyx_n_s__vec,&__pyx_n_s__radius,&__pyx_n_s__inclusive,&__pyx_n_s__nest,0};
+  __Pyx_RefNannySetupContext("query_disc");
+  __pyx_self = __pyx_self;
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_nside,&__pyx_n_s_ring,0};
-    PyObject* values[2] = {0,0};
+    PyObject* values[5] = {0,0,0,0,0};
+    values[3] = __pyx_k_1;
+    values[4] = __pyx_k_2;
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nside)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nside);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ring)) != 0)) kw_args--;
+        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__vec);
+        if (likely(values[1])) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("query_disc", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  2:
+        values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__radius);
+        if (likely(values[2])) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("ringinfo", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+          __Pyx_RaiseArgtupleInvalid("query_disc", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  3:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__inclusive);
+          if (value) { values[3] = value; kw_args--; }
+        }
+        case  4:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nest);
+          if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ringinfo") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "query_disc") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
     }
     __pyx_v_nside = values[0];
-    __pyx_v_ring = ((PyArrayObject *)values[1]);
+    __pyx_v_vec = values[1];
+    __pyx_v_radius = values[2];
+    __pyx_v_inclusive = values[3];
+    __pyx_v_nest = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("ringinfo", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("query_disc", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._pixelfunc.ringinfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._query_disc.query_disc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ring), __pyx_ptype_5numpy_ndarray, 0, "ring", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_r = __pyx_pf_6healpy_10_pixelfunc_ringinfo(__pyx_self, __pyx_v_nside, __pyx_v_ring);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
 
-static PyObject *__pyx_pf_6healpy_10_pixelfunc_ringinfo(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nside, PyArrayObject *__pyx_v_ring) {
-  enum Healpix_Ordering_Scheme __pyx_v_scheme;
-  T_Healpix_Base<int64> __pyx_v_hb;
-  npy_intp __pyx_v_num;
-  PyArrayObject *__pyx_v_startpix = 0;
-  PyArrayObject *__pyx_v_ringpix = 0;
-  PyArrayObject *__pyx_v_costheta = 0;
-  PyArrayObject *__pyx_v_sintheta = 0;
-  PyArrayObject *__pyx_v_shifted = 0;
-  npy_intp __pyx_v_i;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_costheta;
-  __Pyx_Buffer __pyx_pybuffer_costheta;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ring;
-  __Pyx_Buffer __pyx_pybuffer_ring;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ringpix;
-  __Pyx_Buffer __pyx_pybuffer_ringpix;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_shifted;
-  __Pyx_Buffer __pyx_pybuffer_shifted;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_sintheta;
-  __Pyx_Buffer __pyx_pybuffer_sintheta;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_startpix;
-  __Pyx_Buffer __pyx_pybuffer_startpix;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  int64 __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyArrayObject *__pyx_t_9 = NULL;
-  PyArrayObject *__pyx_t_10 = NULL;
-  PyArrayObject *__pyx_t_11 = NULL;
-  PyArrayObject *__pyx_t_12 = NULL;
-  PyArrayObject *__pyx_t_13 = NULL;
-  npy_intp __pyx_t_14;
-  npy_intp __pyx_t_15;
-  npy_intp __pyx_t_16;
-  npy_intp __pyx_t_17;
-  npy_intp __pyx_t_18;
-  npy_intp __pyx_t_19;
-  npy_intp __pyx_t_20;
-  npy_intp __pyx_t_21;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ringinfo", 0);
-  __pyx_pybuffer_startpix.pybuffer.buf = NULL;
-  __pyx_pybuffer_startpix.refcount = 0;
-  __pyx_pybuffernd_startpix.data = NULL;
-  __pyx_pybuffernd_startpix.rcbuffer = &__pyx_pybuffer_startpix;
-  __pyx_pybuffer_ringpix.pybuffer.buf = NULL;
-  __pyx_pybuffer_ringpix.refcount = 0;
-  __pyx_pybuffernd_ringpix.data = NULL;
-  __pyx_pybuffernd_ringpix.rcbuffer = &__pyx_pybuffer_ringpix;
-  __pyx_pybuffer_costheta.pybuffer.buf = NULL;
-  __pyx_pybuffer_costheta.refcount = 0;
-  __pyx_pybuffernd_costheta.data = NULL;
-  __pyx_pybuffernd_costheta.rcbuffer = &__pyx_pybuffer_costheta;
-  __pyx_pybuffer_sintheta.pybuffer.buf = NULL;
-  __pyx_pybuffer_sintheta.refcount = 0;
-  __pyx_pybuffernd_sintheta.data = NULL;
-  __pyx_pybuffernd_sintheta.rcbuffer = &__pyx_pybuffer_sintheta;
-  __pyx_pybuffer_shifted.pybuffer.buf = NULL;
-  __pyx_pybuffer_shifted.refcount = 0;
-  __pyx_pybuffernd_shifted.data = NULL;
-  __pyx_pybuffernd_shifted.rcbuffer = &__pyx_pybuffer_shifted;
-  __pyx_pybuffer_ring.pybuffer.buf = NULL;
-  __pyx_pybuffer_ring.refcount = 0;
-  __pyx_pybuffernd_ring.data = NULL;
-  __pyx_pybuffernd_ring.rcbuffer = &__pyx_pybuffer_ring;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ring.rcbuffer->pybuffer, (PyObject*)__pyx_v_ring, &__Pyx_TypeInfo_nn_int64, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_pybuffernd_ring.diminfo[0].strides = __pyx_pybuffernd_ring.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ring.diminfo[0].shape = __pyx_pybuffernd_ring.rcbuffer->pybuffer.shape[0];
-
-  /* "healpy/src/_pixelfunc.pyx":44
- *             0.94280904,  0.74535599]), array([ True,  True,  True, False,  True, False,  True], dtype=bool))
+  /* "healpy/src/_query_disc.pyx":133
  *     """
+ *     # Check Nside value
  *     if not isnsideok(nside):             # <<<<<<<<<<<<<<
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')
- *     cdef Healpix_Ordering_Scheme scheme = NEST
+ *         raise ValueError('Wrong nside value, must be a power of 2')
+ *     cdef vec3 v = vec3(vec[0], vec[1], vec[2])
  */
-  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_nside); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_2 = ((!(__pyx_f_6healpy_10_pixelfunc_isnsideok(__pyx_t_1) != 0)) != 0);
+  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_nside); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = (!__pyx_f_6healpy_11_query_disc_isnsideok(__pyx_t_1));
   if (__pyx_t_2) {
 
-    /* "healpy/src/_pixelfunc.pyx":45
- *     """
+    /* "healpy/src/_query_disc.pyx":134
+ *     # Check Nside value
  *     if not isnsideok(nside):
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')             # <<<<<<<<<<<<<<
- *     cdef Healpix_Ordering_Scheme scheme = NEST
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     cdef vec3 v = vec3(vec[0], vec[1], vec[2])
+ *     cdef Healpix_Ordering_Scheme scheme
  */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
   }
+  __pyx_L6:;
 
-  /* "healpy/src/_pixelfunc.pyx":46
+  /* "healpy/src/_query_disc.pyx":135
  *     if not isnsideok(nside):
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')
- *     cdef Healpix_Ordering_Scheme scheme = NEST             # <<<<<<<<<<<<<<
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = ring.shape[0]
- */
-  __pyx_v_scheme = NEST;
-
-  /* "healpy/src/_pixelfunc.pyx":47
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')
- *     cdef Healpix_Ordering_Scheme scheme = NEST
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)             # <<<<<<<<<<<<<<
- *     num = ring.shape[0]
- *     cdef np.ndarray[int64, ndim=1] startpix = np.empty(num, dtype=np.int64)
- */
-  __pyx_t_4 = __Pyx_PyInt_As_int64(__pyx_v_nside); if (unlikely((__pyx_t_4 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_hb = T_Healpix_Base<int64>(__pyx_t_4, __pyx_v_scheme, SET_NSIDE);
-
-  /* "healpy/src/_pixelfunc.pyx":48
- *     cdef Healpix_Ordering_Scheme scheme = NEST
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = ring.shape[0]             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[int64, ndim=1] startpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[int64, ndim=1] ringpix = np.empty(num, dtype=np.int64)
- */
-  __pyx_v_num = (__pyx_v_ring->dimensions[0]);
-
-  /* "healpy/src/_pixelfunc.pyx":49
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = ring.shape[0]
- *     cdef np.ndarray[int64, ndim=1] startpix = np.empty(num, dtype=np.int64)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[int64, ndim=1] ringpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[double, ndim=1] costheta = np.empty(num, dtype=np.float)
+ *         raise ValueError('Wrong nside value, must be a power of 2')
+ *     cdef vec3 v = vec3(vec[0], vec[1], vec[2])             # <<<<<<<<<<<<<<
+ *     cdef Healpix_Ordering_Scheme scheme
+ *     if nest:
  */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_vec, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_3);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int64); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_8 = PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_3); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_4 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_8) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_8, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_9 = ((PyArrayObject *)__pyx_t_8);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_startpix.rcbuffer->pybuffer, (PyObject*)__pyx_t_9, &__Pyx_TypeInfo_nn_int64, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_startpix = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_startpix.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_startpix.diminfo[0].strides = __pyx_pybuffernd_startpix.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_startpix.diminfo[0].shape = __pyx_pybuffernd_startpix.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_9 = 0;
-  __pyx_v_startpix = ((PyArrayObject *)__pyx_t_8);
-  __pyx_t_8 = 0;
-
-  /* "healpy/src/_pixelfunc.pyx":50
- *     num = ring.shape[0]
- *     cdef np.ndarray[int64, ndim=1] startpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[int64, ndim=1] ringpix = np.empty(num, dtype=np.int64)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[double, ndim=1] costheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[double, ndim=1] sintheta = np.empty(num, dtype=np.float)
- */
-  __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_empty); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_vec, 1, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_8 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_8);
-  __pyx_t_8 = 0;
-  __pyx_t_8 = PyDict_New(); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_int64); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_dtype, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = PyObject_Call(__pyx_t_3, __pyx_t_6, __pyx_t_8); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (!(likely(((__pyx_t_7) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_7, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_10 = ((PyArrayObject *)__pyx_t_7);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ringpix.rcbuffer->pybuffer, (PyObject*)__pyx_t_10, &__Pyx_TypeInfo_nn_int64, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_ringpix = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_ringpix.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_ringpix.diminfo[0].strides = __pyx_pybuffernd_ringpix.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ringpix.diminfo[0].shape = __pyx_pybuffernd_ringpix.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_10 = 0;
-  __pyx_v_ringpix = ((PyArrayObject *)__pyx_t_7);
-  __pyx_t_7 = 0;
-
-  /* "healpy/src/_pixelfunc.pyx":51
- *     cdef np.ndarray[int64, ndim=1] startpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[int64, ndim=1] ringpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[double, ndim=1] costheta = np.empty(num, dtype=np.float)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[double, ndim=1] sintheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[bool, ndim=1, cast=True] shifted = np.empty(num, dtype=np.bool)
- */
-  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_empty); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
-  __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_vec, 2, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_float); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_dtype, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = PyObject_Call(__pyx_t_8, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_11 = ((PyArrayObject *)__pyx_t_5);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_costheta.rcbuffer->pybuffer, (PyObject*)__pyx_t_11, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_costheta = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_costheta.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_costheta.diminfo[0].strides = __pyx_pybuffernd_costheta.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_costheta.diminfo[0].shape = __pyx_pybuffernd_costheta.rcbuffer->pybuffer.shape[0];
-    }
+  __pyx_v_v = vec3(__pyx_t_4, __pyx_t_5, __pyx_t_6);
+
+  /* "healpy/src/_query_disc.pyx":137
+ *     cdef vec3 v = vec3(vec[0], vec[1], vec[2])
+ *     cdef Healpix_Ordering_Scheme scheme
+ *     if nest:             # <<<<<<<<<<<<<<
+ *         scheme = NEST
+ *     else:
+ */
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_nest); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_2) {
+
+    /* "healpy/src/_query_disc.pyx":138
+ *     cdef Healpix_Ordering_Scheme scheme
+ *     if nest:
+ *         scheme = NEST             # <<<<<<<<<<<<<<
+ *     else:
+ *         scheme = RING
+ */
+    __pyx_v_scheme = NEST;
+    goto __pyx_L7;
   }
-  __pyx_t_11 = 0;
-  __pyx_v_costheta = ((PyArrayObject *)__pyx_t_5);
-  __pyx_t_5 = 0;
+  /*else*/ {
 
-  /* "healpy/src/_pixelfunc.pyx":52
- *     cdef np.ndarray[int64, ndim=1] ringpix = np.empty(num, dtype=np.int64)
- *     cdef np.ndarray[double, ndim=1] costheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[double, ndim=1] sintheta = np.empty(num, dtype=np.float)             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[bool, ndim=1, cast=True] shifted = np.empty(num, dtype=np.bool)
- *     for i in range(num):
+    /* "healpy/src/_query_disc.pyx":140
+ *         scheme = NEST
+ *     else:
+ *         scheme = RING             # <<<<<<<<<<<<<<
+ *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
+ *     cdef rangeset[int64] pixset
  */
-  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_empty); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_5);
-  __pyx_t_5 = 0;
-  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_float); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyObject_Call(__pyx_t_7, __pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_12 = ((PyArrayObject *)__pyx_t_3);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_sintheta.rcbuffer->pybuffer, (PyObject*)__pyx_t_12, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_sintheta = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_sintheta.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_sintheta.diminfo[0].strides = __pyx_pybuffernd_sintheta.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_sintheta.diminfo[0].shape = __pyx_pybuffernd_sintheta.rcbuffer->pybuffer.shape[0];
-    }
+    __pyx_v_scheme = RING;
   }
-  __pyx_t_12 = 0;
-  __pyx_v_sintheta = ((PyArrayObject *)__pyx_t_3);
-  __pyx_t_3 = 0;
+  __pyx_L7:;
 
-  /* "healpy/src/_pixelfunc.pyx":53
- *     cdef np.ndarray[double, ndim=1] costheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[double, ndim=1] sintheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[bool, ndim=1, cast=True] shifted = np.empty(num, dtype=np.bool)             # <<<<<<<<<<<<<<
- *     for i in range(num):
- *         hb.get_ring_info(ring[i], startpix[i], ringpix[i], costheta[i], sintheta[i], shifted[i])
+  /* "healpy/src/_query_disc.pyx":141
+ *     else:
+ *         scheme = RING
+ *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)             # <<<<<<<<<<<<<<
+ *     cdef rangeset[int64] pixset
+ *     cdef bool inc = inclusive
  */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_3);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_bool); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_8 = PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_3); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_8) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_8, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = ((PyArrayObject *)__pyx_t_8);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_shifted.rcbuffer->pybuffer, (PyObject*)__pyx_t_13, &__Pyx_TypeInfo_nn_bool, PyBUF_FORMAT| PyBUF_STRIDES, 1, 1, __pyx_stack) == -1)) {
-      __pyx_v_shifted = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_shifted.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_shifted.diminfo[0].strides = __pyx_pybuffernd_shifted.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_shifted.diminfo[0].shape = __pyx_pybuffernd_shifted.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_13 = 0;
-  __pyx_v_shifted = ((PyArrayObject *)__pyx_t_8);
-  __pyx_t_8 = 0;
-
-  /* "healpy/src/_pixelfunc.pyx":54
- *     cdef np.ndarray[double, ndim=1] sintheta = np.empty(num, dtype=np.float)
- *     cdef np.ndarray[bool, ndim=1, cast=True] shifted = np.empty(num, dtype=np.bool)
- *     for i in range(num):             # <<<<<<<<<<<<<<
- *         hb.get_ring_info(ring[i], startpix[i], ringpix[i], costheta[i], sintheta[i], shifted[i])
- *     return startpix, ringpix, costheta, sintheta, shifted
- */
-  __pyx_t_14 = __pyx_v_num;
-  for (__pyx_t_15 = 0; __pyx_t_15 < __pyx_t_14; __pyx_t_15+=1) {
-    __pyx_v_i = __pyx_t_15;
-
-    /* "healpy/src/_pixelfunc.pyx":55
- *     cdef np.ndarray[bool, ndim=1, cast=True] shifted = np.empty(num, dtype=np.bool)
- *     for i in range(num):
- *         hb.get_ring_info(ring[i], startpix[i], ringpix[i], costheta[i], sintheta[i], shifted[i])             # <<<<<<<<<<<<<<
- *     return startpix, ringpix, costheta, sintheta, shifted
- * 
- */
-    __pyx_t_16 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_16 < 0) {
-      __pyx_t_16 += __pyx_pybuffernd_ring.diminfo[0].shape;
-      if (unlikely(__pyx_t_16 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_16 >= __pyx_pybuffernd_ring.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_17 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_17 < 0) {
-      __pyx_t_17 += __pyx_pybuffernd_startpix.diminfo[0].shape;
-      if (unlikely(__pyx_t_17 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_17 >= __pyx_pybuffernd_startpix.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_18 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_18 < 0) {
-      __pyx_t_18 += __pyx_pybuffernd_ringpix.diminfo[0].shape;
-      if (unlikely(__pyx_t_18 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_18 >= __pyx_pybuffernd_ringpix.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_19 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_19 < 0) {
-      __pyx_t_19 += __pyx_pybuffernd_costheta.diminfo[0].shape;
-      if (unlikely(__pyx_t_19 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_19 >= __pyx_pybuffernd_costheta.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_20 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_20 < 0) {
-      __pyx_t_20 += __pyx_pybuffernd_sintheta.diminfo[0].shape;
-      if (unlikely(__pyx_t_20 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_20 >= __pyx_pybuffernd_sintheta.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_21 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_21 < 0) {
-      __pyx_t_21 += __pyx_pybuffernd_shifted.diminfo[0].shape;
-      if (unlikely(__pyx_t_21 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_21 >= __pyx_pybuffernd_shifted.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_v_hb.get_ring_info((*__Pyx_BufPtrStrided1d(int64 *, __pyx_pybuffernd_ring.rcbuffer->pybuffer.buf, __pyx_t_16, __pyx_pybuffernd_ring.diminfo[0].strides)), (*__Pyx_BufPtrStrided1d(int64 *, __pyx_pybuffernd_startpix.rcbuffer->pybuffer.buf, __pyx_t_17, __pyx_pybuffernd_startpix.diminfo[0].strides)), (*__Pyx_BufPtrStrided1d(int64 *, __pyx_pybuffernd_ringpix.rcbuffer->pybuffer.buf, __pyx_t_18, __pyx_pybuffernd_ringpix.diminfo[0].strides)), (*__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_costheta.rcbuffer->pybuffer.buf, __pyx_t_19, __pyx_pybuffernd_costheta.diminfo[0].strides)), (*__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_sintheta.rcbuffer->pybuffer.buf, __pyx_t_20, __pyx_pybuffernd_sintheta.diminfo[0].strides)), (*__Pyx_BufPtrStrided1d(bool *, __pyx_pybuffernd_shifted.rcbuffer->pybuffer.buf, __pyx_t_21, __pyx_pybuffernd_shifted.diminfo[0].strides)));
-  }
-
-  /* "healpy/src/_pixelfunc.pyx":56
- *     for i in range(num):
- *         hb.get_ring_info(ring[i], startpix[i], ringpix[i], costheta[i], sintheta[i], shifted[i])
- *     return startpix, ringpix, costheta, sintheta, shifted             # <<<<<<<<<<<<<<
+  __pyx_t_7 = __Pyx_PyInt_from_py_int64(__pyx_v_nside); if (unlikely((__pyx_t_7 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_hb = T_Healpix_Base<int64>(__pyx_t_7, __pyx_v_scheme, SET_NSIDE);
+
+  /* "healpy/src/_query_disc.pyx":143
+ *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
+ *     cdef rangeset[int64] pixset
+ *     cdef bool inc = inclusive             # <<<<<<<<<<<<<<
+ *     hb.query_disc(pointing(v), radius, inc, pixset)
  * 
- * def pix2ring(nside, np.ndarray[int64, ndim=1] pix not None, nest=False):
  */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_8 = PyTuple_New(5); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_INCREF(((PyObject *)__pyx_v_startpix));
-  PyTuple_SET_ITEM(__pyx_t_8, 0, ((PyObject *)__pyx_v_startpix));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_startpix));
-  __Pyx_INCREF(((PyObject *)__pyx_v_ringpix));
-  PyTuple_SET_ITEM(__pyx_t_8, 1, ((PyObject *)__pyx_v_ringpix));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_ringpix));
-  __Pyx_INCREF(((PyObject *)__pyx_v_costheta));
-  PyTuple_SET_ITEM(__pyx_t_8, 2, ((PyObject *)__pyx_v_costheta));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_costheta));
-  __Pyx_INCREF(((PyObject *)__pyx_v_sintheta));
-  PyTuple_SET_ITEM(__pyx_t_8, 3, ((PyObject *)__pyx_v_sintheta));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_sintheta));
-  __Pyx_INCREF(((PyObject *)__pyx_v_shifted));
-  PyTuple_SET_ITEM(__pyx_t_8, 4, ((PyObject *)__pyx_v_shifted));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_shifted));
-  __pyx_r = __pyx_t_8;
-  __pyx_t_8 = 0;
-  goto __pyx_L0;
+  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_inclusive); if (unlikely((__pyx_t_8 == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_inc = __pyx_t_8;
 
-  /* "healpy/src/_pixelfunc.pyx":9
- * from _common cimport int64, Healpix_Ordering_Scheme, RING, NEST, SET_NSIDE, T_Healpix_Base
+  /* "healpy/src/_query_disc.pyx":144
+ *     cdef rangeset[int64] pixset
+ *     cdef bool inc = inclusive
+ *     hb.query_disc(pointing(v), radius, inc, pixset)             # <<<<<<<<<<<<<<
+ * 
+ *     return pixset_to_array(pixset)
+ */
+  __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_v_radius); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_hb.query_disc(pointing(__pyx_v_v), __pyx_t_6, __pyx_v_inc, ((rangeset<int64> &)__pyx_v_pixset));
+
+  /* "healpy/src/_query_disc.pyx":146
+ *     hb.query_disc(pointing(v), radius, inc, pixset)
+ * 
+ *     return pixset_to_array(pixset)             # <<<<<<<<<<<<<<
  * 
- * def ringinfo(nside, np.ndarray[int64, ndim=1] ring not None):             # <<<<<<<<<<<<<<
- *     """Get information for rings
  * 
  */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = __pyx_f_6healpy_11_query_disc_pixset_to_array(__pyx_v_pixset); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
 
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_costheta.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ring.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ringpix.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_shifted.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_sintheta.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_startpix.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("healpy._pixelfunc.ringinfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._query_disc.query_disc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_costheta.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ring.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ringpix.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_shifted.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_sintheta.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_startpix.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_startpix);
-  __Pyx_XDECREF((PyObject *)__pyx_v_ringpix);
-  __Pyx_XDECREF((PyObject *)__pyx_v_costheta);
-  __Pyx_XDECREF((PyObject *)__pyx_v_sintheta);
-  __Pyx_XDECREF((PyObject *)__pyx_v_shifted);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_pixelfunc.pyx":58
- *     return startpix, ringpix, costheta, sintheta, shifted
+/* "healpy/src/_query_disc.pyx":149
  * 
- * def pix2ring(nside, np.ndarray[int64, ndim=1] pix not None, nest=False):             # <<<<<<<<<<<<<<
- *     """Convert pixel identifier to ring number
  * 
+ * def query_polygon(nside, vertices, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """ Returns the pixels whose centers lie within the convex polygon
+ *     defined by the *vertices* array (if *inclusive* is False), or which
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_10_pixelfunc_3pix2ring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_10_pixelfunc_2pix2ring[] = "Convert pixel identifier to ring number\n\n    Rings are specified by a positive integer, 1 <= ring <= 4*nside-1.\n\n    Parameters\n    ----------\n    nside : int\n      The healpix nside parameter, must be a power of 2, less than 2**30\n    pix : int64, scalar or array-like\n      The pixel identifier(s)\n    nest : bool\n      Is *pix* specified in the NEST ordering scheme?\n\n    Returns\n    -------\n    ring : int, length equal to that of *pix*\n      Ring number\n\n    Example\n    -------\n    >>> import healpy as hp\n    >>> import numpy as np\n    >>> nside = 2\n    >>> hp.pix2ring(nside, np.arange(hp.nside2npix(nside)))\n    array([1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,\n           4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,\n           7, 7])\n    ";
-static PyMethodDef __pyx_mdef_6healpy_10_pixelfunc_3pix2ring = {__Pyx_NAMESTR("pix2ring"), (PyCFunction)__pyx_pw_6healpy_10_pixelfunc_3pix2ring, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_10_pixelfunc_2pix2ring)};
-static PyObject *__pyx_pw_6healpy_10_pixelfunc_3pix2ring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pf_6healpy_11_query_disc_1query_polygon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_11_query_disc_1query_polygon[] = "query_polygon(nside, vertices, inclusive=False, nest=False)\n Returns the pixels whose centers lie within the convex polygon \n    defined by the *vertices* array (if *inclusive* is False), or which \n    overlap with this polygon (if *inclusive* is True).\n\n    Parameters\n    ----------\n    nside : int\n      The nside of the Healpix map.\n    vertices : float, array-like\n      Vertex array containing the vertices of the polygon, shape (N, 3).\n    inclusive : bool\n      If False, return the exact set of pixels whose pixel centers lie\n      within the polygon; if True, return all pixels that overlap with the\n      polygon, and maybe a few more.\n    nest: bool, optional\n      if True, assume NESTED pixel ordering, otherwise, RING pixel ordering\n    \n    Returns\n    -------\n    ipix : int, array\n      The pixels which lie within the given polygon.\n\n    Note\n    ----\n    This method is more efficient in the RING scheme, but the algorithm used\n    for inclusive==True returns fewer false positives in the NEST scheme.\n    ";
+static PyMethodDef __pyx_mdef_6healpy_11_query_disc_1query_polygon = {__Pyx_NAMESTR("query_polygon"), (PyCFunction)__pyx_pf_6healpy_11_query_disc_1query_polygon, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_11_query_disc_1query_polygon)};
+static PyObject *__pyx_pf_6healpy_11_query_disc_1query_polygon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_nside = 0;
-  PyArrayObject *__pyx_v_pix = 0;
+  PyObject *__pyx_v_vertices = 0;
+  PyObject *__pyx_v_inclusive = 0;
   PyObject *__pyx_v_nest = 0;
+  std::vector<pointing> __pyx_v_vert;
+  PyObject *__pyx_v_v = NULL;
+  enum Healpix_Ordering_Scheme __pyx_v_scheme;
+  T_Healpix_Base<int64> __pyx_v_hb;
+  rangeset<int64> __pyx_v_pixset;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t __pyx_t_4;
+  PyObject *(*__pyx_t_5)(PyObject *);
+  PyObject *__pyx_t_6 = NULL;
+  double __pyx_t_7;
+  double __pyx_t_8;
+  double __pyx_t_9;
+  int64 __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("pix2ring (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nside,&__pyx_n_s__vertices,&__pyx_n_s__inclusive,&__pyx_n_s__nest,0};
+  __Pyx_RefNannySetupContext("query_polygon");
+  __pyx_self = __pyx_self;
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_nside,&__pyx_n_s_pix,&__pyx_n_s_nest,0};
-    PyObject* values[3] = {0,0,0};
-    values[2] = ((PyObject *)Py_False);
+    PyObject* values[4] = {0,0,0,0};
+    values[2] = __pyx_k_5;
+    values[3] = __pyx_k_6;
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nside)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nside);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pix)) != 0)) kw_args--;
+        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__vertices);
+        if (likely(values[1])) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("pix2ring", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+          __Pyx_RaiseArgtupleInvalid("query_polygon", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
         }
         case  2:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nest);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__inclusive);
           if (value) { values[2] = value; kw_args--; }
         }
+        case  3:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nest);
+          if (value) { values[3] = value; kw_args--; }
+        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pix2ring") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "query_polygon") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_nside = values[0];
-    __pyx_v_pix = ((PyArrayObject *)values[1]);
-    __pyx_v_nest = values[2];
+    __pyx_v_vertices = values[1];
+    __pyx_v_inclusive = values[2];
+    __pyx_v_nest = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("pix2ring", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("query_polygon", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._pixelfunc.pix2ring", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._query_disc.query_polygon", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_pix), __pyx_ptype_5numpy_ndarray, 0, "pix", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_r = __pyx_pf_6healpy_10_pixelfunc_2pix2ring(__pyx_self, __pyx_v_nside, __pyx_v_pix, __pyx_v_nest);
 
-  /* function exit code */
+  /* "healpy/src/_query_disc.pyx":178
+ *     """
+ *     # Check Nside value
+ *     if not isnsideok(nside):             # <<<<<<<<<<<<<<
+ *         raise ValueError('Wrong nside value, must be a power of 2')
+ *     # Create vector of vertices
+ */
+  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_nside); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = (!__pyx_f_6healpy_11_query_disc_isnsideok(__pyx_t_1));
+  if (__pyx_t_2) {
+
+    /* "healpy/src/_query_disc.pyx":179
+ *     # Check Nside value
+ *     if not isnsideok(nside):
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     # Create vector of vertices
+ *     cdef vector[pointing] vert
+ */
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "healpy/src/_query_disc.pyx":182
+ *     # Create vector of vertices
+ *     cdef vector[pointing] vert
+ *     for v in vertices:             # <<<<<<<<<<<<<<
+ *         vert.push_back(pointing(vec3(v[0], v[1], v[2])))
+ *     # Create the Healpix_Base2 structure
+ */
+  if (PyList_CheckExact(__pyx_v_vertices) || PyTuple_CheckExact(__pyx_v_vertices)) {
+    __pyx_t_3 = __pyx_v_vertices; __Pyx_INCREF(__pyx_t_3); __pyx_t_4 = 0;
+    __pyx_t_5 = NULL;
+  } else {
+    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_vertices); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = Py_TYPE(__pyx_t_3)->tp_iternext;
+  }
+  for (;;) {
+    if (PyList_CheckExact(__pyx_t_3)) {
+      if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
+      __pyx_t_6 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_6); __pyx_t_4++;
+    } else if (PyTuple_CheckExact(__pyx_t_3)) {
+      if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
+      __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_6); __pyx_t_4++;
+    } else {
+      __pyx_t_6 = __pyx_t_5(__pyx_t_3);
+      if (unlikely(!__pyx_t_6)) {
+        if (PyErr_Occurred()) {
+          if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) PyErr_Clear();
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_6);
+    }
+    __Pyx_XDECREF(__pyx_v_v);
+    __pyx_v_v = __pyx_t_6;
+    __pyx_t_6 = 0;
+
+    /* "healpy/src/_query_disc.pyx":183
+ *     cdef vector[pointing] vert
+ *     for v in vertices:
+ *         vert.push_back(pointing(vec3(v[0], v[1], v[2])))             # <<<<<<<<<<<<<<
+ *     # Create the Healpix_Base2 structure
+ *     cdef Healpix_Ordering_Scheme scheme
+ */
+    __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_v, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_6) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_6); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_v, 1, sizeof(long), PyInt_FromLong); if (!__pyx_t_6) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = __pyx_PyFloat_AsDouble(__pyx_t_6); if (unlikely((__pyx_t_8 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_v, 2, sizeof(long), PyInt_FromLong); if (!__pyx_t_6) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_6); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_v_vert.push_back(pointing(vec3(__pyx_t_7, __pyx_t_8, __pyx_t_9)));
+  }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "healpy/src/_query_disc.pyx":186
+ *     # Create the Healpix_Base2 structure
+ *     cdef Healpix_Ordering_Scheme scheme
+ *     if nest:             # <<<<<<<<<<<<<<
+ *         scheme = NEST
+ *     else:
+ */
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_nest); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_2) {
+
+    /* "healpy/src/_query_disc.pyx":187
+ *     cdef Healpix_Ordering_Scheme scheme
+ *     if nest:
+ *         scheme = NEST             # <<<<<<<<<<<<<<
+ *     else:
+ *         scheme = RING
+ */
+    __pyx_v_scheme = NEST;
+    goto __pyx_L9;
+  }
+  /*else*/ {
+
+    /* "healpy/src/_query_disc.pyx":189
+ *         scheme = NEST
+ *     else:
+ *         scheme = RING             # <<<<<<<<<<<<<<
+ *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
+ *     # Call query_polygon
+ */
+    __pyx_v_scheme = RING;
+  }
+  __pyx_L9:;
+
+  /* "healpy/src/_query_disc.pyx":190
+ *     else:
+ *         scheme = RING
+ *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)             # <<<<<<<<<<<<<<
+ *     # Call query_polygon
+ *     cdef rangeset[int64] pixset
+ */
+  __pyx_t_10 = __Pyx_PyInt_from_py_int64(__pyx_v_nside); if (unlikely((__pyx_t_10 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_hb = T_Healpix_Base<int64>(__pyx_t_10, __pyx_v_scheme, SET_NSIDE);
+
+  /* "healpy/src/_query_disc.pyx":193
+ *     # Call query_polygon
+ *     cdef rangeset[int64] pixset
+ *     hb.query_polygon(vert, inclusive, pixset)             # <<<<<<<<<<<<<<
+ * 
+ *     return pixset_to_array(pixset)
+ */
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_inclusive); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_hb.query_polygon(((std::vector<pointing>)__pyx_v_vert), __pyx_t_2, ((rangeset<int64> &)__pyx_v_pixset));
+
+  /* "healpy/src/_query_disc.pyx":195
+ *     hb.query_polygon(vert, inclusive, pixset)
+ * 
+ *     return pixset_to_array(pixset)             # <<<<<<<<<<<<<<
+ * 
+ * def query_strip(nside, theta1, theta2, inclusive = False, nest = False):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = __pyx_f_6healpy_11_query_disc_pixset_to_array(__pyx_v_pixset); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("healpy._query_disc.query_polygon", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_v);
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_6healpy_10_pixelfunc_2pix2ring(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nside, PyArrayObject *__pyx_v_pix, PyObject *__pyx_v_nest) {
+/* "healpy/src/_query_disc.pyx":197
+ *     return pixset_to_array(pixset)
+ * 
+ * def query_strip(nside, theta1, theta2, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """Returns pixels whose centers lie within the colatitude range
+ *     defined by *theta1* and *theta2* (if inclusive is False), or which
+ */
+
+static PyObject *__pyx_pf_6healpy_11_query_disc_2query_strip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_11_query_disc_2query_strip[] = "query_strip(nside, theta1, theta2, inclusive=False, nest=False)\nReturns pixels whose centers lie within the colatitude range\n    defined by *theta1* and *theta2* (if inclusive is False), or which \n    overlap with this region (if *inclusive* is True). If theta1<theta2, the\n    region between both angles is considered, otherwise the regions \n    0<theta<theta2 and theta1<theta<pi.\n    \n    Parameters\n    ----------\n    nside : int\n      The nside of the Healpix map.\n    theta1 : float\n      First colatitude\n    theta2 : float\n      Second colatitude\n    inclusive ; bool\n      If False, return the exact set of pixels whose pixels centers lie \n      within the region; if True, return all pixels that overlap with the\n      region.\n    nest: bool, optional\n      if True, assume NESTED pixel ordering, otherwise, RING pixel ordering\n\n    Returns\n    -------\n    ipix : int, array\n      The pixels which lie within the given strip.\n    ";
+static PyMethodDef __pyx_mdef_6healpy_11_query_disc_2query_strip = {__Pyx_NAMESTR("query_strip"), (PyCFunction)__pyx_pf_6healpy_11_query_disc_2query_strip, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_11_query_disc_2query_strip)};
+static PyObject *__pyx_pf_6healpy_11_query_disc_2query_strip(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_nside = 0;
+  PyObject *__pyx_v_theta1 = 0;
+  PyObject *__pyx_v_theta2 = 0;
+  PyObject *__pyx_v_inclusive = 0;
+  PyObject *__pyx_v_nest = 0;
   enum Healpix_Ordering_Scheme __pyx_v_scheme;
   T_Healpix_Base<int64> __pyx_v_hb;
-  npy_intp __pyx_v_num;
-  PyArrayObject *__pyx_v_ring = 0;
-  npy_intp __pyx_v_i;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_pix;
-  __Pyx_Buffer __pyx_pybuffer_pix;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_ring;
-  __Pyx_Buffer __pyx_pybuffer_ring;
+  rangeset<int64> __pyx_v_pixset;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int64 __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyArrayObject *__pyx_t_9 = NULL;
-  npy_intp __pyx_t_10;
-  npy_intp __pyx_t_11;
-  npy_intp __pyx_t_12;
-  npy_intp __pyx_t_13;
+  double __pyx_t_5;
+  double __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("pix2ring", 0);
-  __pyx_pybuffer_ring.pybuffer.buf = NULL;
-  __pyx_pybuffer_ring.refcount = 0;
-  __pyx_pybuffernd_ring.data = NULL;
-  __pyx_pybuffernd_ring.rcbuffer = &__pyx_pybuffer_ring;
-  __pyx_pybuffer_pix.pybuffer.buf = NULL;
-  __pyx_pybuffer_pix.refcount = 0;
-  __pyx_pybuffernd_pix.data = NULL;
-  __pyx_pybuffernd_pix.rcbuffer = &__pyx_pybuffer_pix;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nside,&__pyx_n_s__theta1,&__pyx_n_s__theta2,&__pyx_n_s__inclusive,&__pyx_n_s__nest,0};
+  __Pyx_RefNannySetupContext("query_strip");
+  __pyx_self = __pyx_self;
   {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_pix.rcbuffer->pybuffer, (PyObject*)__pyx_v_pix, &__Pyx_TypeInfo_nn_int64, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    PyObject* values[5] = {0,0,0,0,0};
+    values[3] = __pyx_k_8;
+    values[4] = __pyx_k_9;
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  0:
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nside);
+        if (likely(values[0])) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__theta1);
+        if (likely(values[1])) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("query_strip", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  2:
+        values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__theta2);
+        if (likely(values[2])) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("query_strip", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  3:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__inclusive);
+          if (value) { values[3] = value; kw_args--; }
+        }
+        case  4:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nest);
+          if (value) { values[4] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "query_strip") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_nside = values[0];
+    __pyx_v_theta1 = values[1];
+    __pyx_v_theta2 = values[2];
+    __pyx_v_inclusive = values[3];
+    __pyx_v_nest = values[4];
   }
-  __pyx_pybuffernd_pix.diminfo[0].strides = __pyx_pybuffernd_pix.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_pix.diminfo[0].shape = __pyx_pybuffernd_pix.rcbuffer->pybuffer.shape[0];
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("query_strip", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("healpy._query_disc.query_strip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
 
-  /* "healpy/src/_pixelfunc.pyx":88
+  /* "healpy/src/_query_disc.pyx":225
  *     """
- * 
+ *     # Check Nside value
  *     if not isnsideok(nside):             # <<<<<<<<<<<<<<
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')
- *     cdef Healpix_Ordering_Scheme scheme
+ *         raise ValueError('Wrong nside value, must be a power of 2')
+ *     # Create the Healpix_Base2 structure
  */
-  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_nside); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_2 = ((!(__pyx_f_6healpy_10_pixelfunc_isnsideok(__pyx_t_1) != 0)) != 0);
+  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_nside); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = (!__pyx_f_6healpy_11_query_disc_isnsideok(__pyx_t_1));
   if (__pyx_t_2) {
 
-    /* "healpy/src/_pixelfunc.pyx":89
- * 
+    /* "healpy/src/_query_disc.pyx":226
+ *     # Check Nside value
  *     if not isnsideok(nside):
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')             # <<<<<<<<<<<<<<
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     # Create the Healpix_Base2 structure
  *     cdef Healpix_Ordering_Scheme scheme
- *     if nest:
  */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_10), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
   }
+  __pyx_L6:;
 
-  /* "healpy/src/_pixelfunc.pyx":91
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')
+  /* "healpy/src/_query_disc.pyx":229
+ *     # Create the Healpix_Base2 structure
  *     cdef Healpix_Ordering_Scheme scheme
  *     if nest:             # <<<<<<<<<<<<<<
  *         scheme = NEST
  *     else:
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_nest); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_nest); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   if (__pyx_t_2) {
 
-    /* "healpy/src/_pixelfunc.pyx":92
+    /* "healpy/src/_query_disc.pyx":230
  *     cdef Healpix_Ordering_Scheme scheme
  *     if nest:
  *         scheme = NEST             # <<<<<<<<<<<<<<
  *     else:
  *         scheme = RING
  */
     __pyx_v_scheme = NEST;
-    goto __pyx_L4;
+    goto __pyx_L7;
   }
   /*else*/ {
 
-    /* "healpy/src/_pixelfunc.pyx":94
+    /* "healpy/src/_query_disc.pyx":232
  *         scheme = NEST
  *     else:
  *         scheme = RING             # <<<<<<<<<<<<<<
  *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = pix.shape[0]
+ *     # Call query_polygon
  */
     __pyx_v_scheme = RING;
   }
-  __pyx_L4:;
+  __pyx_L7:;
 
-  /* "healpy/src/_pixelfunc.pyx":95
+  /* "healpy/src/_query_disc.pyx":233
  *     else:
  *         scheme = RING
  *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)             # <<<<<<<<<<<<<<
- *     num = pix.shape[0]
- *     cdef np.ndarray[int64, ndim=1] ring = np.empty(num, dtype=np.int64)
+ *     # Call query_polygon
+ *     cdef rangeset[int64] pixset
  */
-  __pyx_t_4 = __Pyx_PyInt_As_int64(__pyx_v_nside); if (unlikely((__pyx_t_4 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = __Pyx_PyInt_from_py_int64(__pyx_v_nside); if (unlikely((__pyx_t_4 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_v_hb = T_Healpix_Base<int64>(__pyx_t_4, __pyx_v_scheme, SET_NSIDE);
 
-  /* "healpy/src/_pixelfunc.pyx":96
- *         scheme = RING
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = pix.shape[0]             # <<<<<<<<<<<<<<
- *     cdef np.ndarray[int64, ndim=1] ring = np.empty(num, dtype=np.int64)
- *     for i in range(num):
- */
-  __pyx_v_num = (__pyx_v_pix->dimensions[0]);
+  /* "healpy/src/_query_disc.pyx":236
+ *     # Call query_polygon
+ *     cdef rangeset[int64] pixset
+ *     hb.query_strip(theta1, theta2, inclusive, pixset)             # <<<<<<<<<<<<<<
+ * 
+ *     return pixset_to_array(pixset)
+ */
+  __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_v_theta1); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_v_theta2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_inclusive); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_hb.query_strip(__pyx_t_5, __pyx_t_6, __pyx_t_2, ((rangeset<int64> &)__pyx_v_pixset));
 
-  /* "healpy/src/_pixelfunc.pyx":97
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
- *     num = pix.shape[0]
- *     cdef np.ndarray[int64, ndim=1] ring = np.empty(num, dtype=np.int64)             # <<<<<<<<<<<<<<
- *     for i in range(num):
- *         ring[i] = hb.pix2ring(pix[i])
+  /* "healpy/src/_query_disc.pyx":238
+ *     hb.query_strip(theta1, theta2, inclusive, pixset)
+ * 
+ *     return pixset_to_array(pixset)             # <<<<<<<<<<<<<<
+ * 
+ * 
  */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_From_Py_intptr_t(__pyx_v_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = __pyx_f_6healpy_11_query_disc_pixset_to_array(__pyx_v_pixset); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
-  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int64); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_8 = PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_3); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("healpy._query_disc.query_strip", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "healpy/src/_query_disc.pyx":271
+ * 
+ * 
+ * cdef pixset_to_array(rangeset[int64] &pixset):             # <<<<<<<<<<<<<<
+ *     cdef int64 i, n
+ *     n = pixset.nval()
+ */
+
+static PyObject *__pyx_f_6healpy_11_query_disc_pixset_to_array(rangeset<int64> &__pyx_v_pixset) {
+  int64 __pyx_v_i;
+  int64 __pyx_v_n;
+  PyArrayObject *__pyx_v_ipix = 0;
+  int64 __pyx_v_a;
+  int64 __pyx_v_b;
+  int64 __pyx_v_ii;
+  int64 __pyx_v_ip;
+  Py_buffer __pyx_bstruct_ipix;
+  Py_ssize_t __pyx_bstride_0_ipix = 0;
+  Py_ssize_t __pyx_bshape_0_ipix = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyArrayObject *__pyx_t_6 = NULL;
+  int64 __pyx_t_7;
+  int64 __pyx_t_8;
+  int64 __pyx_t_9;
+  int64 __pyx_t_10;
+  int64 __pyx_t_11;
+  int __pyx_t_12;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("pixset_to_array");
+  __pyx_bstruct_ipix.buf = NULL;
+
+  /* "healpy/src/_query_disc.pyx":273
+ * cdef pixset_to_array(rangeset[int64] &pixset):
+ *     cdef int64 i, n
+ *     n = pixset.nval()             # <<<<<<<<<<<<<<
+ *     cdef np.ndarray[np.int64_t, ndim=1] ipix = np.empty(n, dtype=np.int64)
+ *     n = pixset.size()
+ */
+  __pyx_v_n = __pyx_v_pixset.nval();
+
+  /* "healpy/src/_query_disc.pyx":274
+ *     cdef int64 i, n
+ *     n = pixset.nval()
+ *     cdef np.ndarray[np.int64_t, ndim=1] ipix = np.empty(n, dtype=np.int64)             # <<<<<<<<<<<<<<
+ *     n = pixset.size()
+ *     cdef int64 a, b, ii, ip
+ */
+  __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__empty); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyInt_to_py_int64(__pyx_v_n); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __pyx_t_4 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__int64); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__dtype), __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(((__pyx_t_8) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_8, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_9 = ((PyArrayObject *)__pyx_t_8);
+  __pyx_t_5 = PyEval_CallObjectWithKeywords(__pyx_t_2, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = ((PyArrayObject *)__pyx_t_5);
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_ring.rcbuffer->pybuffer, (PyObject*)__pyx_t_9, &__Pyx_TypeInfo_nn_int64, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_ring = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_ring.rcbuffer->pybuffer.buf = NULL;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    } else {__pyx_pybuffernd_ring.diminfo[0].strides = __pyx_pybuffernd_ring.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_ring.diminfo[0].shape = __pyx_pybuffernd_ring.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_9 = 0;
-  __pyx_v_ring = ((PyArrayObject *)__pyx_t_8);
-  __pyx_t_8 = 0;
-
-  /* "healpy/src/_pixelfunc.pyx":98
- *     num = pix.shape[0]
- *     cdef np.ndarray[int64, ndim=1] ring = np.empty(num, dtype=np.int64)
- *     for i in range(num):             # <<<<<<<<<<<<<<
- *         ring[i] = hb.pix2ring(pix[i])
- *     return ring
- */
-  __pyx_t_10 = __pyx_v_num;
-  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
-    __pyx_v_i = __pyx_t_11;
-
-    /* "healpy/src/_pixelfunc.pyx":99
- *     cdef np.ndarray[int64, ndim=1] ring = np.empty(num, dtype=np.int64)
- *     for i in range(num):
- *         ring[i] = hb.pix2ring(pix[i])             # <<<<<<<<<<<<<<
- *     return ring
- * 
- */
-    __pyx_t_12 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_12 < 0) {
-      __pyx_t_12 += __pyx_pybuffernd_pix.diminfo[0].shape;
-      if (unlikely(__pyx_t_12 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_12 >= __pyx_pybuffernd_pix.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    __pyx_t_13 = __pyx_v_i;
-    __pyx_t_1 = -1;
-    if (__pyx_t_13 < 0) {
-      __pyx_t_13 += __pyx_pybuffernd_ring.diminfo[0].shape;
-      if (unlikely(__pyx_t_13 < 0)) __pyx_t_1 = 0;
-    } else if (unlikely(__pyx_t_13 >= __pyx_pybuffernd_ring.diminfo[0].shape)) __pyx_t_1 = 0;
-    if (unlikely(__pyx_t_1 != -1)) {
-      __Pyx_RaiseBufferIndexError(__pyx_t_1);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    *__Pyx_BufPtrStrided1d(int64 *, __pyx_pybuffernd_ring.rcbuffer->pybuffer.buf, __pyx_t_13, __pyx_pybuffernd_ring.diminfo[0].strides) = __pyx_v_hb.pix2ring((*__Pyx_BufPtrStrided1d(int64 *, __pyx_pybuffernd_pix.rcbuffer->pybuffer.buf, __pyx_t_12, __pyx_pybuffernd_pix.diminfo[0].strides)));
-  }
-
-  /* "healpy/src/_pixelfunc.pyx":100
- *     for i in range(num):
- *         ring[i] = hb.pix2ring(pix[i])
- *     return ring             # <<<<<<<<<<<<<<
- * 
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_ipix, (PyObject*)__pyx_t_6, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int64_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_ipix = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_ipix.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_ipix = __pyx_bstruct_ipix.strides[0];
+      __pyx_bshape_0_ipix = __pyx_bstruct_ipix.shape[0];
+    }
+  }
+  __pyx_t_6 = 0;
+  __pyx_v_ipix = ((PyArrayObject *)__pyx_t_5);
+  __pyx_t_5 = 0;
+
+  /* "healpy/src/_query_disc.pyx":275
+ *     n = pixset.nval()
+ *     cdef np.ndarray[np.int64_t, ndim=1] ipix = np.empty(n, dtype=np.int64)
+ *     n = pixset.size()             # <<<<<<<<<<<<<<
+ *     cdef int64 a, b, ii, ip
+ *     ii = 0
+ */
+  __pyx_v_n = __pyx_v_pixset.size();
+
+  /* "healpy/src/_query_disc.pyx":277
+ *     n = pixset.size()
+ *     cdef int64 a, b, ii, ip
+ *     ii = 0             # <<<<<<<<<<<<<<
+ *     for i in range(n):
+ *         a = pixset[i].a()
+ */
+  __pyx_v_ii = 0;
+
+  /* "healpy/src/_query_disc.pyx":278
+ *     cdef int64 a, b, ii, ip
+ *     ii = 0
+ *     for i in range(n):             # <<<<<<<<<<<<<<
+ *         a = pixset[i].a()
+ *         b = pixset[i].b()
+ */
+  __pyx_t_7 = __pyx_v_n;
+  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
+    __pyx_v_i = __pyx_t_8;
+
+    /* "healpy/src/_query_disc.pyx":279
+ *     ii = 0
+ *     for i in range(n):
+ *         a = pixset[i].a()             # <<<<<<<<<<<<<<
+ *         b = pixset[i].b()
+ *         for ip in range(a, b):
+ */
+    __pyx_v_a = (__pyx_v_pixset[__pyx_v_i]).a();
+
+    /* "healpy/src/_query_disc.pyx":280
+ *     for i in range(n):
+ *         a = pixset[i].a()
+ *         b = pixset[i].b()             # <<<<<<<<<<<<<<
+ *         for ip in range(a, b):
+ *             ipix[ii] = ip
+ */
+    __pyx_v_b = (__pyx_v_pixset[__pyx_v_i]).b();
+
+    /* "healpy/src/_query_disc.pyx":281
+ *         a = pixset[i].a()
+ *         b = pixset[i].b()
+ *         for ip in range(a, b):             # <<<<<<<<<<<<<<
+ *             ipix[ii] = ip
+ *             ii += 1
+ */
+    __pyx_t_9 = __pyx_v_b;
+    for (__pyx_t_10 = __pyx_v_a; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
+      __pyx_v_ip = __pyx_t_10;
+
+      /* "healpy/src/_query_disc.pyx":282
+ *         b = pixset[i].b()
+ *         for ip in range(a, b):
+ *             ipix[ii] = ip             # <<<<<<<<<<<<<<
+ *             ii += 1
+ *     return ipix
+ */
+      __pyx_t_11 = __pyx_v_ii;
+      __pyx_t_12 = -1;
+      if (__pyx_t_11 < 0) {
+        __pyx_t_11 += __pyx_bshape_0_ipix;
+        if (unlikely(__pyx_t_11 < 0)) __pyx_t_12 = 0;
+      } else if (unlikely(__pyx_t_11 >= __pyx_bshape_0_ipix)) __pyx_t_12 = 0;
+      if (unlikely(__pyx_t_12 != -1)) {
+        __Pyx_RaiseBufferIndexError(__pyx_t_12);
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      *__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int64_t *, __pyx_bstruct_ipix.buf, __pyx_t_11, __pyx_bstride_0_ipix) = __pyx_v_ip;
+
+      /* "healpy/src/_query_disc.pyx":283
+ *         for ip in range(a, b):
+ *             ipix[ii] = ip
+ *             ii += 1             # <<<<<<<<<<<<<<
+ *     return ipix
  * 
  */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(((PyObject *)__pyx_v_ring));
-  __pyx_r = ((PyObject *)__pyx_v_ring);
-  goto __pyx_L0;
+      __pyx_v_ii = (__pyx_v_ii + 1);
+    }
+  }
 
-  /* "healpy/src/_pixelfunc.pyx":58
- *     return startpix, ringpix, costheta, sintheta, shifted
- * 
- * def pix2ring(nside, np.ndarray[int64, ndim=1] pix not None, nest=False):             # <<<<<<<<<<<<<<
- *     """Convert pixel identifier to ring number
+  /* "healpy/src/_query_disc.pyx":284
+ *             ipix[ii] = ip
+ *             ii += 1
+ *     return ipix             # <<<<<<<<<<<<<<
  * 
+ * cdef bool isnsideok(int nside):
  */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_ipix));
+  __pyx_r = ((PyObject *)__pyx_v_ipix);
+  goto __pyx_L0;
 
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_pix.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ring.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_ipix);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("healpy._pixelfunc.pix2ring", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __Pyx_AddTraceback("healpy._query_disc.pixset_to_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_pix.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_ring.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_ipix);
   __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_ring);
+  __Pyx_XDECREF((PyObject *)__pyx_v_ipix);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_pixelfunc.pyx":103
- * 
+/* "healpy/src/_query_disc.pyx":286
+ *     return ipix
  * 
  * cdef bool isnsideok(int nside):             # <<<<<<<<<<<<<<
  *     if nside < 0 or nside != 2**int(round(np.log2(nside))):
  *         return False
  */
 
-static bool __pyx_f_6healpy_10_pixelfunc_isnsideok(int __pyx_v_nside) {
+static bool __pyx_f_6healpy_11_query_disc_isnsideok(int __pyx_v_nside) {
   bool __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("isnsideok", 0);
+  __Pyx_RefNannySetupContext("isnsideok");
 
-  /* "healpy/src/_pixelfunc.pyx":104
+  /* "healpy/src/_query_disc.pyx":287
  * 
  * cdef bool isnsideok(int nside):
  *     if nside < 0 or nside != 2**int(round(np.log2(nside))):             # <<<<<<<<<<<<<<
  *         return False
  *     else:
  */
   __pyx_t_1 = (__pyx_v_nside < 0);
   if (!__pyx_t_1) {
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_nside); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyInt_FromLong(__pyx_v_nside); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_log2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__log2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_nside); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyInt_FromLong(__pyx_v_nside); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_round, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_round, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyNumber_Int(__pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_3);
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)(&PyInt_Type))), ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __pyx_t_5 = PyNumber_Power(__pyx_int_2, __pyx_t_3, Py_None); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyNumber_Power(__pyx_int_2, __pyx_t_5, Py_None); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_5, Py_NE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_7 = __pyx_t_6;
   } else {
     __pyx_t_7 = __pyx_t_1;
   }
   if (__pyx_t_7) {
 
-    /* "healpy/src/_pixelfunc.pyx":105
+    /* "healpy/src/_query_disc.pyx":288
  * cdef bool isnsideok(int nside):
  *     if nside < 0 or nside != 2**int(round(np.log2(nside))):
  *         return False             # <<<<<<<<<<<<<<
  *     else:
  *         return True
  */
     __pyx_r = 0;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "healpy/src/_pixelfunc.pyx":107
+    /* "healpy/src/_query_disc.pyx":290
  *         return False
  *     else:
  *         return True             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_r = 1;
     goto __pyx_L0;
   }
+  __pyx_L3:;
 
-  /* "healpy/src/_pixelfunc.pyx":103
- * 
- * 
- * cdef bool isnsideok(int nside):             # <<<<<<<<<<<<<<
- *     if nside < 0 or nside != 2**int(round(np.log2(nside))):
- *         return False
- */
-
-  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_WriteUnraisable("healpy._pixelfunc.isnsideok", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "_common.pxd":124
- *         tsize Num_Alms (int l, int m)
- * 
- * cdef inline Healpix_Map[double]* ndarray2map(np.ndarray[np.float64_t, ndim=1, mode='c'] array, Healpix_Ordering_Scheme scheme) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as a Healpix Map. """
- *     # To ensure that the output map is a view of the input array, the latter
- */
-
-static CYTHON_INLINE Healpix_Map<double> *__pyx_f_7_common_ndarray2map(PyArrayObject *__pyx_v_array, enum Healpix_Ordering_Scheme __pyx_v_scheme) {
-  arr<double> *__pyx_v_a;
-  Healpix_Map<double> *__pyx_v_map;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_array;
-  __Pyx_Buffer __pyx_pybuffer_array;
-  Healpix_Map<double> *__pyx_r;
-  __Pyx_RefNannyDeclarations
-  long __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  size_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ndarray2map", 0);
-  __pyx_pybuffer_array.pybuffer.buf = NULL;
-  __pyx_pybuffer_array.refcount = 0;
-  __pyx_pybuffernd_array.data = NULL;
-  __pyx_pybuffernd_array.rcbuffer = &__pyx_pybuffer_array;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_array.rcbuffer->pybuffer, (PyObject*)__pyx_v_array, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_C_CONTIGUOUS, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_pybuffernd_array.diminfo[0].strides = __pyx_pybuffernd_array.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_array.diminfo[0].shape = __pyx_pybuffernd_array.rcbuffer->pybuffer.shape[0];
-
-  /* "_common.pxd":129
- *     # is forced to be contiguous, of correct type and dimensions (otherwise, an
- *     # exception is raised).
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)             # <<<<<<<<<<<<<<
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)
- */
-  __pyx_t_1 = 0;
-  __pyx_t_2 = -1;
-  if (__pyx_t_1 < 0) {
-    __pyx_t_1 += __pyx_pybuffernd_array.diminfo[0].shape;
-    if (unlikely(__pyx_t_1 < 0)) __pyx_t_2 = 0;
-  } else if (unlikely(__pyx_t_1 >= __pyx_pybuffernd_array.diminfo[0].shape)) __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_2 != -1)) {
-    __Pyx_RaiseBufferIndexError(__pyx_t_2);
-    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_array), __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_size_t(__pyx_t_3); if (unlikely((__pyx_t_4 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_a = new arr<double>((&(*__Pyx_BufPtrCContig1d(__pyx_t_5numpy_float64_t *, __pyx_pybuffernd_array.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_array.diminfo[0].strides))), __pyx_t_4);
-
-  /* "_common.pxd":130
- *     # exception is raised).
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()             # <<<<<<<<<<<<<<
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated
- */
-  __pyx_v_map = new Healpix_Map<double>();
-
-  /* "_common.pxd":131
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)             # <<<<<<<<<<<<<<
- *     del a # a does not own its buffer, so it won't be deallocated
- *     return map
- */
-  __pyx_v_map->Set((__pyx_v_a[0]), __pyx_v_scheme);
-
-  /* "_common.pxd":132
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated             # <<<<<<<<<<<<<<
- *     return map
- * 
- */
-  delete __pyx_v_a;
-
-  /* "_common.pxd":133
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated
- *     return map             # <<<<<<<<<<<<<<
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:
- */
-  __pyx_r = __pyx_v_map;
-  goto __pyx_L0;
-
-  /* "_common.pxd":124
- *         tsize Num_Alms (int l, int m)
- * 
- * cdef inline Healpix_Map[double]* ndarray2map(np.ndarray[np.float64_t, ndim=1, mode='c'] array, Healpix_Ordering_Scheme scheme) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as a Healpix Map. """
- *     # To ensure that the output map is a view of the input array, the latter
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("_common.ndarray2map", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "_common.pxd":135
- *     return map
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- */
-
-static CYTHON_INLINE Alm<xcomplex<double> > *__pyx_f_7_common_ndarray2alm(PyArrayObject *__pyx_v_array, int __pyx_v_lmax, int __pyx_v_mmax) {
-  arr<xcomplex<double> > *__pyx_v_a;
-  Alm<xcomplex<double> > *__pyx_v_alm;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_array;
-  __Pyx_Buffer __pyx_pybuffer_array;
-  Alm<xcomplex<double> > *__pyx_r;
-  __Pyx_RefNannyDeclarations
-  long __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  size_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ndarray2alm", 0);
-  __pyx_pybuffer_array.pybuffer.buf = NULL;
-  __pyx_pybuffer_array.refcount = 0;
-  __pyx_pybuffernd_array.data = NULL;
-  __pyx_pybuffernd_array.rcbuffer = &__pyx_pybuffer_array;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_array.rcbuffer->pybuffer, (PyObject*)__pyx_v_array, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_C_CONTIGUOUS, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_pybuffernd_array.diminfo[0].strides = __pyx_pybuffernd_array.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_array.diminfo[0].shape = __pyx_pybuffernd_array.rcbuffer->pybuffer.shape[0];
-
-  /* "_common.pxd":137
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)             # <<<<<<<<<<<<<<
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)
- */
-  __pyx_t_1 = 0;
-  __pyx_t_2 = -1;
-  if (__pyx_t_1 < 0) {
-    __pyx_t_1 += __pyx_pybuffernd_array.diminfo[0].shape;
-    if (unlikely(__pyx_t_1 < 0)) __pyx_t_2 = 0;
-  } else if (unlikely(__pyx_t_1 >= __pyx_pybuffernd_array.diminfo[0].shape)) __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_2 != -1)) {
-    __Pyx_RaiseBufferIndexError(__pyx_t_2);
-    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_array), __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_size_t(__pyx_t_3); if (unlikely((__pyx_t_4 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_a = new arr<xcomplex<double> >(((xcomplex<double> *)(&(*__Pyx_BufPtrCContig1d(__pyx_t_double_complex *, __pyx_pybuffernd_array.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_array.diminfo[0].strides)))), __pyx_t_4);
-
-  /* "_common.pxd":138
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()             # <<<<<<<<<<<<<<
- *     alm.Set(a[0], lmax, mmax)
- *     del a
- */
-  __pyx_v_alm = new Alm<xcomplex<double> >();
-
-  /* "_common.pxd":139
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)             # <<<<<<<<<<<<<<
- *     del a
- *     return alm
- */
-  __pyx_v_alm->Set((__pyx_v_a[0]), __pyx_v_lmax, __pyx_v_mmax);
-
-  /* "_common.pxd":140
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)
- *     del a             # <<<<<<<<<<<<<<
- *     return alm
- */
-  delete __pyx_v_a;
-
-  /* "_common.pxd":141
- *     alm.Set(a[0], lmax, mmax)
- *     del a
- *     return alm             # <<<<<<<<<<<<<<
- */
-  __pyx_r = __pyx_v_alm;
-  goto __pyx_L0;
-
-  /* "_common.pxd":135
- *     return map
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("_common.ndarray2alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_WriteUnraisable("healpy._query_disc.isnsideok", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":194
+/* "numpy.pxd":190
  *         # experimental exception made for __getbuffer__ and __releasebuffer__
  *         # -- the details of this may change.
  *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
  *             # This implementation of getbuffer is geared towards Cython
  *             # requirements, and does not yet fullfill the PEP.
  */
 
-/* Python wrapper */
-static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_5numpy_7ndarray___getbuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
+static CYTHON_UNUSED int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_v_copy_shape;
   int __pyx_v_i;
   int __pyx_v_ndim;
   int __pyx_v_endian_detector;
   int __pyx_v_little_endian;
   int __pyx_v_t;
   char *__pyx_v_f;
@@ -2676,741 +2174,763 @@
   int __pyx_t_6;
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   char *__pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__getbuffer__", 0);
+  __Pyx_RefNannySetupContext("__getbuffer__");
   if (__pyx_v_info != NULL) {
     __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(__pyx_v_info->obj);
   }
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":200
+  /* "numpy.pxd":196
  *             # of flags
  * 
  *             if info == NULL: return             # <<<<<<<<<<<<<<
  * 
  *             cdef int copy_shape, i, ndim
  */
-  __pyx_t_1 = ((__pyx_v_info == NULL) != 0);
+  __pyx_t_1 = (__pyx_v_info == NULL);
   if (__pyx_t_1) {
     __pyx_r = 0;
     goto __pyx_L0;
+    goto __pyx_L5;
   }
+  __pyx_L5:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":203
+  /* "numpy.pxd":199
  * 
  *             cdef int copy_shape, i, ndim
  *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  */
   __pyx_v_endian_detector = 1;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":204
+  /* "numpy.pxd":200
  *             cdef int copy_shape, i, ndim
  *             cdef int endian_detector = 1
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  * 
  *             ndim = PyArray_NDIM(self)
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":206
+  /* "numpy.pxd":202
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
-  __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);
+  __pyx_v_ndim = PyArray_NDIM(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":208
+  /* "numpy.pxd":204
  *             ndim = PyArray_NDIM(self)
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 copy_shape = 1
  *             else:
  */
-  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
+  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":209
+    /* "numpy.pxd":205
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 copy_shape = 1             # <<<<<<<<<<<<<<
  *             else:
  *                 copy_shape = 0
  */
     __pyx_v_copy_shape = 1;
-    goto __pyx_L4;
+    goto __pyx_L6;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":211
+    /* "numpy.pxd":207
  *                 copy_shape = 1
  *             else:
  *                 copy_shape = 0             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  */
     __pyx_v_copy_shape = 0;
   }
-  __pyx_L4:;
+  __pyx_L6:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":213
+  /* "numpy.pxd":209
  *                 copy_shape = 0
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")
  */
-  __pyx_t_1 = (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS) != 0);
+  __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":214
+    /* "numpy.pxd":210
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  */
-    __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_C_CONTIGUOUS) != 0)) != 0);
+    __pyx_t_2 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_C_CONTIGUOUS));
     __pyx_t_3 = __pyx_t_2;
   } else {
     __pyx_t_3 = __pyx_t_1;
   }
   if (__pyx_t_3) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":215
+    /* "numpy.pxd":211
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_12), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L7;
   }
+  __pyx_L7:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":217
+  /* "numpy.pxd":213
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  */
-  __pyx_t_3 = (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS) != 0);
+  __pyx_t_3 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);
   if (__pyx_t_3) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":218
+    /* "numpy.pxd":214
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  */
-    __pyx_t_1 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_F_CONTIGUOUS) != 0)) != 0);
+    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_F_CONTIGUOUS));
     __pyx_t_2 = __pyx_t_1;
   } else {
     __pyx_t_2 = __pyx_t_3;
   }
   if (__pyx_t_2) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":219
+    /* "numpy.pxd":215
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_14), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L8;
   }
+  __pyx_L8:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":221
+  /* "numpy.pxd":217
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
  *             info.ndim = ndim
  *             if copy_shape:
  */
-  __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);
+  __pyx_v_info->buf = PyArray_DATA(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":222
+  /* "numpy.pxd":218
  * 
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim             # <<<<<<<<<<<<<<
  *             if copy_shape:
  *                 # Allocate new buffer for strides and shape info.
  */
   __pyx_v_info->ndim = __pyx_v_ndim;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":223
+  /* "numpy.pxd":219
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim
  *             if copy_shape:             # <<<<<<<<<<<<<<
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  */
-  __pyx_t_2 = (__pyx_v_copy_shape != 0);
-  if (__pyx_t_2) {
+  if (__pyx_v_copy_shape) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":226
+    /* "numpy.pxd":222
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)             # <<<<<<<<<<<<<<
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  */
     __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * ((size_t)__pyx_v_ndim)) * 2)));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":227
+    /* "numpy.pxd":223
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
  *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  */
     __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":228
+    /* "numpy.pxd":224
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):             # <<<<<<<<<<<<<<
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  */
     __pyx_t_5 = __pyx_v_ndim;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_i = __pyx_t_6;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":229
+      /* "numpy.pxd":225
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  */
-      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);
+      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":230
+      /* "numpy.pxd":226
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  */
-      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
+      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
     }
-    goto __pyx_L7;
+    goto __pyx_L9;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":232
+    /* "numpy.pxd":228
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  */
-    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));
+    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(((PyArrayObject *)__pyx_v_self)));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":233
+    /* "numpy.pxd":229
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  */
-    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
+    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(((PyArrayObject *)__pyx_v_self)));
   }
-  __pyx_L7:;
+  __pyx_L9:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":234
+  /* "numpy.pxd":230
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":235
+  /* "numpy.pxd":231
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  * 
  */
-  __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);
+  __pyx_v_info->itemsize = PyArray_ITEMSIZE(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":236
+  /* "numpy.pxd":232
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
  * 
  *             cdef int t
  */
-  __pyx_v_info->readonly = (!(PyArray_ISWRITEABLE(__pyx_v_self) != 0));
+  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(((PyArrayObject *)__pyx_v_self)));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":239
+  /* "numpy.pxd":235
  * 
  *             cdef int t
  *             cdef char* f = NULL             # <<<<<<<<<<<<<<
  *             cdef dtype descr = self.descr
  *             cdef list stack
  */
   __pyx_v_f = NULL;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":240
+  /* "numpy.pxd":236
  *             cdef int t
  *             cdef char* f = NULL
  *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
  *             cdef list stack
  *             cdef int offset
  */
-  __pyx_t_4 = ((PyObject *)__pyx_v_self->descr);
-  __Pyx_INCREF(__pyx_t_4);
-  __pyx_v_descr = ((PyArray_Descr *)__pyx_t_4);
-  __pyx_t_4 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_v_self)->descr));
+  __pyx_v_descr = ((PyArrayObject *)__pyx_v_self)->descr;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":244
+  /* "numpy.pxd":240
  *             cdef int offset
  * 
  *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
  * 
  *             if not hasfields and not copy_shape:
  */
   __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":246
+  /* "numpy.pxd":242
  *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
  * 
  *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
  *                 # do not call releasebuffer
  *                 info.obj = None
  */
-  __pyx_t_2 = ((!(__pyx_v_hasfields != 0)) != 0);
+  __pyx_t_2 = (!__pyx_v_hasfields);
   if (__pyx_t_2) {
-    __pyx_t_3 = ((!(__pyx_v_copy_shape != 0)) != 0);
+    __pyx_t_3 = (!__pyx_v_copy_shape);
     __pyx_t_1 = __pyx_t_3;
   } else {
     __pyx_t_1 = __pyx_t_2;
   }
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":248
+    /* "numpy.pxd":244
  *             if not hasfields and not copy_shape:
  *                 # do not call releasebuffer
  *                 info.obj = None             # <<<<<<<<<<<<<<
  *             else:
  *                 # need to call releasebuffer
  */
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj);
     __pyx_v_info->obj = Py_None;
-    goto __pyx_L10;
+    goto __pyx_L12;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":251
+    /* "numpy.pxd":247
  *             else:
  *                 # need to call releasebuffer
  *                 info.obj = self             # <<<<<<<<<<<<<<
  * 
  *             if not hasfields:
  */
-    __Pyx_INCREF(((PyObject *)__pyx_v_self));
-    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
+    __Pyx_INCREF(__pyx_v_self);
+    __Pyx_GIVEREF(__pyx_v_self);
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj);
-    __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
+    __pyx_v_info->obj = __pyx_v_self;
   }
-  __pyx_L10:;
+  __pyx_L12:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":253
+  /* "numpy.pxd":249
  *                 info.obj = self
  * 
  *             if not hasfields:             # <<<<<<<<<<<<<<
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or
+ *                 if ((descr.byteorder == '>' and little_endian) or
  */
-  __pyx_t_1 = ((!(__pyx_v_hasfields != 0)) != 0);
+  __pyx_t_1 = (!__pyx_v_hasfields);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":254
+    /* "numpy.pxd":250
  * 
  *             if not hasfields:
  *                 t = descr.type_num             # <<<<<<<<<<<<<<
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  */
-    __pyx_t_5 = __pyx_v_descr->type_num;
-    __pyx_v_t = __pyx_t_5;
+    __pyx_v_t = __pyx_v_descr->type_num;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":255
+    /* "numpy.pxd":251
  *             if not hasfields:
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
- *                     (descr.byteorder == c'<' and not little_endian)):
+ *                 if ((descr.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  */
-    __pyx_t_1 = ((__pyx_v_descr->byteorder == '>') != 0);
+    __pyx_t_1 = (__pyx_v_descr->byteorder == '>');
     if (__pyx_t_1) {
-      __pyx_t_2 = (__pyx_v_little_endian != 0);
+      __pyx_t_2 = __pyx_v_little_endian;
     } else {
       __pyx_t_2 = __pyx_t_1;
     }
     if (!__pyx_t_2) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":256
+      /* "numpy.pxd":252
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  */
-      __pyx_t_1 = ((__pyx_v_descr->byteorder == '<') != 0);
+      __pyx_t_1 = (__pyx_v_descr->byteorder == '<');
       if (__pyx_t_1) {
-        __pyx_t_3 = ((!(__pyx_v_little_endian != 0)) != 0);
+        __pyx_t_3 = (!__pyx_v_little_endian);
         __pyx_t_7 = __pyx_t_3;
       } else {
         __pyx_t_7 = __pyx_t_1;
       }
       __pyx_t_1 = __pyx_t_7;
     } else {
       __pyx_t_1 = __pyx_t_2;
     }
     if (__pyx_t_1) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":257
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+      /* "numpy.pxd":253
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_16), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L14;
     }
+    __pyx_L14:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
- *                 elif t == NPY_CDOUBLE:     f = "Zd"
- *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
- *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
- *                 else:
- *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
- */
-    switch (__pyx_v_t) {
-
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":258
- *                     (descr.byteorder == c'<' and not little_endian)):
+    /* "numpy.pxd":254
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  */
-      case NPY_BYTE:
-      __pyx_v_f = __pyx_k_b;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_BYTE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__b;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":259
+    /* "numpy.pxd":255
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  */
-      case NPY_UBYTE:
-      __pyx_v_f = __pyx_k_B;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_UBYTE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__B;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":260
+    /* "numpy.pxd":256
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  */
-      case NPY_SHORT:
-      __pyx_v_f = __pyx_k_h;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_SHORT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__h;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":261
+    /* "numpy.pxd":257
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  */
-      case NPY_USHORT:
-      __pyx_v_f = __pyx_k_H;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_USHORT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__H;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":262
+    /* "numpy.pxd":258
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  */
-      case NPY_INT:
-      __pyx_v_f = __pyx_k_i;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_INT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__i;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":263
+    /* "numpy.pxd":259
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  */
-      case NPY_UINT:
-      __pyx_v_f = __pyx_k_I;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_UINT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__I;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":264
+    /* "numpy.pxd":260
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  */
-      case NPY_LONG:
-      __pyx_v_f = __pyx_k_l;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__l;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":265
+    /* "numpy.pxd":261
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  */
-      case NPY_ULONG:
-      __pyx_v_f = __pyx_k_L;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_ULONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__L;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":266
+    /* "numpy.pxd":262
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  */
-      case NPY_LONGLONG:
-      __pyx_v_f = __pyx_k_q;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONGLONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__q;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":267
+    /* "numpy.pxd":263
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  */
-      case NPY_ULONGLONG:
-      __pyx_v_f = __pyx_k_Q;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_ULONGLONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Q;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":268
+    /* "numpy.pxd":264
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  */
-      case NPY_FLOAT:
-      __pyx_v_f = __pyx_k_f;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_FLOAT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__f;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":269
+    /* "numpy.pxd":265
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  */
-      case NPY_DOUBLE:
-      __pyx_v_f = __pyx_k_d;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_DOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__d;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":270
+    /* "numpy.pxd":266
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  */
-      case NPY_LONGDOUBLE:
-      __pyx_v_f = __pyx_k_g;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONGDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__g;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":271
+    /* "numpy.pxd":267
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  */
-      case NPY_CFLOAT:
-      __pyx_v_f = __pyx_k_Zf;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CFLOAT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zf;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":272
+    /* "numpy.pxd":268
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"
  */
-      case NPY_CDOUBLE:
-      __pyx_v_f = __pyx_k_Zd;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zd;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":273
+    /* "numpy.pxd":269
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  */
-      case NPY_CLONGDOUBLE:
-      __pyx_v_f = __pyx_k_Zg;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CLONGDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zg;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
+    /* "numpy.pxd":270
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      case NPY_OBJECT:
-      __pyx_v_f = __pyx_k_O;
-      break;
-      default:
+    __pyx_t_1 = (__pyx_v_t == NPY_OBJECT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__O;
+      goto __pyx_L15;
+    }
+    /*else*/ {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":276
+      /* "numpy.pxd":272
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *                 info.format = f
  *                 return
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_8 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_t_8 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_17), __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_8));
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_8);
-      __Pyx_GIVEREF(__pyx_t_8);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_8));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_8));
       __pyx_t_8 = 0;
-      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_8);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      break;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
+    __pyx_L15:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":277
+    /* "numpy.pxd":273
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f             # <<<<<<<<<<<<<<
  *                 return
  *             else:
  */
     __pyx_v_info->format = __pyx_v_f;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":278
+    /* "numpy.pxd":274
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f
  *                 return             # <<<<<<<<<<<<<<
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
  */
     __pyx_r = 0;
     goto __pyx_L0;
+    goto __pyx_L13;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":280
+    /* "numpy.pxd":276
  *                 return
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
- *                 info.format[0] = c'^' # Native data types, manual alignment
+ *                 info.format[0] = '^' # Native data types, manual alignment
  *                 offset = 0
  */
     __pyx_v_info->format = ((char *)malloc(255));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":281
+    /* "numpy.pxd":277
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
- *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
+ *                 info.format[0] = '^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
  *                 offset = 0
  *                 f = _util_dtypestring(descr, info.format + 1,
  */
     (__pyx_v_info->format[0]) = '^';
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":282
+    /* "numpy.pxd":278
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
- *                 info.format[0] = c'^' # Native data types, manual alignment
+ *                 info.format[0] = '^' # Native data types, manual alignment
  *                 offset = 0             # <<<<<<<<<<<<<<
  *                 f = _util_dtypestring(descr, info.format + 1,
  *                                       info.format + _buffer_format_string_len,
  */
     __pyx_v_offset = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":283
- *                 info.format[0] = c'^' # Native data types, manual alignment
- *                 offset = 0
- *                 f = _util_dtypestring(descr, info.format + 1,             # <<<<<<<<<<<<<<
+    /* "numpy.pxd":281
+ *                 f = _util_dtypestring(descr, info.format + 1,
  *                                       info.format + _buffer_format_string_len,
- *                                       &offset)
+ *                                       &offset)             # <<<<<<<<<<<<<<
+ *                 f[0] = 0 # Terminate format string
+ * 
  */
-    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __pyx_v_f = __pyx_t_9;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":286
+    /* "numpy.pxd":282
  *                                       info.format + _buffer_format_string_len,
  *                                       &offset)
- *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
+ *                 f[0] = 0 # Terminate format string             # <<<<<<<<<<<<<<
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  */
-    (__pyx_v_f[0]) = '\x00';
+    (__pyx_v_f[0]) = 0;
   }
+  __pyx_L13:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":194
- *         # experimental exception made for __getbuffer__ and __releasebuffer__
- *         # -- the details of this may change.
- *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
- *             # This implementation of getbuffer is geared towards Cython
- *             # requirements, and does not yet fullfill the PEP.
- */
-
-  /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
@@ -3426,345 +2946,291 @@
   }
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_descr);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":288
- *                 f[0] = c'\0' # Terminate format string
+/* "numpy.pxd":284
+ *                 f[0] = 0 # Terminate format string
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)
  */
 
-/* Python wrapper */
-static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
-static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
-  __pyx_pf_5numpy_7ndarray_2__releasebuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-}
-
-static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
+static CYTHON_UNUSED void __pyx_pf_5numpy_7ndarray_1__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
+static CYTHON_UNUSED void __pyx_pf_5numpy_7ndarray_1__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("__releasebuffer__", 0);
+  __Pyx_RefNannySetupContext("__releasebuffer__");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":289
+  /* "numpy.pxd":285
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
-  __pyx_t_1 = (PyArray_HASFIELDS(__pyx_v_self) != 0);
+  __pyx_t_1 = PyArray_HASFIELDS(((PyArrayObject *)__pyx_v_self));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":290
+    /* "numpy.pxd":286
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 stdlib.free(info.strides)
  */
     free(__pyx_v_info->format);
-    goto __pyx_L3;
+    goto __pyx_L5;
   }
-  __pyx_L3:;
+  __pyx_L5:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":291
+  /* "numpy.pxd":287
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 stdlib.free(info.strides)
  *                 # info.shape was stored after info.strides in the same block
  */
-  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
+  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":292
+    /* "numpy.pxd":288
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
  *                 # info.shape was stored after info.strides in the same block
  * 
  */
     free(__pyx_v_info->strides);
-    goto __pyx_L4;
+    goto __pyx_L6;
   }
-  __pyx_L4:;
+  __pyx_L6:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":288
- *                 f[0] = c'\0' # Terminate format string
- * 
- *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
- *             if PyArray_HASFIELDS(self):
- *                 stdlib.free(info.format)
- */
-
-  /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":768
+/* "numpy.pxd":764
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":769
+  /* "numpy.pxd":765
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":768
- * ctypedef npy_cdouble     complex_t
- * 
- * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(1, <void*>a)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":771
+/* "numpy.pxd":767
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":772
+  /* "numpy.pxd":768
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 768; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":771
- *     return PyArray_MultiIterNew(1, <void*>a)
- * 
- * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":774
+/* "numpy.pxd":770
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":775
+  /* "numpy.pxd":771
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":774
- *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- * 
- * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":777
+/* "numpy.pxd":773
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":778
+  /* "numpy.pxd":774
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":777
- *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- * 
- * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":780
+/* "numpy.pxd":776
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":781
+  /* "numpy.pxd":777
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":780
- *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- * 
- * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":783
+/* "numpy.pxd":779
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
  *     # Recursive utility function used in __getbuffer__ to get format
  *     # string. The new location in the format string is returned.
  */
 
@@ -3778,1230 +3244,1237 @@
   PyObject *__pyx_v_t = NULL;
   char *__pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   long __pyx_t_10;
   char *__pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_util_dtypestring", 0);
+  __Pyx_RefNannySetupContext("_util_dtypestring");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":790
+  /* "numpy.pxd":786
  *     cdef int delta_offset
  *     cdef tuple i
  *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  *     cdef tuple fields
  */
   __pyx_v_endian_detector = 1;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":791
+  /* "numpy.pxd":787
  *     cdef tuple i
  *     cdef int endian_detector = 1
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  *     cdef tuple fields
  * 
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":794
+  /* "numpy.pxd":790
  *     cdef tuple fields
  * 
  *     for childname in descr.names:             # <<<<<<<<<<<<<<
  *         fields = descr.fields[childname]
  *         child, new_offset = fields
  */
-  if (unlikely(__pyx_v_descr->names == Py_None)) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(((PyObject *)__pyx_v_descr->names) == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable"); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;} 
   }
-  __pyx_t_1 = __pyx_v_descr->names; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
+  __pyx_t_1 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #endif
-    __Pyx_XDECREF_SET(__pyx_v_childname, __pyx_t_3);
+    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++;
+    __Pyx_XDECREF(__pyx_v_childname);
+    __pyx_v_childname = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":795
+    /* "numpy.pxd":791
  * 
  *     for childname in descr.names:
  *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
  *         child, new_offset = fields
  * 
  */
-    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_XDECREF_SET(__pyx_v_fields, ((PyObject*)__pyx_t_3));
+    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected tuple, got %.200s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_XDECREF(((PyObject *)__pyx_v_fields));
+    __pyx_v_fields = ((PyObject*)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":796
+    /* "numpy.pxd":792
  *     for childname in descr.names:
  *         fields = descr.fields[childname]
  *         child, new_offset = fields             # <<<<<<<<<<<<<<
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  */
-    if (likely(__pyx_v_fields != Py_None)) {
-      PyObject* sequence = __pyx_v_fields;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      Py_ssize_t size = Py_SIZE(sequence);
-      #else
-      Py_ssize_t size = PySequence_Size(sequence);
-      #endif
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (likely(PyTuple_CheckExact(((PyObject *)__pyx_v_fields)))) {
+      PyObject* sequence = ((PyObject *)__pyx_v_fields);
+      if (unlikely(PyTuple_GET_SIZE(sequence) != 2)) {
+        if (PyTuple_GET_SIZE(sequence) > 2) __Pyx_RaiseTooManyValuesError(2);
+        else __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(sequence));
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
-      #if CYTHON_COMPILING_IN_CPYTHON
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
-      #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      #endif
     } else {
-      __Pyx_RaiseNoneNotIterableError(); {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_UnpackTupleError(((PyObject *)__pyx_v_fields), 2);
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_XDECREF_SET(__pyx_v_child, ((PyArray_Descr *)__pyx_t_3));
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_XDECREF(((PyObject *)__pyx_v_child));
+    __pyx_v_child = ((PyArray_Descr *)__pyx_t_3);
     __pyx_t_3 = 0;
-    __Pyx_XDECREF_SET(__pyx_v_new_offset, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_v_new_offset);
+    __pyx_v_new_offset = __pyx_t_4;
     __pyx_t_4 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":798
+    /* "numpy.pxd":794
  *         child, new_offset = fields
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
+ *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  */
-    __pyx_t_4 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_6 = ((((__pyx_v_end - __pyx_v_f) - ((int)__pyx_t_5)) < 15) != 0);
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":799
+      /* "numpy.pxd":795
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
+ *         if ((child.byteorder == '>' and little_endian) or
  */
-      __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_19), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L5;
     }
+    __pyx_L5:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":801
+    /* "numpy.pxd":797
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
- *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
- *             (child.byteorder == c'<' and not little_endian)):
+ *         if ((child.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")
  */
-    __pyx_t_6 = ((__pyx_v_child->byteorder == '>') != 0);
+    __pyx_t_6 = (__pyx_v_child->byteorder == '>');
     if (__pyx_t_6) {
-      __pyx_t_7 = (__pyx_v_little_endian != 0);
+      __pyx_t_7 = __pyx_v_little_endian;
     } else {
       __pyx_t_7 = __pyx_t_6;
     }
     if (!__pyx_t_7) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":802
+      /* "numpy.pxd":798
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
  *             raise ValueError(u"Non-native byte order not supported")
  *             # One could encode it in the format string and have Cython
  */
-      __pyx_t_6 = ((__pyx_v_child->byteorder == '<') != 0);
+      __pyx_t_6 = (__pyx_v_child->byteorder == '<');
       if (__pyx_t_6) {
-        __pyx_t_8 = ((!(__pyx_v_little_endian != 0)) != 0);
+        __pyx_t_8 = (!__pyx_v_little_endian);
         __pyx_t_9 = __pyx_t_8;
       } else {
         __pyx_t_9 = __pyx_t_6;
       }
       __pyx_t_6 = __pyx_t_9;
     } else {
       __pyx_t_6 = __pyx_t_7;
     }
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":803
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):
+      /* "numpy.pxd":799
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_20), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L6;
     }
+    __pyx_L6:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":813
+    /* "numpy.pxd":809
  * 
  *         # Output padding bytes
  *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  */
     while (1) {
-      __pyx_t_3 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (!__pyx_t_6) break;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":814
+      /* "numpy.pxd":810
  *         # Output padding bytes
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
  *             f += 1
  *             offset[0] += 1
  */
       (__pyx_v_f[0]) = 120;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":815
+      /* "numpy.pxd":811
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte
  *             f += 1             # <<<<<<<<<<<<<<
  *             offset[0] += 1
  * 
  */
       __pyx_v_f = (__pyx_v_f + 1);
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":816
+      /* "numpy.pxd":812
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  *             offset[0] += 1             # <<<<<<<<<<<<<<
  * 
  *         offset[0] += child.itemsize
  */
       __pyx_t_10 = 0;
       (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + 1);
     }
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":818
+    /* "numpy.pxd":814
  *             offset[0] += 1
  * 
  *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not PyDataType_HASFIELDS(child):
  */
     __pyx_t_10 = 0;
     (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + __pyx_v_child->elsize);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":820
+    /* "numpy.pxd":816
  *         offset[0] += child.itemsize
  * 
  *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
  *             t = child.type_num
  *             if end - f < 5:
  */
-    __pyx_t_6 = ((!(PyDataType_HASFIELDS(__pyx_v_child) != 0)) != 0);
+    __pyx_t_6 = (!PyDataType_HASFIELDS(__pyx_v_child));
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":821
+      /* "numpy.pxd":817
  * 
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num             # <<<<<<<<<<<<<<
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_XDECREF_SET(__pyx_v_t, __pyx_t_4);
-      __pyx_t_4 = 0;
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_v_t);
+      __pyx_v_t = __pyx_t_3;
+      __pyx_t_3 = 0;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":822
+      /* "numpy.pxd":818
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num
  *             if end - f < 5:             # <<<<<<<<<<<<<<
  *                 raise RuntimeError(u"Format string allocated too short.")
  * 
  */
-      __pyx_t_6 = (((__pyx_v_end - __pyx_v_f) < 5) != 0);
+      __pyx_t_6 = ((__pyx_v_end - __pyx_v_f) < 5);
       if (__pyx_t_6) {
 
-        /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":823
+        /* "numpy.pxd":819
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-        __pyx_t_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_22), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L10;
       }
+      __pyx_L10:;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":826
+      /* "numpy.pxd":822
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 98;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":827
+      /* "numpy.pxd":823
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 66;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":828
+      /* "numpy.pxd":824
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 104;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":829
+      /* "numpy.pxd":825
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 72;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":830
+      /* "numpy.pxd":826
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 105;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":831
+      /* "numpy.pxd":827
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 73;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":832
+      /* "numpy.pxd":828
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 108;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":833
+      /* "numpy.pxd":829
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 76;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":834
+      /* "numpy.pxd":830
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 113;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":835
+      /* "numpy.pxd":831
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 81;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":836
+      /* "numpy.pxd":832
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 102;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":837
+      /* "numpy.pxd":833
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 100;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":838
+      /* "numpy.pxd":834
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 103;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":839
+      /* "numpy.pxd":835
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 102;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":840
+      /* "numpy.pxd":836
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 100;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":841
+      /* "numpy.pxd":837
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 103;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":842
+      /* "numpy.pxd":838
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 79;
         goto __pyx_L11;
       }
       /*else*/ {
 
-        /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":844
+        /* "numpy.pxd":840
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *             f += 1
  *         else:
  */
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_v_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_4);
-        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-        __Pyx_GIVEREF(__pyx_t_3);
-        __pyx_t_3 = 0;
-        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_17), __pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));
+        __Pyx_GIVEREF(((PyObject *)__pyx_t_5));
+        __pyx_t_5 = 0;
+        __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+        __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
       __pyx_L11:;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":845
+      /* "numpy.pxd":841
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *             f += 1             # <<<<<<<<<<<<<<
  *         else:
  *             # Cython ignores struct boundary information ("T{...}"),
  */
       __pyx_v_f = (__pyx_v_f + 1);
       goto __pyx_L9;
     }
     /*else*/ {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":849
+      /* "numpy.pxd":845
  *             # Cython ignores struct boundary information ("T{...}"),
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
  *     return f
  * 
  */
-      __pyx_t_11 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_11 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __pyx_v_f = __pyx_t_11;
     }
     __pyx_L9:;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":850
+  /* "numpy.pxd":846
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)
  *     return f             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_f;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":783
- *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- * 
- * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
- *     # Recursive utility function used in __getbuffer__ to get format
- *     # string. The new location in the format string is returned.
- */
-
-  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("numpy._util_dtypestring", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_child);
   __Pyx_XDECREF(__pyx_v_fields);
   __Pyx_XDECREF(__pyx_v_childname);
   __Pyx_XDECREF(__pyx_v_new_offset);
   __Pyx_XDECREF(__pyx_v_t);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":966
+/* "numpy.pxd":961
  * 
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *      cdef PyObject* baseptr
  *      if base is None:
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   PyObject *__pyx_v_baseptr;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  int __pyx_t_2;
-  __Pyx_RefNannySetupContext("set_array_base", 0);
+  __Pyx_RefNannySetupContext("set_array_base");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":968
+  /* "numpy.pxd":963
  * cdef inline void set_array_base(ndarray arr, object base):
  *      cdef PyObject* baseptr
  *      if base is None:             # <<<<<<<<<<<<<<
  *          baseptr = NULL
  *      else:
  */
   __pyx_t_1 = (__pyx_v_base == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
+  if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":969
+    /* "numpy.pxd":964
  *      cdef PyObject* baseptr
  *      if base is None:
  *          baseptr = NULL             # <<<<<<<<<<<<<<
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!
  */
     __pyx_v_baseptr = NULL;
     goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":971
+    /* "numpy.pxd":966
  *          baseptr = NULL
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)
  */
     Py_INCREF(__pyx_v_base);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":972
+    /* "numpy.pxd":967
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!
  *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
  *      Py_XDECREF(arr.base)
  *      arr.base = baseptr
  */
     __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
   }
   __pyx_L3:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":973
+  /* "numpy.pxd":968
  *          Py_INCREF(base) # important to do this before decref below!
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
  *      arr.base = baseptr
  * 
  */
   Py_XDECREF(__pyx_v_arr->base);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":974
+  /* "numpy.pxd":969
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)
  *      arr.base = baseptr             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   __pyx_v_arr->base = __pyx_v_baseptr;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":966
- * 
- * 
- * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
- *      cdef PyObject* baseptr
- *      if base is None:
- */
-
-  /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
+/* "numpy.pxd":971
  *      arr.base = baseptr
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     if arr.base is NULL:
  *         return None
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("get_array_base", 0);
+  __Pyx_RefNannySetupContext("get_array_base");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":977
+  /* "numpy.pxd":972
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     if arr.base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     else:
  */
-  __pyx_t_1 = ((__pyx_v_arr->base == NULL) != 0);
+  __pyx_t_1 = (__pyx_v_arr->base == NULL);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":978
+    /* "numpy.pxd":973
  * cdef inline object get_array_base(ndarray arr):
  *     if arr.base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     else:
  *         return <object>arr.base
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(Py_None);
     __pyx_r = Py_None;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":980
+    /* "numpy.pxd":975
  *         return None
  *     else:
  *         return <object>arr.base             # <<<<<<<<<<<<<<
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
     __pyx_r = ((PyObject *)__pyx_v_arr->base);
     goto __pyx_L0;
   }
+  __pyx_L3:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
- *      arr.base = baseptr
- * 
- * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
- *     if arr.base is NULL:
- *         return None
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 static struct PyModuleDef __pyx_moduledef = {
-  #if PY_VERSION_HEX < 0x03020000
-    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
-  #else
     PyModuleDef_HEAD_INIT,
-  #endif
-    __Pyx_NAMESTR("_pixelfunc"),
+    __Pyx_NAMESTR("_query_disc"),
     0, /* m_doc */
     -1, /* m_size */
     __pyx_methods /* m_methods */,
     NULL, /* m_reload */
     NULL, /* m_traverse */
     NULL, /* m_clear */
     NULL /* m_free */
 };
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_kp_u_Convert_pixel_identifier_to_ring, __pyx_k_Convert_pixel_identifier_to_ring, sizeof(__pyx_k_Convert_pixel_identifier_to_ring), 0, 1, 0, 0},
-  {&__pyx_kp_u_Format_string_allocated_too_shor, __pyx_k_Format_string_allocated_too_shor, sizeof(__pyx_k_Format_string_allocated_too_shor), 0, 1, 0, 0},
-  {&__pyx_kp_u_Format_string_allocated_too_shor_2, __pyx_k_Format_string_allocated_too_shor_2, sizeof(__pyx_k_Format_string_allocated_too_shor_2), 0, 1, 0, 0},
-  {&__pyx_kp_u_Get_information_for_rings_Rings, __pyx_k_Get_information_for_rings_Rings, sizeof(__pyx_k_Get_information_for_rings_Rings), 0, 1, 0, 0},
-  {&__pyx_kp_u_Non_native_byte_order_not_suppor, __pyx_k_Non_native_byte_order_not_suppor, sizeof(__pyx_k_Non_native_byte_order_not_suppor), 0, 1, 0, 0},
-  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
-  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Wrong_nside_value_must_be_a_powe, __pyx_k_Wrong_nside_value_must_be_a_powe, sizeof(__pyx_k_Wrong_nside_value_must_be_a_powe), 0, 0, 1, 0},
-  {&__pyx_n_s_bool, __pyx_k_bool, sizeof(__pyx_k_bool), 0, 0, 1, 1},
-  {&__pyx_n_s_costheta, __pyx_k_costheta, sizeof(__pyx_k_costheta), 0, 0, 1, 1},
-  {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
-  {&__pyx_n_s_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 0, 0, 1, 1},
-  {&__pyx_n_s_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 0, 1, 1},
-  {&__pyx_n_s_hb, __pyx_k_hb, sizeof(__pyx_k_hb), 0, 0, 1, 1},
-  {&__pyx_n_s_healpy__pixelfunc, __pyx_k_healpy__pixelfunc, sizeof(__pyx_k_healpy__pixelfunc), 0, 0, 1, 1},
-  {&__pyx_kp_s_home_zonca_healpy_healpy_src__p, __pyx_k_home_zonca_healpy_healpy_src__p, sizeof(__pyx_k_home_zonca_healpy_healpy_src__p), 0, 0, 1, 0},
-  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
-  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-  {&__pyx_n_s_int64, __pyx_k_int64, sizeof(__pyx_k_int64), 0, 0, 1, 1},
-  {&__pyx_n_s_log2, __pyx_k_log2, sizeof(__pyx_k_log2), 0, 0, 1, 1},
-  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-  {&__pyx_kp_u_ndarray_is_not_C_contiguous, __pyx_k_ndarray_is_not_C_contiguous, sizeof(__pyx_k_ndarray_is_not_C_contiguous), 0, 1, 0, 0},
-  {&__pyx_kp_u_ndarray_is_not_Fortran_contiguou, __pyx_k_ndarray_is_not_Fortran_contiguou, sizeof(__pyx_k_ndarray_is_not_Fortran_contiguou), 0, 1, 0, 0},
-  {&__pyx_n_s_nest, __pyx_k_nest, sizeof(__pyx_k_nest), 0, 0, 1, 1},
-  {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
-  {&__pyx_n_s_nside, __pyx_k_nside, sizeof(__pyx_k_nside), 0, 0, 1, 1},
-  {&__pyx_n_s_num, __pyx_k_num, sizeof(__pyx_k_num), 0, 0, 1, 1},
-  {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
-  {&__pyx_n_s_pix, __pyx_k_pix, sizeof(__pyx_k_pix), 0, 0, 1, 1},
-  {&__pyx_n_s_pix2ring, __pyx_k_pix2ring, sizeof(__pyx_k_pix2ring), 0, 0, 1, 1},
-  {&__pyx_kp_u_pix2ring_line_58, __pyx_k_pix2ring_line_58, sizeof(__pyx_k_pix2ring_line_58), 0, 1, 0, 0},
-  {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
-  {&__pyx_n_s_pyx_releasebuffer, __pyx_k_pyx_releasebuffer, sizeof(__pyx_k_pyx_releasebuffer), 0, 0, 1, 1},
-  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-  {&__pyx_n_s_ring, __pyx_k_ring, sizeof(__pyx_k_ring), 0, 0, 1, 1},
-  {&__pyx_n_s_ringinfo, __pyx_k_ringinfo, sizeof(__pyx_k_ringinfo), 0, 0, 1, 1},
-  {&__pyx_kp_u_ringinfo_line_9, __pyx_k_ringinfo_line_9, sizeof(__pyx_k_ringinfo_line_9), 0, 1, 0, 0},
-  {&__pyx_n_s_ringpix, __pyx_k_ringpix, sizeof(__pyx_k_ringpix), 0, 0, 1, 1},
-  {&__pyx_n_s_round, __pyx_k_round, sizeof(__pyx_k_round), 0, 0, 1, 1},
-  {&__pyx_n_s_scheme, __pyx_k_scheme, sizeof(__pyx_k_scheme), 0, 0, 1, 1},
-  {&__pyx_n_s_shifted, __pyx_k_shifted, sizeof(__pyx_k_shifted), 0, 0, 1, 1},
-  {&__pyx_n_s_sintheta, __pyx_k_sintheta, sizeof(__pyx_k_sintheta), 0, 0, 1, 1},
-  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
-  {&__pyx_n_s_startpix, __pyx_k_startpix, sizeof(__pyx_k_startpix), 0, 0, 1, 1},
-  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-  {&__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_k_unknown_dtype_code_in_numpy_pxd, sizeof(__pyx_k_unknown_dtype_code_in_numpy_pxd), 0, 1, 0, 0},
+  {&__pyx_kp_u_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 1, 0, 0},
+  {&__pyx_kp_u_13, __pyx_k_13, sizeof(__pyx_k_13), 0, 1, 0, 0},
+  {&__pyx_kp_u_15, __pyx_k_15, sizeof(__pyx_k_15), 0, 1, 0, 0},
+  {&__pyx_kp_u_17, __pyx_k_17, sizeof(__pyx_k_17), 0, 1, 0, 0},
+  {&__pyx_kp_u_18, __pyx_k_18, sizeof(__pyx_k_18), 0, 1, 0, 0},
+  {&__pyx_kp_u_21, __pyx_k_21, sizeof(__pyx_k_21), 0, 1, 0, 0},
+  {&__pyx_n_s_23, __pyx_k_23, sizeof(__pyx_k_23), 0, 0, 1, 1},
+  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
+  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__dtype, __pyx_k__dtype, sizeof(__pyx_k__dtype), 0, 0, 1, 1},
+  {&__pyx_n_s__empty, __pyx_k__empty, sizeof(__pyx_k__empty), 0, 0, 1, 1},
+  {&__pyx_n_s__inclusive, __pyx_k__inclusive, sizeof(__pyx_k__inclusive), 0, 0, 1, 1},
+  {&__pyx_n_s__int64, __pyx_k__int64, sizeof(__pyx_k__int64), 0, 0, 1, 1},
+  {&__pyx_n_s__log2, __pyx_k__log2, sizeof(__pyx_k__log2), 0, 0, 1, 1},
+  {&__pyx_n_s__nest, __pyx_k__nest, sizeof(__pyx_k__nest), 0, 0, 1, 1},
+  {&__pyx_n_s__np, __pyx_k__np, sizeof(__pyx_k__np), 0, 0, 1, 1},
+  {&__pyx_n_s__nside, __pyx_k__nside, sizeof(__pyx_k__nside), 0, 0, 1, 1},
+  {&__pyx_n_s__numpy, __pyx_k__numpy, sizeof(__pyx_k__numpy), 0, 0, 1, 1},
+  {&__pyx_n_s__query_disc, __pyx_k__query_disc, sizeof(__pyx_k__query_disc), 0, 0, 1, 1},
+  {&__pyx_n_s__query_polygon, __pyx_k__query_polygon, sizeof(__pyx_k__query_polygon), 0, 0, 1, 1},
+  {&__pyx_n_s__query_strip, __pyx_k__query_strip, sizeof(__pyx_k__query_strip), 0, 0, 1, 1},
+  {&__pyx_n_s__radius, __pyx_k__radius, sizeof(__pyx_k__radius), 0, 0, 1, 1},
+  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
+  {&__pyx_n_s__round, __pyx_k__round, sizeof(__pyx_k__round), 0, 0, 1, 1},
+  {&__pyx_n_s__theta1, __pyx_k__theta1, sizeof(__pyx_k__theta1), 0, 0, 1, 1},
+  {&__pyx_n_s__theta2, __pyx_k__theta2, sizeof(__pyx_k__theta2), 0, 0, 1, 1},
+  {&__pyx_n_s__vec, __pyx_k__vec, sizeof(__pyx_k__vec), 0, 0, 1, 1},
+  {&__pyx_n_s__vertices, __pyx_k__vertices, sizeof(__pyx_k__vertices), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_round = __Pyx_GetBuiltinName(__pyx_n_s_round); if (!__pyx_builtin_round) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_range = __Pyx_GetName(__pyx_b, __pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_round = __Pyx_GetName(__pyx_b, __pyx_n_s__round); if (!__pyx_builtin_round) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants");
 
-  /* "healpy/src/_pixelfunc.pyx":45
- *     """
+  /* "healpy/src/_query_disc.pyx":134
+ *     # Check Nside value
  *     if not isnsideok(nside):
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')             # <<<<<<<<<<<<<<
- *     cdef Healpix_Ordering_Scheme scheme = NEST
- *     cdef T_Healpix_Base[int64] hb = T_Healpix_Base[int64](nside, scheme, SET_NSIDE)
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     cdef vec3 v = vec3(vec[0], vec[1], vec[2])
+ *     cdef Healpix_Ordering_Scheme scheme
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Wrong_nside_value_must_be_a_powe); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
+  __pyx_k_tuple_4 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_4));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
+  PyTuple_SET_ITEM(__pyx_k_tuple_4, 0, ((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));
 
-  /* "healpy/src/_pixelfunc.pyx":89
- * 
+  /* "healpy/src/_query_disc.pyx":179
+ *     # Check Nside value
+ *     if not isnsideok(nside):
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     # Create vector of vertices
+ *     cdef vector[pointing] vert
+ */
+  __pyx_k_tuple_7 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_7));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
+  PyTuple_SET_ITEM(__pyx_k_tuple_7, 0, ((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_7));
+
+  /* "healpy/src/_query_disc.pyx":226
+ *     # Check Nside value
  *     if not isnsideok(nside):
- *         raise ValueError('Wrong nside value, must be a power of 2, less than 2**30')             # <<<<<<<<<<<<<<
+ *         raise ValueError('Wrong nside value, must be a power of 2')             # <<<<<<<<<<<<<<
+ *     # Create the Healpix_Base2 structure
  *     cdef Healpix_Ordering_Scheme scheme
- *     if nest:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Wrong_nside_value_must_be_a_powe); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_k_tuple_10 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_10));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
+  PyTuple_SET_ITEM(__pyx_k_tuple_10, 0, ((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_10));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":215
+  /* "numpy.pxd":211
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_C_contiguous); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
+  __pyx_k_tuple_12 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_12)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_12));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_11));
+  PyTuple_SET_ITEM(__pyx_k_tuple_12, 0, ((PyObject *)__pyx_kp_u_11));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_11));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_12));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":219
+  /* "numpy.pxd":215
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_Fortran_contiguou); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
-
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":257
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+  __pyx_k_tuple_14 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_14)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_14));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_13));
+  PyTuple_SET_ITEM(__pyx_k_tuple_14, 0, ((PyObject *)__pyx_kp_u_13));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_13));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_14));
+
+  /* "numpy.pxd":253
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__5)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_k_tuple_16 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_16)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_16));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_15));
+  PyTuple_SET_ITEM(__pyx_k_tuple_16, 0, ((PyObject *)__pyx_kp_u_15));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_15));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_16));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":799
+  /* "numpy.pxd":795
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
+ *         if ((child.byteorder == '>' and little_endian) or
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor); if (unlikely(!__pyx_tuple__6)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
-
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":803
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):
+  __pyx_k_tuple_19 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_19)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_19));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_18));
+  PyTuple_SET_ITEM(__pyx_k_tuple_19, 0, ((PyObject *)__pyx_kp_u_18));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_18));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_19));
+
+  /* "numpy.pxd":799
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__7)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_k_tuple_20 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_20)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_20));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_15));
+  PyTuple_SET_ITEM(__pyx_k_tuple_20, 0, ((PyObject *)__pyx_kp_u_15));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_15));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_20));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":823
+  /* "numpy.pxd":819
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor_2); if (unlikely(!__pyx_tuple__8)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
-
-  /* "healpy/src/_pixelfunc.pyx":9
- * from _common cimport int64, Healpix_Ordering_Scheme, RING, NEST, SET_NSIDE, T_Healpix_Base
- * 
- * def ringinfo(nside, np.ndarray[int64, ndim=1] ring not None):             # <<<<<<<<<<<<<<
- *     """Get information for rings
- * 
- */
-  __pyx_tuple__9 = PyTuple_Pack(11, __pyx_n_s_nside, __pyx_n_s_ring, __pyx_n_s_scheme, __pyx_n_s_hb, __pyx_n_s_num, __pyx_n_s_startpix, __pyx_n_s_ringpix, __pyx_n_s_costheta, __pyx_n_s_sintheta, __pyx_n_s_shifted, __pyx_n_s_i); if (unlikely(!__pyx_tuple__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
-  __pyx_codeobj__10 = (PyObject*)__Pyx_PyCode_New(2, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__9, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__p, __pyx_n_s_ringinfo, 9, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_pixelfunc.pyx":58
- *     return startpix, ringpix, costheta, sintheta, shifted
- * 
- * def pix2ring(nside, np.ndarray[int64, ndim=1] pix not None, nest=False):             # <<<<<<<<<<<<<<
- *     """Convert pixel identifier to ring number
- * 
- */
-  __pyx_tuple__11 = PyTuple_Pack(8, __pyx_n_s_nside, __pyx_n_s_pix, __pyx_n_s_nest, __pyx_n_s_scheme, __pyx_n_s_hb, __pyx_n_s_num, __pyx_n_s_ring, __pyx_n_s_i); if (unlikely(!__pyx_tuple__11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
-  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__11, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__p, __pyx_n_s_pix2ring, 58, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_k_tuple_22 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_22)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_22));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_21));
+  PyTuple_SET_ITEM(__pyx_k_tuple_22, 0, ((PyObject *)__pyx_kp_u_21));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_21));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_22));
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 #if PY_MAJOR_VERSION < 3
-PyMODINIT_FUNC init_pixelfunc(void); /*proto*/
-PyMODINIT_FUNC init_pixelfunc(void)
+PyMODINIT_FUNC init_query_disc(void); /*proto*/
+PyMODINIT_FUNC init_query_disc(void)
 #else
-PyMODINIT_FUNC PyInit__pixelfunc(void); /*proto*/
-PyMODINIT_FUNC PyInit__pixelfunc(void)
+PyMODINIT_FUNC PyInit__query_disc(void); /*proto*/
+PyMODINIT_FUNC PyInit__query_disc(void)
 #endif
 {
   PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_REFNANNY
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
   if (!__Pyx_RefNanny) {
       PyErr_Clear();
       __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
       if (!__Pyx_RefNanny)
           Py_FatalError("failed to import 'refnanny' module");
   }
   #endif
-  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__pixelfunc(void)", 0);
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__query_disc(void)");
   if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #ifdef __Pyx_CyFunction_USED
-  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
-  #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __pyx_binding_PyCFunctionType_USED
+  if (__pyx_binding_PyCFunctionType_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   #ifdef WITH_THREAD /* Python build with threading support? */
   PyEval_InitThreads();
   #endif
   #endif
   /*--- Module creation code ---*/
   #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_pixelfunc"), __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_query_disc"), __pyx_methods, 0, 0, PYTHON_API_VERSION);
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   #endif
-  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #if CYTHON_COMPILING_IN_PYPY
-  Py_INCREF(__pyx_b);
+  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  #if PY_MAJOR_VERSION < 3
+  Py_INCREF(__pyx_m);
   #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
+  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   /*--- Initialize various global constants etc. ---*/
   if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
-  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
-  if (__pyx_module_is_main_healpy___pixelfunc) {
-    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  if (__pyx_module_is_main_healpy___query_disc) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   }
-  #if PY_MAJOR_VERSION >= 3
-  {
-    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (!PyDict_GetItemString(modules, "healpy._pixelfunc")) {
-      if (unlikely(PyDict_SetItemString(modules, "healpy._pixelfunc", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-  }
-  #endif
   /*--- Builtin init code ---*/
   if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Constants init code ---*/
   if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Global init code ---*/
   /*--- Variable export code ---*/
   /*--- Function export code ---*/
   /*--- Type init code ---*/
   /*--- Type import code ---*/
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
-  #if CYTHON_COMPILING_IN_PYPY
-  sizeof(PyTypeObject),
-  #else
-  sizeof(PyHeapTypeObject),
-  #endif
-  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Variable import code ---*/
   /*--- Function import code ---*/
   /*--- Execution code ---*/
 
-  /* "healpy/src/_pixelfunc.pyx":3
- * # Wrapper around the geometry methods in Healpix_base class
+  /* "healpy/src/_query_disc.pyx":3
+ * # Wrapper around the query_disc method of Healpix_base class
  * 
  * import numpy as np             # <<<<<<<<<<<<<<
  * cimport numpy as np
  * from libcpp cimport bool
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__numpy), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__np, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_pixelfunc.pyx":9
- * from _common cimport int64, Healpix_Ordering_Scheme, RING, NEST, SET_NSIDE, T_Healpix_Base
+  /* "healpy/src/_query_disc.pyx":102
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def query_disc(nside, vec, radius, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """Returns pixels whose centers lie within the disk defined by
+ *     *vec* and *radius* (in radians) (if *inclusive* is False), or which
+ */
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_1 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_2 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_11_query_disc_query_disc, NULL, __pyx_n_s_23); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__query_disc, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "healpy/src/_query_disc.pyx":149
  * 
- * def ringinfo(nside, np.ndarray[int64, ndim=1] ring not None):             # <<<<<<<<<<<<<<
- *     """Get information for rings
  * 
+ * def query_polygon(nside, vertices, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """ Returns the pixels whose centers lie within the convex polygon
+ *     defined by the *vertices* array (if *inclusive* is False), or which
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_10_pixelfunc_1ringinfo, NULL, __pyx_n_s_healpy__pixelfunc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_5 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ringinfo, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_k_6 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_11_query_disc_1query_polygon, NULL, __pyx_n_s_23); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__query_polygon, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_pixelfunc.pyx":58
- *     return startpix, ringpix, costheta, sintheta, shifted
- * 
- * def pix2ring(nside, np.ndarray[int64, ndim=1] pix not None, nest=False):             # <<<<<<<<<<<<<<
- *     """Convert pixel identifier to ring number
+  /* "healpy/src/_query_disc.pyx":197
+ *     return pixset_to_array(pixset)
  * 
+ * def query_strip(nside, theta1, theta2, inclusive = False, nest = False):             # <<<<<<<<<<<<<<
+ *     """Returns pixels whose centers lie within the colatitude range
+ *     defined by *theta1* and *theta2* (if inclusive is False), or which
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_10_pixelfunc_3pix2ring, NULL, __pyx_n_s_healpy__pixelfunc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pix2ring, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_k_8 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_9 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_11_query_disc_2query_strip, NULL, __pyx_n_s_23); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__query_strip, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_pixelfunc.pyx":1
- * # Wrapper around the geometry methods in Healpix_base class             # <<<<<<<<<<<<<<
+  /* "healpy/src/_query_disc.pyx":1
+ * # Wrapper around the query_disc method of Healpix_base class             # <<<<<<<<<<<<<<
  * 
  * import numpy as np
  */
   __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_ringinfo_line_9, __pyx_kp_u_Get_information_for_rings_Rings) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_pix2ring_line_58, __pyx_kp_u_Convert_pixel_identifier_to_ring) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
+  /* "numpy.pxd":971
  *      arr.base = baseptr
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     if arr.base is NULL:
  *         return None
  */
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   if (__pyx_m) {
-    __Pyx_AddTraceback("init healpy._pixelfunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    __Pyx_AddTraceback("init healpy._query_disc", __pyx_clineno, __pyx_lineno, __pyx_filename);
     Py_DECREF(__pyx_m); __pyx_m = 0;
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init healpy._pixelfunc");
+    PyErr_SetString(PyExc_ImportError, "init healpy._query_disc");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if PY_MAJOR_VERSION < 3
   return;
   #else
   return __pyx_m;
   #endif
 }
 
 /* Runtime support code */
+
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
     m = PyImport_ImportModule((char *)modname);
     if (!m) goto end;
     p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
@@ -5010,62 +4483,65 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif /* CYTHON_REFNANNY */
 
-static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
-    if (unlikely(!result)) {
-        PyErr_Format(PyExc_NameError,
-#if PY_MAJOR_VERSION >= 3
-            "name '%U' is not defined", name);
-#else
-            "name '%.200s' is not defined", PyString_AS_STRING(name));
-#endif
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
+    PyObject *result;
+    result = PyObject_GetAttr(dict, name);
+    if (!result) {
+        if (dict != __pyx_b) {
+            PyErr_Clear();
+            result = PyObject_GetAttr(__pyx_b, name);
+        }
+        if (!result) {
+            PyErr_SetObject(PyExc_NameError, name);
+        }
     }
     return result;
 }
 
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
     Py_ssize_t num_found)
 {
     Py_ssize_t num_expected;
     const char *more_or_less;
+
     if (num_found < num_min) {
         num_expected = num_min;
         more_or_less = "at least";
     } else {
         num_expected = num_max;
         more_or_less = "at most";
     }
     if (exact) {
         more_or_less = "exactly";
     }
     PyErr_Format(PyExc_TypeError,
-                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 "%s() takes %s %"PY_FORMAT_SIZE_T"d positional argument%s (%"PY_FORMAT_SIZE_T"d given)",
                  func_name, more_or_less, num_expected,
                  (num_expected == 1) ? "" : "s", num_found);
 }
 
 static void __Pyx_RaiseDoubleKeywordsError(
     const char* func_name,
     PyObject* kw_name)
 {
     PyErr_Format(PyExc_TypeError,
         #if PY_MAJOR_VERSION >= 3
         "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
         #else
         "%s() got multiple values for keyword argument '%s'", func_name,
-        PyString_AsString(kw_name));
+        PyString_AS_STRING(kw_name));
         #endif
 }
 
 static int __Pyx_ParseOptionalKeywords(
     PyObject *kwds,
     PyObject **argnames[],
     PyObject *kwds2,
@@ -5073,133 +4549,271 @@
     Py_ssize_t num_pos_args,
     const char* function_name)
 {
     PyObject *key = 0, *value = 0;
     Py_ssize_t pos = 0;
     PyObject*** name;
     PyObject*** first_kw_arg = argnames + num_pos_args;
+
     while (PyDict_Next(kwds, &pos, &key, &value)) {
         name = first_kw_arg;
         while (*name && (**name != key)) name++;
         if (*name) {
             values[name-argnames] = value;
-            continue;
-        }
-        name = first_kw_arg;
-        #if PY_MAJOR_VERSION < 3
-        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
-            while (*name) {
-                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
-                        && _PyString_Eq(**name, key)) {
-                    values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    if ((**argname == key) || (
-                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
-                             && _PyString_Eq(**argname, key))) {
-                        goto arg_passed_twice;
-                    }
-                    argname++;
+        } else {
+            #if PY_MAJOR_VERSION < 3
+            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
+            #else
+            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
+            #endif
+                goto invalid_keyword_type;
+            } else {
+                for (name = first_kw_arg; *name; name++) {
+                    #if PY_MAJOR_VERSION >= 3
+                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                        PyUnicode_Compare(**name, key) == 0) break;
+                    #else
+                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                        _PyString_Eq(**name, key)) break;
+                    #endif
                 }
-            }
-        } else
-        #endif
-        if (likely(PyUnicode_Check(key))) {
-            while (*name) {
-                int cmp = (**name == key) ? 0 :
-                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
-                #endif
-                    PyUnicode_Compare(**name, key);
-                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                if (cmp == 0) {
+                if (*name) {
                     values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    int cmp = (**argname == key) ? 0 :
-                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
-                    #endif
-                        PyUnicode_Compare(**argname, key);
-                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                    if (cmp == 0) goto arg_passed_twice;
-                    argname++;
+                } else {
+                    /* unexpected keyword found */
+                    for (name=argnames; name != first_kw_arg; name++) {
+                        if (**name == key) goto arg_passed_twice;
+                        #if PY_MAJOR_VERSION >= 3
+                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
+                        #else
+                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                            _PyString_Eq(**name, key)) goto arg_passed_twice;
+                        #endif
+                    }
+                    if (kwds2) {
+                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+                    } else {
+                        goto invalid_keyword;
+                    }
                 }
             }
-        } else
-            goto invalid_keyword_type;
-        if (kwds2) {
-            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
-        } else {
-            goto invalid_keyword;
         }
     }
     return 0;
 arg_passed_twice:
-    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
     goto bad;
 invalid_keyword_type:
     PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
+        "%s() keywords must be strings", function_name);
     goto bad;
 invalid_keyword:
     PyErr_Format(PyExc_TypeError,
     #if PY_MAJOR_VERSION < 3
-        "%.200s() got an unexpected keyword argument '%.200s'",
+        "%s() got an unexpected keyword argument '%s'",
         function_name, PyString_AsString(key));
     #else
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
     return -1;
 }
 
-static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
-    PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
-        name, type->tp_name, Py_TYPE(obj)->tp_name);
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
 }
-static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
-    const char *name, int exact)
-{
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
+
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    /* cause is unused */
+    Py_XINCREF(type);
+    Py_XINCREF(value);
+    Py_XINCREF(tb);
+    /* First, check the traceback argument, replacing None with NULL. */
+    if (tb == Py_None) {
+        Py_DECREF(tb);
+        tb = 0;
+    }
+    else if (tb != NULL && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto raise_error;
+    }
+    /* Next, replace a missing value with None */
+    if (value == NULL) {
+        value = Py_None;
+        Py_INCREF(value);
     }
-    if (none_allowed && obj == Py_None) return 1;
-    else if (exact) {
-        if (likely(Py_TYPE(obj) == type)) return 1;
-        #if PY_MAJOR_VERSION == 2
-        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
+    #if PY_VERSION_HEX < 0x02050000
+    if (!PyClass_Check(type))
+    #else
+    if (!PyType_Check(type))
+    #endif
+    {
+        /* Raising an instance.  The value should be a dummy. */
+        if (value != Py_None) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        /* Normalize to raise <class>, <instance> */
+        Py_DECREF(value);
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+            if (PyInstance_Check(type)) {
+                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+                Py_INCREF(type);
+            }
+            else {
+                type = 0;
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception must be an old-style class or instance");
+                goto raise_error;
+            }
+        #else
+            type = (PyObject*) Py_TYPE(type);
+            Py_INCREF(type);
+            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception class must be a subclass of BaseException");
+                goto raise_error;
+            }
         #endif
     }
-    else {
-        if (likely(PyObject_TypeCheck(obj, type))) return 1;
+
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+
+#else /* Python 3+ */
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (!PyExceptionClass_Check(type)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+
+    if (cause) {
+        PyObject *fixed_cause;
+        if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        }
+        else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        }
+        else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        if (!value) {
+            value = PyObject_CallObject(type, NULL);
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+
+    PyErr_SetObject(type, value);
+
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
     }
-    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
+
+bad:
+    return;
+}
+#endif
+
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(PyObject_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
 }
 
 static CYTHON_INLINE int __Pyx_IsLittleEndian(void) {
   unsigned int n = 1;
   return *(unsigned char*)(&n) != 0;
 }
+
+typedef struct {
+  __Pyx_StructField root;
+  __Pyx_BufFmt_StackElem* head;
+  size_t fmt_offset;
+  size_t new_count, enc_count;
+  int is_complex;
+  char enc_type;
+  char new_packmode;
+  char enc_packmode;
+} __Pyx_BufFmt_Context;
+
 static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
                               __Pyx_BufFmt_StackElem* stack,
                               __Pyx_TypeInfo* type) {
   stack[0].field = &ctx->root;
   stack[0].parent_offset = 0;
   ctx->root.type = type;
   ctx->root.name = "buffer dtype";
@@ -5210,23 +4824,22 @@
   ctx->head->parent_offset = 0;
   ctx->new_packmode = '@';
   ctx->enc_packmode = '@';
   ctx->new_count = 1;
   ctx->enc_count = 0;
   ctx->enc_type = 0;
   ctx->is_complex = 0;
-  ctx->is_valid_array = 0;
-  ctx->struct_alignment = 0;
   while (type->typegroup == 'S') {
     ++ctx->head;
     ctx->head->field = type->fields;
     ctx->head->parent_offset = 0;
     type = type->fields->type;
   }
 }
+
 static int __Pyx_BufFmt_ParseNumber(const char** ts) {
     int count;
     const char* t = *ts;
     if (*t < '0' || *t > '9') {
       return -1;
     } else {
         count = *t++ - '0';
@@ -5234,29 +4847,23 @@
             count *= 10;
             count += *t++ - '0';
         }
     }
     *ts = t;
     return count;
 }
-static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
-    int number = __Pyx_BufFmt_ParseNumber(ts);
-    if (number == -1) /* First char was not a digit */
-        PyErr_Format(PyExc_ValueError,\
-                     "Does not understand character buffer dtype format string ('%c')", **ts);
-    return number;
-}
+
 static void __Pyx_BufFmt_RaiseUnexpectedChar(char ch) {
   PyErr_Format(PyExc_ValueError,
                "Unexpected format string character: '%c'", ch);
 }
+
 static const char* __Pyx_BufFmt_DescribeTypeChar(char ch, int is_complex) {
   switch (ch) {
-    case 'c': return "'char'";
-    case 'b': return "'signed char'";
+    case 'b': return "'char'";
     case 'B': return "'unsigned char'";
     case 'h': return "'short'";
     case 'H': return "'unsigned short'";
     case 'i': return "'int'";
     case 'I': return "'unsigned int'";
     case 'l': return "'long'";
     case 'L': return "'unsigned long'";
@@ -5264,22 +4871,22 @@
     case 'Q': return "'unsigned long long'";
     case 'f': return (is_complex ? "'complex float'" : "'float'");
     case 'd': return (is_complex ? "'complex double'" : "'double'");
     case 'g': return (is_complex ? "'complex long double'" : "'long double'");
     case 'T': return "a struct";
     case 'O': return "Python object";
     case 'P': return "a pointer";
-    case 's': case 'p': return "a string";
     case 0: return "end";
     default: return "unparseable format string";
   }
 }
+
 static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
   switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case '?': case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return 2;
     case 'i': case 'I': case 'l': case 'L': return 4;
     case 'q': case 'Q': return 8;
     case 'f': return (is_complex ? 8 : 4);
     case 'd': return (is_complex ? 16 : 8);
     case 'g': {
       PyErr_SetString(PyExc_ValueError, "Python does not define a standard format string size for long double ('g')..");
@@ -5287,17 +4894,18 @@
     }
     case 'O': case 'P': return sizeof(void*);
     default:
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
 }
+
 static size_t __Pyx_BufFmt_TypeCharToNativeSize(char ch, int is_complex) {
   switch (ch) {
-    case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return sizeof(short);
     case 'i': case 'I': return sizeof(int);
     case 'l': case 'L': return sizeof(long);
     #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(PY_LONG_LONG);
     #endif
     case 'f': return sizeof(float) * (is_complex ? 2 : 1);
@@ -5306,27 +4914,29 @@
     case 'O': case 'P': return sizeof(void*);
     default: {
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
   }
 }
+
 typedef struct { char c; short x; } __Pyx_st_short;
 typedef struct { char c; int x; } __Pyx_st_int;
 typedef struct { char c; long x; } __Pyx_st_long;
 typedef struct { char c; float x; } __Pyx_st_float;
 typedef struct { char c; double x; } __Pyx_st_double;
 typedef struct { char c; long double x; } __Pyx_st_longdouble;
 typedef struct { char c; void *x; } __Pyx_st_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, CYTHON_UNUSED int is_complex) {
+
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
   switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case '?': case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
 #endif
     case 'f': return sizeof(__Pyx_st_float) - sizeof(float);
@@ -5334,67 +4944,29 @@
     case 'g': return sizeof(__Pyx_st_longdouble) - sizeof(long double);
     case 'P': case 'O': return sizeof(__Pyx_st_void_p) - sizeof(void*);
     default:
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
 }
-/* These are for computing the padding at the end of the struct to align
-   on the first member of the struct. This will probably the same as above,
-   but we don't have any guarantees.
- */
-typedef struct { short x; char c; } __Pyx_pad_short;
-typedef struct { int x; char c; } __Pyx_pad_int;
-typedef struct { long x; char c; } __Pyx_pad_long;
-typedef struct { float x; char c; } __Pyx_pad_float;
-typedef struct { double x; char c; } __Pyx_pad_double;
-typedef struct { long double x; char c; } __Pyx_pad_longdouble;
-typedef struct { void *x; char c; } __Pyx_pad_void_p;
-#ifdef HAVE_LONG_LONG
-typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
-#endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, CYTHON_UNUSED int is_complex) {
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
-    case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
-    case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
-#ifdef HAVE_LONG_LONG
-    case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
-#endif
-    case 'f': return sizeof(__Pyx_pad_float) - sizeof(float);
-    case 'd': return sizeof(__Pyx_pad_double) - sizeof(double);
-    case 'g': return sizeof(__Pyx_pad_longdouble) - sizeof(long double);
-    case 'P': case 'O': return sizeof(__Pyx_pad_void_p) - sizeof(void*);
-    default:
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-}
+
 static char __Pyx_BufFmt_TypeCharToGroup(char ch, int is_complex) {
   switch (ch) {
-    case 'c':
-        return 'H';
-    case 'b': case 'h': case 'i':
-    case 'l': case 'q': case 's': case 'p':
-        return 'I';
-    case 'B': case 'H': case 'I': case 'L': case 'Q':
-        return 'U';
-    case 'f': case 'd': case 'g':
-        return (is_complex ? 'C' : 'R');
-    case 'O':
-        return 'O';
-    case 'P':
-        return 'P';
+    case 'c': case 'b': case 'h': case 'i': case 'l': case 'q': return 'I';
+    case 'B': case 'H': case 'I': case 'L': case 'Q': return 'U';
+    case 'f': case 'd': case 'g': return (is_complex ? 'C' : 'R');
+    case 'O': return 'O';
+    case 'P': return 'P';
     default: {
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
   }
 }
+
 static void __Pyx_BufFmt_RaiseExpected(__Pyx_BufFmt_Context* ctx) {
   if (ctx->head == NULL || ctx->head->field == &ctx->root) {
     const char* expected;
     const char* quote;
     if (ctx->head == NULL) {
       expected = "end";
       quote = "";
@@ -5411,85 +4983,64 @@
     __Pyx_StructField* parent = (ctx->head - 1)->field;
     PyErr_Format(PyExc_ValueError,
                  "Buffer dtype mismatch, expected '%s' but got %s in '%s.%s'",
                  field->type->name, __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex),
                  parent->type->name, field->name);
   }
 }
+
 static int __Pyx_BufFmt_ProcessTypeChunk(__Pyx_BufFmt_Context* ctx) {
   char group;
-  size_t size, offset, arraysize = 1;
+  size_t size, offset;
   if (ctx->enc_type == 0) return 0;
-  if (ctx->head->field->type->arraysize[0]) {
-    int i, ndim = 0;
-    if (ctx->enc_type == 's' || ctx->enc_type == 'p') {
-        ctx->is_valid_array = ctx->head->field->type->ndim == 1;
-        ndim = 1;
-        if (ctx->enc_count != ctx->head->field->type->arraysize[0]) {
-            PyErr_Format(PyExc_ValueError,
-                         "Expected a dimension of size %zu, got %zu",
-                         ctx->head->field->type->arraysize[0], ctx->enc_count);
-            return -1;
-        }
-    }
-    if (!ctx->is_valid_array) {
-      PyErr_Format(PyExc_ValueError, "Expected %d dimensions, got %d",
-                   ctx->head->field->type->ndim, ndim);
-      return -1;
-    }
-    for (i = 0; i < ctx->head->field->type->ndim; i++) {
-      arraysize *= ctx->head->field->type->arraysize[i];
-    }
-    ctx->is_valid_array = 0;
-    ctx->enc_count = 1;
-  }
   group = __Pyx_BufFmt_TypeCharToGroup(ctx->enc_type, ctx->is_complex);
   do {
     __Pyx_StructField* field = ctx->head->field;
     __Pyx_TypeInfo* type = field->type;
+
     if (ctx->enc_packmode == '@' || ctx->enc_packmode == '^') {
       size = __Pyx_BufFmt_TypeCharToNativeSize(ctx->enc_type, ctx->is_complex);
     } else {
       size = __Pyx_BufFmt_TypeCharToStandardSize(ctx->enc_type, ctx->is_complex);
     }
     if (ctx->enc_packmode == '@') {
       size_t align_at = __Pyx_BufFmt_TypeCharToAlignment(ctx->enc_type, ctx->is_complex);
       size_t align_mod_offset;
       if (align_at == 0) return -1;
       align_mod_offset = ctx->fmt_offset % align_at;
       if (align_mod_offset > 0) ctx->fmt_offset += align_at - align_mod_offset;
-      if (ctx->struct_alignment == 0)
-          ctx->struct_alignment = __Pyx_BufFmt_TypeCharToPadding(ctx->enc_type,
-                                                                 ctx->is_complex);
     }
+
     if (type->size != size || type->typegroup != group) {
       if (type->typegroup == 'C' && type->fields != NULL) {
+        /* special case -- treat as struct rather than complex number */
         size_t parent_offset = ctx->head->parent_offset + field->offset;
         ++ctx->head;
         ctx->head->field = type->fields;
         ctx->head->parent_offset = parent_offset;
         continue;
       }
-      if ((type->typegroup == 'H' || group == 'H') && type->size == size) {
-      } else {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return -1;
-      }
+
+      __Pyx_BufFmt_RaiseExpected(ctx);
+      return -1;
     }
+
     offset = ctx->head->parent_offset + field->offset;
     if (ctx->fmt_offset != offset) {
       PyErr_Format(PyExc_ValueError,
-                   "Buffer dtype mismatch; next field is at offset %" CYTHON_FORMAT_SSIZE_T "d but %" CYTHON_FORMAT_SSIZE_T "d expected",
+                   "Buffer dtype mismatch; next field is at offset %"PY_FORMAT_SIZE_T"d but %"PY_FORMAT_SIZE_T"d expected",
                    (Py_ssize_t)ctx->fmt_offset, (Py_ssize_t)offset);
       return -1;
     }
+
     ctx->fmt_offset += size;
-    if (arraysize)
-      ctx->fmt_offset += (arraysize - 1) * size;
+
     --ctx->enc_count; /* Consume from buffer string */
+
+    /* Done checking, move to next field, pushing or popping struct stack if needed */
     while (1) {
       if (field == &ctx->root) {
         ctx->head = NULL;
         if (ctx->enc_count != 0) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return -1;
         }
@@ -5513,71 +5064,30 @@
       }
     }
   } while (ctx->enc_count);
   ctx->enc_type = 0;
   ctx->is_complex = 0;
   return 0;
 }
-static CYTHON_INLINE PyObject *
-__pyx_buffmt_parse_array(__Pyx_BufFmt_Context* ctx, const char** tsp)
-{
-    const char *ts = *tsp;
-    int i = 0, number;
-    int ndim = ctx->head->field->type->ndim;
-;
-    ++ts;
-    if (ctx->new_count != 1) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Cannot handle repeated arrays in format string");
-        return NULL;
-    }
-    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-    while (*ts && *ts != ')') {
-        if (isspace(*ts))
-            continue;
-        number = __Pyx_BufFmt_ExpectNumber(&ts);
-        if (number == -1) return NULL;
-        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i])
-            return PyErr_Format(PyExc_ValueError,
-                        "Expected a dimension of size %zu, got %d",
-                        ctx->head->field->type->arraysize[i], number);
-        if (*ts != ',' && *ts != ')')
-            return PyErr_Format(PyExc_ValueError,
-                                "Expected a comma in format string, got '%c'", *ts);
-        if (*ts == ',') ts++;
-        i++;
-    }
-    if (i != ndim)
-        return PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
-                            ctx->head->field->type->ndim, i);
-    if (!*ts) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Unexpected end of format string, expected ')'");
-        return NULL;
-    }
-    ctx->is_valid_array = 1;
-    ctx->new_count = 1;
-    *tsp = ++ts;
-    return Py_None;
-}
+
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
   int got_Z = 0;
   while (1) {
     switch(*ts) {
       case 0:
         if (ctx->enc_type != 0 && ctx->head == NULL) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return NULL;
         }
         if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
         if (ctx->head != NULL) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return NULL;
         }
-                return ts;
+        return ts;
       case ' ':
       case 10:
       case 13:
         ++ts;
         break;
       case '<':
         if (!__Pyx_IsLittleEndian()) {
@@ -5601,45 +5111,31 @@
       case '^':
         ctx->new_packmode = *ts++;
         break;
       case 'T': /* substruct */
         {
           const char* ts_after_sub;
           size_t i, struct_count = ctx->new_count;
-          size_t struct_alignment = ctx->struct_alignment;
           ctx->new_count = 1;
           ++ts;
           if (*ts != '{') {
             PyErr_SetString(PyExc_ValueError, "Buffer acquisition: Expected '{' after 'T'");
             return NULL;
           }
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0; /* Erase processed last struct element */
-          ctx->enc_count = 0;
-          ctx->struct_alignment = 0;
           ++ts;
           ts_after_sub = ts;
           for (i = 0; i != struct_count; ++i) {
             ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);
             if (!ts_after_sub) return NULL;
           }
           ts = ts_after_sub;
-          if (struct_alignment) ctx->struct_alignment = struct_alignment;
         }
         break;
       case '}': /* end of substruct; either repeat or move on */
-        {
-          size_t alignment = ctx->struct_alignment;
-          ++ts;
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0; /* Erase processed last struct element */
-          if (alignment && ctx->fmt_offset % alignment) {
-            ctx->fmt_offset += alignment - (ctx->fmt_offset % alignment);
-          }
-        }
+        ++ts;
         return ts;
       case 'x':
         if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
         ctx->fmt_offset += ctx->new_count;
         ctx->new_count = 1;
         ctx->enc_count = 0;
         ctx->enc_type = 0;
@@ -5652,19 +5148,21 @@
         if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
           __Pyx_BufFmt_RaiseUnexpectedChar('Z');
           return NULL;
         }        /* fall through */
       case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
       case 'l': case 'L': case 'q': case 'Q':
       case 'f': case 'd': case 'g':
-      case 'O': case 's': case 'p':
+      case 'O':
         if (ctx->enc_type == *ts && got_Z == ctx->is_complex &&
             ctx->enc_packmode == ctx->new_packmode) {
+          /* Continue pooling same type */
           ctx->enc_count += ctx->new_count;
         } else {
+          /* New type */
           if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
           ctx->enc_count = ctx->new_count;
           ctx->enc_packmode = ctx->new_packmode;
           ctx->enc_type = *ts;
           ctx->is_complex = got_Z;
         }
         ++ts;
@@ -5672,37 +5170,37 @@
         got_Z = 0;
         break;
       case ':':
         ++ts;
         while(*ts != ':') ++ts;
         ++ts;
         break;
-      case '(':
-        if (!__pyx_buffmt_parse_array(ctx, &ts)) return NULL;
-        break;
       default:
         {
-          int number = __Pyx_BufFmt_ExpectNumber(&ts);
-          if (number == -1) return NULL;
-          ctx->new_count = (size_t)number;
+          int number = __Pyx_BufFmt_ParseNumber(&ts);
+          if (number == -1) { /* First char was not a digit */
+            PyErr_Format(PyExc_ValueError,
+                         "Does not understand character buffer dtype format string ('%c')", *ts);
+            return NULL;
+          }
+          ctx->new_count = (size_t)number; 
         }
     }
   }
 }
+
 static CYTHON_INLINE void __Pyx_ZeroBuffer(Py_buffer* buf) {
   buf->buf = NULL;
   buf->obj = NULL;
   buf->strides = __Pyx_zeros;
   buf->shape = __Pyx_zeros;
   buf->suboffsets = __Pyx_minusones;
 }
-static CYTHON_INLINE int __Pyx_GetBufferAndValidate(
-        Py_buffer* buf, PyObject* obj,  __Pyx_TypeInfo* dtype, int flags,
-        int nd, int cast, __Pyx_BufFmt_StackElem* stack)
-{
+
+static CYTHON_INLINE int __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack) {
   if (obj == Py_None || obj == NULL) {
     __Pyx_ZeroBuffer(buf);
     return 0;
   }
   buf->buf = NULL;
   if (__Pyx_GetBuffer(obj, buf, flags) == -1) goto fail;
   if (buf->ndim != nd) {
@@ -5714,380 +5212,98 @@
   if (!cast) {
     __Pyx_BufFmt_Context ctx;
     __Pyx_BufFmt_Init(&ctx, stack, dtype);
     if (!__Pyx_BufFmt_CheckString(&ctx, buf->format)) goto fail;
   }
   if ((unsigned)buf->itemsize != dtype->size) {
     PyErr_Format(PyExc_ValueError,
-      "Item size of buffer (%" CYTHON_FORMAT_SSIZE_T "d byte%s) does not match size of '%s' (%" CYTHON_FORMAT_SSIZE_T "d byte%s)",
+      "Item size of buffer (%"PY_FORMAT_SIZE_T"d byte%s) does not match size of '%s' (%"PY_FORMAT_SIZE_T"d byte%s)",
       buf->itemsize, (buf->itemsize > 1) ? "s" : "",
       dtype->name, (Py_ssize_t)dtype->size, (dtype->size > 1) ? "s" : "");
     goto fail;
   }
   if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
   return 0;
 fail:;
   __Pyx_ZeroBuffer(buf);
   return -1;
 }
+
 static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info) {
   if (info->buf == NULL) return;
   if (info->suboffsets == __Pyx_minusones) info->suboffsets = NULL;
   __Pyx_ReleaseBuffer(info);
 }
-
-static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    PyThreadState *tstate = PyThreadState_GET();
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#else
-    PyErr_Restore(type, value, tb);
-#endif
-}
-static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    PyThreadState *tstate = PyThreadState_GET();
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-#else
-    PyErr_Fetch(type, value, tb);
-#endif
-}
-
-#if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
-                        CYTHON_UNUSED PyObject *cause) {
-    Py_XINCREF(type);
-    if (!value || value == Py_None)
-        value = NULL;
-    else
-        Py_INCREF(value);
-    if (!tb || tb == Py_None)
-        tb = NULL;
-    else {
-        Py_INCREF(tb);
-        if (!PyTraceBack_Check(tb)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: arg 3 must be a traceback or None");
-            goto raise_error;
-        }
-    }
-    #if PY_VERSION_HEX < 0x02050000
-    if (PyClass_Check(type)) {
-    #else
-    if (PyType_Check(type)) {
-    #endif
-#if CYTHON_COMPILING_IN_PYPY
-        if (!value) {
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-#endif
-        PyErr_NormalizeException(&type, &value, &tb);
-    } else {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto raise_error;
-        }
-        value = type;
-        #if PY_VERSION_HEX < 0x02050000
-        if (PyInstance_Check(type)) {
-            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
-            Py_INCREF(type);
-        } else {
-            type = 0;
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception must be an old-style class or instance");
-            goto raise_error;
-        }
-        #else
-        type = (PyObject*) Py_TYPE(type);
-        Py_INCREF(type);
-        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception class must be a subclass of BaseException");
-            goto raise_error;
-        }
-        #endif
-    }
-    __Pyx_ErrRestore(type, value, tb);
-    return;
-raise_error:
-    Py_XDECREF(value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-    return;
-}
-#else /* Python 3+ */
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
-    PyObject* owned_instance = NULL;
-    if (tb == Py_None) {
-        tb = 0;
-    } else if (tb && !PyTraceBack_Check(tb)) {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: arg 3 must be a traceback or None");
-        goto bad;
-    }
-    if (value == Py_None)
-        value = 0;
-    if (PyExceptionInstance_Check(type)) {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto bad;
-        }
-        value = type;
-        type = (PyObject*) Py_TYPE(value);
-    } else if (PyExceptionClass_Check(type)) {
-        PyObject *instance_class = NULL;
-        if (value && PyExceptionInstance_Check(value)) {
-            instance_class = (PyObject*) Py_TYPE(value);
-            if (instance_class != type) {
-                if (PyObject_IsSubclass(instance_class, type)) {
-                    type = instance_class;
-                } else {
-                    instance_class = NULL;
-                }
-            }
-        }
-        if (!instance_class) {
-            PyObject *args;
-            if (!value)
-                args = PyTuple_New(0);
-            else if (PyTuple_Check(value)) {
-                Py_INCREF(value);
-                args = value;
-            } else
-                args = PyTuple_Pack(1, value);
-            if (!args)
-                goto bad;
-            owned_instance = PyObject_Call(type, args, NULL);
-            Py_DECREF(args);
-            if (!owned_instance)
-                goto bad;
-            value = owned_instance;
-            if (!PyExceptionInstance_Check(value)) {
-                PyErr_Format(PyExc_TypeError,
-                             "calling %R should have returned an instance of "
-                             "BaseException, not %R",
-                             type, Py_TYPE(value));
-                goto bad;
-            }
-        }
-    } else {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: exception class must be a subclass of BaseException");
-        goto bad;
-    }
-#if PY_VERSION_HEX >= 0x03030000
-    if (cause) {
-#else
-    if (cause && cause != Py_None) {
-#endif
-        PyObject *fixed_cause;
-        if (cause == Py_None) {
-            fixed_cause = NULL;
-        } else if (PyExceptionClass_Check(cause)) {
-            fixed_cause = PyObject_CallObject(cause, NULL);
-            if (fixed_cause == NULL)
-                goto bad;
-        } else if (PyExceptionInstance_Check(cause)) {
-            fixed_cause = cause;
-            Py_INCREF(fixed_cause);
-        } else {
-            PyErr_SetString(PyExc_TypeError,
-                            "exception causes must derive from "
-                            "BaseException");
-            goto bad;
-        }
-        PyException_SetCause(value, fixed_cause);
-    }
-    PyErr_SetObject(type, value);
-    if (tb) {
-        PyThreadState *tstate = PyThreadState_GET();
-        PyObject* tmp_tb = tstate->curexc_traceback;
-        if (tb != tmp_tb) {
-            Py_INCREF(tb);
-            tstate->curexc_traceback = tb;
-            Py_XDECREF(tmp_tb);
-        }
-    }
-bad:
-    Py_XDECREF(owned_instance);
-    return;
-}
-#endif
-
-static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
-    PyObject *result;
-#if CYTHON_COMPILING_IN_CPYTHON
-    result = PyDict_GetItem(__pyx_d, name);
-    if (result) {
-        Py_INCREF(result);
-    } else {
-#else
-    result = PyObject_GetItem(__pyx_d, name);
-    if (!result) {
-        PyErr_Clear();
-#endif
-        result = __Pyx_GetBuiltinName(name);
-    }
-    return result;
-}
-
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
-    }
-    if (likely(PyObject_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
-    return 0;
-}
-
 static void __Pyx_RaiseBufferIndexError(int axis) {
   PyErr_Format(PyExc_IndexError,
      "Out of bounds on buffer access (axis %d)", axis);
 }
 
-static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
-                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
-                                  int full_traceback) {
-    PyObject *old_exc, *old_val, *old_tb;
-    PyObject *ctx;
-    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
-    if (full_traceback) {
-        Py_XINCREF(old_exc);
-        Py_XINCREF(old_val);
-        Py_XINCREF(old_tb);
-        __Pyx_ErrRestore(old_exc, old_val, old_tb);
-        PyErr_PrintEx(1);
-    }
-    #if PY_MAJOR_VERSION < 3
-    ctx = PyString_FromString(name);
-    #else
-    ctx = PyUnicode_FromString(name);
-    #endif
-    __Pyx_ErrRestore(old_exc, old_val, old_tb);
-    if (!ctx) {
-        PyErr_WriteUnraisable(Py_None);
-    } else {
-        PyErr_WriteUnraisable(ctx);
-        Py_DECREF(ctx);
-    }
-}
 
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
     PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+                 "need more than %"PY_FORMAT_SIZE_T"d value%s to unpack",
+                 index, (index == 1) ? "" : "s");
 }
 
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
     PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
+                 "too many values to unpack (expected %"PY_FORMAT_SIZE_T"d)", expected);
 }
 
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError(index);
+    }
+}
+
 #if PY_MAJOR_VERSION < 3
 static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
   #if PY_VERSION_HEX >= 0x02060000
-    if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
+  if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
   #endif
-        if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) return __pyx_pw_5numpy_7ndarray_1__getbuffer__(obj, view, flags);
-  #if PY_VERSION_HEX < 0x02060000
-    if (obj->ob_type->tp_dict) {
-        PyObject *getbuffer_cobj = PyObject_GetItem(
-            obj->ob_type->tp_dict, __pyx_n_s_pyx_getbuffer);
-        if (getbuffer_cobj) {
-            getbufferproc func = (getbufferproc) PyCObject_AsVoidPtr(getbuffer_cobj);
-            Py_DECREF(getbuffer_cobj);
-            if (!func)
-                goto fail;
-            return func(obj, view, flags);
-        } else {
-            PyErr_Clear();
-        }
+  if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) return __pyx_pf_5numpy_7ndarray___getbuffer__(obj, view, flags);
+  else {
+  PyErr_Format(PyExc_TypeError, "'%100s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
+  return -1;
     }
-  #endif
-    PyErr_Format(PyExc_TypeError, "'%.200s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
-#if PY_VERSION_HEX < 0x02060000
-fail:
-#endif
-    return -1;
 }
+
 static void __Pyx_ReleaseBuffer(Py_buffer *view) {
-    PyObject *obj = view->obj;
-    if (!obj) return;
-  #if PY_VERSION_HEX >= 0x02060000
-    if (PyObject_CheckBuffer(obj)) {
-        PyBuffer_Release(view);
-        return;
-    }
-  #endif
-        if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) { __pyx_pw_5numpy_7ndarray_3__releasebuffer__(obj, view); return; }
-  #if PY_VERSION_HEX < 0x02060000
-    if (obj->ob_type->tp_dict) {
-        PyObject *releasebuffer_cobj = PyObject_GetItem(
-            obj->ob_type->tp_dict, __pyx_n_s_pyx_releasebuffer);
-        if (releasebuffer_cobj) {
-            releasebufferproc func = (releasebufferproc) PyCObject_AsVoidPtr(releasebuffer_cobj);
-            Py_DECREF(releasebuffer_cobj);
-            if (!func)
-                goto fail;
-            func(obj, view);
-            return;
-        } else {
-            PyErr_Clear();
-        }
-    }
-  #endif
-    goto nofail;
-#if PY_VERSION_HEX < 0x02060000
-fail:
-#endif
-    PyErr_WriteUnraisable(obj);
-nofail:
+  PyObject* obj = view->obj;
+  if (obj) {
+    #if PY_VERSION_HEX >= 0x02060000
+    if (PyObject_CheckBuffer(obj)) {PyBuffer_Release(view); return;}
+    #endif
+    if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) __pyx_pf_5numpy_7ndarray_1__releasebuffer__(obj, view);
     Py_DECREF(obj);
     view->obj = NULL;
+  }
 }
-#endif /*  PY_MAJOR_VERSION < 3 */
 
+#endif
 
-        static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, long level) {
+    PyObject *py_import = 0;
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
     PyObject *list;
-    #if PY_VERSION_HEX < 0x03030000
-    PyObject *py_import;
-    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
+    py_import = __Pyx_GetAttrString(__pyx_b, "__import__");
     if (!py_import)
         goto bad;
-    #endif
     if (from_list)
         list = from_list;
     else {
         empty_list = PyList_New(0);
         if (!empty_list)
             goto bad;
         list = empty_list;
@@ -6096,536 +5312,113 @@
     if (!global_dict)
         goto bad;
     empty_dict = PyDict_New();
     if (!empty_dict)
         goto bad;
     #if PY_VERSION_HEX >= 0x02050000
     {
-        #if PY_MAJOR_VERSION >= 3
-        if (level == -1) {
-            if (strchr(__Pyx_MODULE_NAME, '.')) {
-                #if PY_VERSION_HEX < 0x03030000
-                PyObject *py_level = PyInt_FromLong(1);
-                if (!py_level)
-                    goto bad;
-                module = PyObject_CallFunctionObjArgs(py_import,
-                    name, global_dict, empty_dict, list, py_level, NULL);
-                Py_DECREF(py_level);
-                #else
-                module = PyImport_ImportModuleLevelObject(
-                    name, global_dict, empty_dict, list, 1);
-                #endif
-                if (!module) {
-                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
-                        goto bad;
-                    PyErr_Clear();
-                }
-            }
-            level = 0; /* try absolute import on failure */
-        }
-        #endif
-        if (!module) {
-            #if PY_VERSION_HEX < 0x03030000
-            PyObject *py_level = PyInt_FromLong(level);
-            if (!py_level)
-                goto bad;
-            module = PyObject_CallFunctionObjArgs(py_import,
-                name, global_dict, empty_dict, list, py_level, NULL);
-            Py_DECREF(py_level);
-            #else
-            module = PyImport_ImportModuleLevelObject(
-                name, global_dict, empty_dict, list, level);
-            #endif
-        }
+        PyObject *py_level = PyInt_FromLong(level);
+        if (!py_level)
+            goto bad;
+        module = PyObject_CallFunctionObjArgs(py_import,
+            name, global_dict, empty_dict, list, py_level, NULL);
+        Py_DECREF(py_level);
     }
     #else
     if (level>0) {
         PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
         goto bad;
     }
     module = PyObject_CallFunctionObjArgs(py_import,
         name, global_dict, empty_dict, list, NULL);
     #endif
 bad:
-    #if PY_VERSION_HEX < 0x03030000
-    Py_XDECREF(py_import);
-    #endif
     Py_XDECREF(empty_list);
+    Py_XDECREF(py_import);
     Py_XDECREF(empty_dict);
     return module;
 }
 
-#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func)             \
-    {                                                                     \
-        func_type value = func(x);                                        \
-        if (sizeof(target_type) < sizeof(func_type)) {                    \
-            if (unlikely(value != (func_type) (target_type) value)) {     \
-                func_type zero = 0;                                       \
-                PyErr_SetString(PyExc_OverflowError,                      \
-                    (is_unsigned && unlikely(value < zero)) ?             \
-                    "can't convert negative value to " #target_type :     \
-                    "value too large to convert to " #target_type);       \
-                return (target_type) -1;                                  \
-            }                                                             \
-        }                                                                 \
-        return (target_type) value;                                       \
-    }
-
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
-    const int neg_one = (int) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(int) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int");
-                return (int) -1;
-            }
-            return (int) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (int) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int");
-                return (int) -1;
-            }
-            if (sizeof(int) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(int) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong)
-            }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(int) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(int) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (sizeof(int) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong)
-            } else if (sizeof(int) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong)
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            int val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (int) -1;
-        }
-    } else {
-        int val;
-        PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (int) -1;
-        val = __Pyx_PyInt_As_int(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-}
-
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE int64 __Pyx_PyInt_As_int64(PyObject *x) {
-    const int64 neg_one = (int64) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(int64) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(int64, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int64");
-                return (int64) -1;
-            }
-            return (int64) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int64)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (int64) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int64");
-                return (int64) -1;
-            }
-            if (sizeof(int64) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(int64, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(int64) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(int64, unsigned long long, PyLong_AsUnsignedLongLong)
-            }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int64)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(int64) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(int64) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (sizeof(int64) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(int64, long, PyLong_AsLong)
-            } else if (sizeof(int64) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(int64, long long, PyLong_AsLongLong)
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            int64 val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (int64) -1;
-        }
-    } else {
+static CYTHON_INLINE int64 __Pyx_PyInt_from_py_int64(PyObject* x) {
+    const int64 neg_one = (int64)-1, const_zero = (int64)0;
+    const int is_unsigned = const_zero < neg_one;
+    if (sizeof(int64) == sizeof(char)) {
+        if (is_unsigned)
+            return (int64)__Pyx_PyInt_AsUnsignedChar(x);
+        else
+            return (int64)__Pyx_PyInt_AsSignedChar(x);
+    } else if (sizeof(int64) == sizeof(short)) {
+        if (is_unsigned)
+            return (int64)__Pyx_PyInt_AsUnsignedShort(x);
+        else
+            return (int64)__Pyx_PyInt_AsSignedShort(x);
+    } else if (sizeof(int64) == sizeof(int)) {
+        if (is_unsigned)
+            return (int64)__Pyx_PyInt_AsUnsignedInt(x);
+        else
+            return (int64)__Pyx_PyInt_AsSignedInt(x);
+    } else if (sizeof(int64) == sizeof(long)) {
+        if (is_unsigned)
+            return (int64)__Pyx_PyInt_AsUnsignedLong(x);
+        else
+            return (int64)__Pyx_PyInt_AsSignedLong(x);
+    } else if (sizeof(int64) == sizeof(PY_LONG_LONG)) {
+        if (is_unsigned)
+            return (int64)__Pyx_PyInt_AsUnsignedLongLong(x);
+        else
+            return (int64)__Pyx_PyInt_AsSignedLongLong(x);
+    }  else {
         int64 val;
-        PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (int64) -1;
-        val = __Pyx_PyInt_As_int64(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-}
-
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_Py_intptr_t(Py_intptr_t value) {
-    const Py_intptr_t neg_one = (Py_intptr_t) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(Py_intptr_t) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(Py_intptr_t) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-        } else if (sizeof(Py_intptr_t) <= sizeof(unsigned long long)) {
-            return PyLong_FromUnsignedLongLong((unsigned long long) value);
-        }
-    } else {
-        if (sizeof(Py_intptr_t) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(Py_intptr_t) <= sizeof(long long)) {
-            return PyLong_FromLongLong((long long) value);
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(Py_intptr_t),
-                                     little, !is_unsigned);
-    }
-}
-
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE Py_intptr_t __Pyx_PyInt_As_Py_intptr_t(PyObject *x) {
-    const Py_intptr_t neg_one = (Py_intptr_t) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(Py_intptr_t) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to Py_intptr_t");
-                return (Py_intptr_t) -1;
-            }
-            return (Py_intptr_t) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(Py_intptr_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (Py_intptr_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to Py_intptr_t");
-                return (Py_intptr_t) -1;
-            }
-            if (sizeof(Py_intptr_t) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(Py_intptr_t) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(Py_intptr_t, unsigned long long, PyLong_AsUnsignedLongLong)
-            }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(Py_intptr_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(Py_intptr_t) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(Py_intptr_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (sizeof(Py_intptr_t) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(Py_intptr_t, long, PyLong_AsLong)
-            } else if (sizeof(Py_intptr_t) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(Py_intptr_t, long long, PyLong_AsLongLong)
-            }
+        PyObject *v = __Pyx_PyNumber_Int(x);
+        #if PY_VERSION_HEX < 0x03000000
+        if (likely(v) && !PyLong_Check(v)) {
+            PyObject *tmp = v;
+            v = PyNumber_Long(tmp);
+            Py_DECREF(tmp);
         }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            Py_intptr_t val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (Py_intptr_t) -1;
-        }
-    } else {
-        Py_intptr_t val;
-        PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (Py_intptr_t) -1;
-        val = __Pyx_PyInt_As_Py_intptr_t(tmp);
-        Py_DECREF(tmp);
-        return val;
+        #endif
+        if (likely(v)) {
+            int one = 1; int is_little = (int)*(unsigned char *)&one;
+            unsigned char *bytes = (unsigned char *)&val;
+            int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                          bytes, sizeof(val),
+                                          is_little, !is_unsigned);
+            Py_DECREF(v);
+            if (likely(!ret))
+                return val;
+        }
+        return (int64)-1;
     }
 }
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-    const int neg_one = (int) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long long)) {
-            return PyLong_FromUnsignedLongLong((unsigned long long) value);
-        }
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_int64(int64 val) {
+    const int64 neg_one = (int64)-1, const_zero = (int64)0;
+    const int is_unsigned = const_zero < neg_one;
+    if ((sizeof(int64) == sizeof(char))  ||
+        (sizeof(int64) == sizeof(short))) {
+        return PyInt_FromLong((long)val);
+    } else if ((sizeof(int64) == sizeof(int)) ||
+               (sizeof(int64) == sizeof(long))) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLong((unsigned long)val);
+        else
+            return PyInt_FromLong((long)val);
+    } else if (sizeof(int64) == sizeof(PY_LONG_LONG)) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
+        else
+            return PyLong_FromLongLong((PY_LONG_LONG)val);
     } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(long long)) {
-            return PyLong_FromLongLong((long long) value);
-        }
-    }
-    {
         int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
+        unsigned char *bytes = (unsigned char *)&val;
+        return _PyLong_FromByteArray(bytes, sizeof(int64),
                                      little, !is_unsigned);
     }
 }
 
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
-    const size_t neg_one = (size_t) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(size_t) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to size_t");
-                return (size_t) -1;
-            }
-            return (size_t) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(size_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (size_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to size_t");
-                return (size_t) -1;
-            }
-            if (sizeof(size_t) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, unsigned long long, PyLong_AsUnsignedLongLong)
-            }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(size_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(size_t) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(size_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
-            if (sizeof(size_t) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, long, PyLong_AsLong)
-            } else if (sizeof(size_t) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, long long, PyLong_AsLongLong)
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            size_t val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (size_t) -1;
-        }
-    } else {
-        size_t val;
-        PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (size_t) -1;
-        val = __Pyx_PyInt_As_size_t(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-}
-
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
       return ::std::complex< float >(x, y);
     }
   #else
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
@@ -6858,140 +5651,433 @@
             z.real = z_r * cos(z_theta);
             z.imag = z_r * sin(z_theta);
             return z;
         }
     #endif
 #endif
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-    const long neg_one = (long) -1, const_zero = 0;
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
     const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long long)) {
-            return PyLong_FromUnsignedLongLong((unsigned long long) value);
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
         }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(long long)) {
-            return PyLong_FromLongLong((long long) value);
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
         }
+        return (unsigned short)val;
     }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
     }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
 }
 
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
-    const long neg_one = (long) -1, const_zero = 0;
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
     const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
     if (likely(PyInt_Check(x))) {
-        if (sizeof(long) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
                 PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to long");
-                return (long) -1;
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
             }
-            return (long) val;
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+            return (unsigned long)PyLong_AsLong(x);
         }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(long)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
-                }
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
             }
- #endif
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
 #endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
             if (unlikely(Py_SIZE(x) < 0)) {
                 PyErr_SetString(PyExc_OverflowError,
                                 "can't convert negative value to long");
-                return (long) -1;
-            }
-            if (sizeof(long) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(long) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong)
+                return (long)-1;
             }
+            return (long)PyLong_AsUnsignedLong(x);
         } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(long)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
 #endif
-            if (sizeof(long) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong)
-            } else if (sizeof(long) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong)
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
             }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
         }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            long val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
             }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
 #endif
-            return (long) -1;
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
         }
     } else {
-        long val;
+        signed PY_LONG_LONG val;
         PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (long) -1;
-        val = __Pyx_PyInt_As_long(tmp);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
         Py_DECREF(tmp);
         return val;
     }
 }
 
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    #if PY_MAJOR_VERSION < 3
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
+    #endif
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
+    }
+}
+
 static int __Pyx_check_binary_version(void) {
     char ctversion[4], rtversion[4];
     PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
     PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
     if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
         PyOS_snprintf(message, sizeof(message),
@@ -7003,257 +6089,160 @@
         #else
         return PyErr_WarnEx(NULL, message, 1);
         #endif
     }
     return 0;
 }
 
-#ifndef __PYX_HAVE_RT_ImportModule
-#define __PYX_HAVE_RT_ImportModule
-static PyObject *__Pyx_ImportModule(const char *name) {
-    PyObject *py_name = 0;
-    PyObject *py_module = 0;
-    py_name = __Pyx_PyIdentifier_FromString(name);
-    if (!py_name)
-        goto bad;
-    py_module = PyImport_Import(py_name);
-    Py_DECREF(py_name);
-    return py_module;
-bad:
-    Py_XDECREF(py_name);
-    return 0;
-}
-#endif
-
 #ifndef __PYX_HAVE_RT_ImportType
 #define __PYX_HAVE_RT_ImportType
 static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
     size_t size, int strict)
 {
     PyObject *py_module = 0;
     PyObject *result = 0;
     PyObject *py_name = 0;
     char warning[200];
-    Py_ssize_t basicsize;
-#ifdef Py_LIMITED_API
-    PyObject *py_basicsize;
-#endif
+
     py_module = __Pyx_ImportModule(module_name);
     if (!py_module)
         goto bad;
-    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(class_name);
+    #else
+    py_name = PyUnicode_FromString(class_name);
+    #endif
     if (!py_name)
         goto bad;
     result = PyObject_GetAttr(py_module, py_name);
     Py_DECREF(py_name);
     py_name = 0;
     Py_DECREF(py_module);
     py_module = 0;
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
-            "%.200s.%.200s is not a type object",
+            "%s.%s is not a type object",
             module_name, class_name);
         goto bad;
     }
-#ifndef Py_LIMITED_API
-    basicsize = ((PyTypeObject *)result)->tp_basicsize;
-#else
-    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
-    if (!py_basicsize)
-        goto bad;
-    basicsize = PyLong_AsSsize_t(py_basicsize);
-    Py_DECREF(py_basicsize);
-    py_basicsize = 0;
-    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
-        goto bad;
-#endif
-    if (!strict && (size_t)basicsize > size) {
+    if (!strict && ((PyTypeObject *)result)->tp_basicsize > (Py_ssize_t)size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility",
             module_name, class_name);
         #if PY_VERSION_HEX < 0x02050000
         if (PyErr_Warn(NULL, warning) < 0) goto bad;
         #else
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
         #endif
     }
-    else if ((size_t)basicsize != size) {
+    else if (((PyTypeObject *)result)->tp_basicsize != (Py_ssize_t)size) {
         PyErr_Format(PyExc_ValueError,
-            "%.200s.%.200s has the wrong size, try recompiling",
+            "%s.%s has the wrong size, try recompiling",
             module_name, class_name);
         goto bad;
     }
     return (PyTypeObject *)result;
 bad:
     Py_XDECREF(py_module);
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
-    int start = 0, mid = 0, end = count - 1;
-    if (end >= 0 && code_line > entries[end].code_line) {
-        return count;
-    }
-    while (start < end) {
-        mid = (start + end) / 2;
-        if (code_line < entries[mid].code_line) {
-            end = mid;
-        } else if (code_line > entries[mid].code_line) {
-             start = mid + 1;
-        } else {
-            return mid;
-        }
-    }
-    if (code_line <= entries[mid].code_line) {
-        return mid;
-    } else {
-        return mid + 1;
-    }
-}
-static PyCodeObject *__pyx_find_code_object(int code_line) {
-    PyCodeObject* code_object;
-    int pos;
-    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
-        return NULL;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
-        return NULL;
-    }
-    code_object = __pyx_code_cache.entries[pos].code_object;
-    Py_INCREF(code_object);
-    return code_object;
-}
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
-    int pos, i;
-    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
-    if (unlikely(!code_line)) {
-        return;
-    }
-    if (unlikely(!entries)) {
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
-        if (likely(entries)) {
-            __pyx_code_cache.entries = entries;
-            __pyx_code_cache.max_count = 64;
-            __pyx_code_cache.count = 1;
-            entries[0].code_line = code_line;
-            entries[0].code_object = code_object;
-            Py_INCREF(code_object);
-        }
-        return;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
-        PyCodeObject* tmp = entries[pos].code_object;
-        entries[pos].code_object = code_object;
-        Py_DECREF(tmp);
-        return;
-    }
-    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
-        int new_max = __pyx_code_cache.max_count + 64;
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
-            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
-        if (unlikely(!entries)) {
-            return;
-        }
-        __pyx_code_cache.entries = entries;
-        __pyx_code_cache.max_count = new_max;
-    }
-    for (i=__pyx_code_cache.count; i>pos; i--) {
-        entries[i] = entries[i-1];
-    }
-    entries[pos].code_line = code_line;
-    entries[pos].code_object = code_object;
-    __pyx_code_cache.count++;
-    Py_INCREF(code_object);
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(name);
+    #else
+    py_name = PyUnicode_FromString(name);
+    #endif
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
 }
+#endif
 
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
-            const char *funcname, int c_line,
-            int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
+
+static void __Pyx_AddTraceback(const char *funcname, int __pyx_clineno,
+                               int __pyx_lineno, const char *__pyx_filename) {
     PyObject *py_srcfile = 0;
     PyObject *py_funcname = 0;
+    PyObject *py_globals = 0;
+    PyCodeObject *py_code = 0;
+    PyFrameObject *py_frame = 0;
+
     #if PY_MAJOR_VERSION < 3
-    py_srcfile = PyString_FromString(filename);
+    py_srcfile = PyString_FromString(__pyx_filename);
     #else
-    py_srcfile = PyUnicode_FromString(filename);
+    py_srcfile = PyUnicode_FromString(__pyx_filename);
     #endif
     if (!py_srcfile) goto bad;
-    if (c_line) {
+    if (__pyx_clineno) {
         #if PY_MAJOR_VERSION < 3
-        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
         #else
-        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
         #else
         py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
     if (!py_funcname) goto bad;
-    py_code = __Pyx_PyCode_New(
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_code = PyCode_New(
         0,            /*int argcount,*/
+        #if PY_MAJOR_VERSION >= 3
         0,            /*int kwonlyargcount,*/
+        #endif
         0,            /*int nlocals,*/
         0,            /*int stacksize,*/
         0,            /*int flags,*/
         __pyx_empty_bytes, /*PyObject *code,*/
-        __pyx_empty_tuple, /*PyObject *consts,*/
-        __pyx_empty_tuple, /*PyObject *names,*/
-        __pyx_empty_tuple, /*PyObject *varnames,*/
-        __pyx_empty_tuple, /*PyObject *freevars,*/
-        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        __pyx_empty_tuple,  /*PyObject *consts,*/
+        __pyx_empty_tuple,  /*PyObject *names,*/
+        __pyx_empty_tuple,  /*PyObject *varnames,*/
+        __pyx_empty_tuple,  /*PyObject *freevars,*/
+        __pyx_empty_tuple,  /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
-        py_line,      /*int firstlineno,*/
+        __pyx_lineno,   /*int firstlineno,*/
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
-    Py_DECREF(py_srcfile);
-    Py_DECREF(py_funcname);
-    return py_code;
-bad:
-    Py_XDECREF(py_srcfile);
-    Py_XDECREF(py_funcname);
-    return NULL;
-}
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
-    PyObject *py_globals = 0;
-    PyFrameObject *py_frame = 0;
-    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
-    if (!py_code) {
-        py_code = __Pyx_CreateCodeObjectForTraceback(
-            funcname, c_line, py_line, filename);
-        if (!py_code) goto bad;
-        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
-    }
-    py_globals = PyModule_GetDict(__pyx_m);
-    if (!py_globals) goto bad;
+    if (!py_code) goto bad;
     py_frame = PyFrame_New(
         PyThreadState_GET(), /*PyThreadState *tstate,*/
         py_code,             /*PyCodeObject *code,*/
         py_globals,          /*PyObject *globals,*/
         0                    /*PyObject *locals*/
     );
     if (!py_frame) goto bad;
-    py_frame->f_lineno = py_line;
+    py_frame->f_lineno = __pyx_lineno;
     PyTraceBack_Here(py_frame);
 bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
 
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
         #if PY_MAJOR_VERSION < 3
@@ -7280,96 +6269,34 @@
         if (!*t->p)
             return -1;
         ++t;
     }
     return 0;
 }
 
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
-    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
-}
-static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
-    Py_ssize_t ignore;
-    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
-}
-static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-    if (
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-            __Pyx_sys_getdefaultencoding_not_ascii &&
-#endif
-            PyUnicode_Check(o)) {
-#if PY_VERSION_HEX < 0x03030000
-        char* defenc_c;
-        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
-        if (!defenc) return NULL;
-        defenc_c = PyBytes_AS_STRING(defenc);
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-        {
-            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
-            char* c;
-            for (c = defenc_c; c < end; c++) {
-                if ((unsigned char) (*c) >= 128) {
-                    PyUnicode_AsASCIIString(o);
-                    return NULL;
-                }
-            }
-        }
-#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
-        *length = PyBytes_GET_SIZE(defenc);
-        return defenc_c;
-#else /* PY_VERSION_HEX < 0x03030000 */
-        if (PyUnicode_READY(o) == -1) return NULL;
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-        if (PyUnicode_IS_ASCII(o)) {
-            *length = PyUnicode_GET_DATA_SIZE(o);
-            return PyUnicode_AsUTF8(o);
-        } else {
-            PyUnicode_AsASCIIString(o);
-            return NULL;
-        }
-#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
-        return PyUnicode_AsUTF8AndSize(o, length);
-#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
-#endif /* PY_VERSION_HEX < 0x03030000 */
-    } else
-#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
-#if PY_VERSION_HEX >= 0x02060000
-    if (PyByteArray_Check(o)) {
-        *length = PyByteArray_GET_SIZE(o);
-        return PyByteArray_AS_STRING(o);
-    } else
-#endif
-    {
-        char* result;
-        int r = PyBytes_AsStringAndSize(o, &result, length);
-        if (unlikely(r < 0)) {
-            return NULL;
-        } else {
-            return result;
-        }
-    }
-}
+/* Type Conversion Functions */
+
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
    int is_true = x == Py_True;
    if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
    else return PyObject_IsTrue(x);
 }
+
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
   PyNumberMethods *m;
   const char *name = NULL;
   PyObject *res = NULL;
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
   if (PyInt_Check(x) || PyLong_Check(x))
 #else
   if (PyLong_Check(x))
 #endif
     return Py_INCREF(x), x;
   m = Py_TYPE(x)->tp_as_number;
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
   if (m && m->nb_int) {
     name = "int";
     res = PyNumber_Int(x);
   }
   else if (m && m->nb_long) {
     name = "long";
     res = PyNumber_Long(x);
@@ -7377,75 +6304,63 @@
 #else
   if (m && m->nb_int) {
     name = "int";
     res = PyNumber_Long(x);
   }
 #endif
   if (res) {
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
     if (!PyInt_Check(res) && !PyLong_Check(res)) {
 #else
     if (!PyLong_Check(res)) {
 #endif
       PyErr_Format(PyExc_TypeError,
-                   "__%.4s__ returned non-%.4s (type %.200s)",
+                   "__%s__ returned non-%s (type %.200s)",
                    name, name, Py_TYPE(res)->tp_name);
       Py_DECREF(res);
       return NULL;
     }
   }
   else if (!PyErr_Occurred()) {
     PyErr_SetString(PyExc_TypeError,
                     "an integer is required");
   }
   return res;
 }
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
+
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
   Py_ssize_t ival;
-  PyObject *x;
-#if PY_MAJOR_VERSION < 3
-  if (likely(PyInt_CheckExact(b)))
-      return PyInt_AS_LONG(b);
-#endif
-  if (likely(PyLong_CheckExact(b))) {
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
-     #if CYTHON_USE_PYLONG_INTERNALS
-       switch (Py_SIZE(b)) {
-       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
-       case  0: return 0;
-       case  1: return ((PyLongObject*)b)->ob_digit[0];
-       }
-     #endif
-    #endif
-  #if PY_VERSION_HEX < 0x02060000
-    return PyInt_AsSsize_t(b);
-  #else
-    return PyLong_AsSsize_t(b);
-  #endif
-  }
-  x = PyNumber_Index(b);
+  PyObject* x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
+
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
 #if PY_VERSION_HEX < 0x02050000
    if (ival <= LONG_MAX)
        return PyInt_FromLong((long)ival);
    else {
        unsigned char *bytes = (unsigned char *) &ival;
        int one = 1; int little = (int)*(unsigned char*)&one;
        return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
    }
 #else
    return PyInt_FromSize_t(ival);
 #endif
 }
 
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
+       return (size_t)-1;
+   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       PyErr_SetString(PyExc_OverflowError,
+                       "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
 
 #endif /* Py_PYTHON_H */
```

### Comparing `healpy-1.9.1/healpy/src/_sphtools.cpp` & `healpy-github-devel/healpy/src/_sphtools.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,186 +1,118 @@
-/* Generated by Cython 0.20 on Thu Sep 24 12:31:48 2015 */
+/* Generated by Cython 0.15.1 on Thu Apr 19 10:27:30 2012 */
 
 #define PY_SSIZE_T_CLEAN
-#ifndef CYTHON_USE_PYLONG_INTERNALS
-#ifdef PYLONG_BITS_IN_DIGIT
-#define CYTHON_USE_PYLONG_INTERNALS 0
-#else
-#include "pyconfig.h"
-#ifdef PYLONG_BITS_IN_DIGIT
-#define CYTHON_USE_PYLONG_INTERNALS 1
-#else
-#define CYTHON_USE_PYLONG_INTERNALS 0
-#endif
-#endif
-#endif
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02040000
-    #error Cython requires Python 2.4+.
 #else
-#define CYTHON_ABI "0_20"
+
 #include <stddef.h> /* For offsetof */
 #ifndef offsetof
 #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
+
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
     #define __fastcall
   #endif
 #endif
+
 #ifndef DL_IMPORT
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
+
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
-#ifndef Py_HUGE_VAL
-  #define Py_HUGE_VAL HUGE_VAL
-#endif
-#ifdef PYPY_VERSION
-#define CYTHON_COMPILING_IN_PYPY 1
-#define CYTHON_COMPILING_IN_CPYTHON 0
-#else
-#define CYTHON_COMPILING_IN_PYPY 0
-#define CYTHON_COMPILING_IN_CPYTHON 1
-#endif
-#if CYTHON_COMPILING_IN_PYPY
-#define Py_OptimizeFlag 0
+
+#if PY_VERSION_HEX < 0x02040000
+  #define METH_COEXIST 0
+  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
+  #define PyDict_Contains(d,o)   PySequence_Contains(d,o)
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   typedef int Py_ssize_t;
   #define PY_SSIZE_T_MAX INT_MAX
   #define PY_SSIZE_T_MIN INT_MIN
   #define PY_FORMAT_SIZE_T ""
-  #define CYTHON_FORMAT_SSIZE_T ""
   #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
-  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_As_int(o)
-  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
-                                (PyErr_Format(PyExc_TypeError, \
-                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
-                                 (PyObject*)0))
-  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
-                                  !PyComplex_Check(o))
-  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    PyNumber_Int(o)
+  #define PyIndex_Check(o)     PyNumber_Check(o)
   #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
-  #define __PYX_BUILD_PY_SSIZE_T "i"
-#else
-  #define __PYX_BUILD_PY_SSIZE_T "n"
-  #define CYTHON_FORMAT_SSIZE_T "z"
-  #define __Pyx_PyIndex_Check PyIndex_Check
 #endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
   #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
   #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
   #define PyVarObject_HEAD_INIT(type, size) \
           PyObject_HEAD_INIT(type) size,
   #define PyType_Modified(t)
+
   typedef struct {
      void *buf;
      PyObject *obj;
      Py_ssize_t len;
      Py_ssize_t itemsize;
      int readonly;
      int ndim;
      char *format;
      Py_ssize_t *shape;
      Py_ssize_t *strides;
      Py_ssize_t *suboffsets;
      void *internal;
   } Py_buffer;
+
   #define PyBUF_SIMPLE 0
   #define PyBUF_WRITABLE 0x0001
   #define PyBUF_FORMAT 0x0004
   #define PyBUF_ND 0x0008
   #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
   #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
   #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
   #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
   #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
-  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
-  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
-  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
-  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+
 #endif
+
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
-          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-  #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
-          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-  #define __Pyx_DefaultClassType PyType_Type
-#endif
-#if PY_VERSION_HEX < 0x02060000
-  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define Py_TPFLAGS_CHECKTYPES 0
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
+
 #if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
-#if PY_VERSION_HEX < 0x02060000
-  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
-#endif
-#if PY_VERSION_HEX < 0x02060000 && !defined(Py_TPFLAGS_IS_ABSTRACT)
-  #define Py_TPFLAGS_IS_ABSTRACT 0
-#endif
-#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
-  #define Py_TPFLAGS_HAVE_FINALIZE 0
-#endif
-#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
-  #define CYTHON_PEP393_ENABLED 1
-  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
-                                              0 : _PyUnicode_Ready((PyObject *)(op)))
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
-  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
-  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-#else
-  #define CYTHON_PEP393_ENABLED 0
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-#endif
-#define __Pyx_PyString_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
-#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
-#define __Pyx_PyUnicode_Concat(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
-    PyNumber_Add(a, b) : PyUnicode_Concat(a, b))
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
-#else
-  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
-#endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyBaseString_Type            PyUnicode_Type
   #define PyStringObject               PyUnicodeObject
   #define PyString_Type                PyUnicode_Type
   #define PyString_Check               PyUnicode_Check
   #define PyString_CheckExact          PyUnicode_CheckExact
 #endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define PyBytesObject                PyStringObject
   #define PyBytes_Type                 PyString_Type
   #define PyBytes_Check                PyString_Check
   #define PyBytes_CheckExact           PyString_CheckExact
   #define PyBytes_FromString           PyString_FromString
   #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
@@ -191,30 +123,25 @@
   #define PyBytes_Size                 PyString_Size
   #define PyBytes_AS_STRING            PyString_AS_STRING
   #define PyBytes_GET_SIZE             PyString_GET_SIZE
   #define PyBytes_Repr                 PyString_Repr
   #define PyBytes_Concat               PyString_Concat
   #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
 #endif
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
-  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
-#else
-  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
-                                         PyString_Check(obj) || PyUnicode_Check(obj))
-  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
-#endif
+
 #if PY_VERSION_HEX < 0x02060000
   #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
   #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
 #endif
 #ifndef PySet_CheckExact
   #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
+
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
@@ -222,27 +149,38 @@
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
-  #define PyNumber_Int                 PyNumber_Long
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
+
 #if PY_VERSION_HEX < 0x03020000
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
   #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
   #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
 #endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
 #if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
   #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
   #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
   #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
 #else
   #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
         (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
@@ -253,76 +191,36 @@
         (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
             (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
   #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
         (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
         (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
             (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
 #endif
+
 #if PY_MAJOR_VERSION >= 3
   #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
   #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
   #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
 #else
   #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
   #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
   #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
 #endif
+
 #if PY_VERSION_HEX < 0x02050000
   #define __Pyx_NAMESTR(n) ((char *)(n))
   #define __Pyx_DOCSTR(n)  ((char *)(n))
 #else
   #define __Pyx_NAMESTR(n) (n)
   #define __Pyx_DOCSTR(n)  (n)
 #endif
-#ifndef CYTHON_INLINE
-  #if defined(__GNUC__)
-    #define CYTHON_INLINE __inline__
-  #elif defined(_MSC_VER)
-    #define CYTHON_INLINE __inline
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_INLINE inline
-  #else
-    #define CYTHON_INLINE
-  #endif
-#endif
-#ifndef CYTHON_RESTRICT
-  #if defined(__GNUC__)
-    #define CYTHON_RESTRICT __restrict__
-  #elif defined(_MSC_VER) && _MSC_VER >= 1400
-    #define CYTHON_RESTRICT __restrict
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_RESTRICT restrict
-  #else
-    #define CYTHON_RESTRICT
-  #endif
-#endif
-#ifdef NAN
-#define __PYX_NAN() ((float) NAN)
-#else
-static CYTHON_INLINE float __PYX_NAN() {
-  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
-   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
-   a quiet NaN. */
-  float value;
-  memset(&value, 0xFF, sizeof(value));
-  return value;
-}
-#endif
-
-
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
-#else
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
-#endif
 
 #ifndef __PYX_EXTERN_C
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
@@ -330,196 +228,82 @@
 
 #if defined(WIN32) || defined(MS_WINDOWS)
 #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #define __PYX_HAVE__healpy___sphtools
 #define __PYX_HAVE_API__healpy___sphtools
-#include "string.h"
 #include "stdio.h"
 #include "stdlib.h"
 #include "numpy/arrayobject.h"
 #include "numpy/ufuncobject.h"
 #include <string>
-#include "ios"
-#include "new"
-#include "stdexcept"
-#include "typeinfo"
 #include "math.h"
-#include <vector>
-#include "stddef.h"
-#include "datatypes.h"
-#include "xcomplex.h"
 #include "arr.h"
-#include "rangeset.h"
-#include "vec3.h"
-#include "pointing.h"
-#include "healpix_base.h"
-#include "healpix_map.h"
+#include "xcomplex.h"
 #include "alm.h"
+#include "healpix_map.h"
 #include "alm_healpix_tools.h"
-#include "alm_powspec_tools.h"
 #include "healpix_data_io.h"
+#include "hack.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #ifdef PYREX_WITHOUT_ASSERTIONS
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
 
+
+/* inline attribute */
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+
+/* unused attribute */
 #ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
-# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+# elif defined(__ICC) || defined(__INTEL_COMPILER)
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
-                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
 
-#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
-#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
-#define __PYX_DEFAULT_STRING_ENCODING ""
-#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
-#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
-#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
-    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
-    (sizeof(type) > sizeof(Py_ssize_t) &&               \
-          likely(v < (type)PY_SSIZE_T_MAX ||            \
-                 v == (type)PY_SSIZE_T_MAX)  &&         \
-          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
-                                v == (type)PY_SSIZE_T_MIN)))  ||  \
-    (sizeof(type) == sizeof(Py_ssize_t) &&              \
-          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
-                               v == (type)PY_SSIZE_T_MAX)))  )
-static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
-static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
-#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
-#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
-#define __Pyx_PyBytes_FromString        PyBytes_FromString
-#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
-#if PY_MAJOR_VERSION < 3
-    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
-#else
-    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
-#endif
-#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
-#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
-#define __Pyx_PyByteArray_FromUString(s)   __Pyx_PyByteArray_FromString((char*)s)
-#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
-#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
-#if PY_MAJOR_VERSION < 3
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return u_end - u - 1;
-}
-#else
-#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
-#endif
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
-#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+
+/* Type Conversion Predeclarations */
+
+#define __Pyx_PyBytes_FromUString(s) PyBytes_FromString((char*)s)
+#define __Pyx_PyBytes_AsUString(s)   ((unsigned char*) PyBytes_AsString(s))
+
 #define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
 #define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
-#else
-#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
-#endif
-#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-static int __Pyx_sys_getdefaultencoding_not_ascii;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys = NULL;
-    PyObject* default_encoding = NULL;
-    PyObject* ascii_chars_u = NULL;
-    PyObject* ascii_chars_b = NULL;
-    sys = PyImport_ImportModule("sys");
-    if (sys == NULL) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
-    if (default_encoding == NULL) goto bad;
-    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
-        __Pyx_sys_getdefaultencoding_not_ascii = 0;
-    } else {
-        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
-        char ascii_chars[128];
-        int c;
-        for (c = 0; c < 128; c++) {
-            ascii_chars[c] = c;
-        }
-        __Pyx_sys_getdefaultencoding_not_ascii = 1;
-        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
-        if (ascii_chars_u == NULL) goto bad;
-        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
-        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
-            PyErr_Format(
-                PyExc_ValueError,
-                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
-                default_encoding_c);
-            goto bad;
-        }
-    }
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    Py_XDECREF(ascii_chars_u);
-    Py_XDECREF(ascii_chars_b);
-    return 0;
-bad:
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    Py_XDECREF(ascii_chars_u);
-    Py_XDECREF(ascii_chars_b);
-    return -1;
-}
-#endif
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
-#else
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-static char* __PYX_DEFAULT_STRING_ENCODING;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys = NULL;
-    PyObject* default_encoding = NULL;
-    char* default_encoding_c;
-    sys = PyImport_ImportModule("sys");
-    if (sys == NULL) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
-    if (default_encoding == NULL) goto bad;
-    default_encoding_c = PyBytes_AS_STRING(default_encoding);
-    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
-    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
-    Py_DECREF(sys);
-    Py_DECREF(default_encoding);
-    return 0;
-bad:
-    Py_XDECREF(sys);
-    Py_XDECREF(default_encoding);
-    return -1;
-}
-#endif
-#endif
 
 
 #ifdef __GNUC__
   /* Test for GCC > 2.95 */
   #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
     #define likely(x)   __builtin_expect(!!(x), 1)
     #define unlikely(x) __builtin_expect(!!(x), 0)
@@ -527,676 +311,645 @@
     #define likely(x)   (x)
     #define unlikely(x) (x)
   #endif /* __GNUC__ > 2 ... */
 #else /* __GNUC__ */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
-
+    
 static PyObject *__pyx_m;
-static PyObject *__pyx_d;
 static PyObject *__pyx_b;
 static PyObject *__pyx_empty_tuple;
 static PyObject *__pyx_empty_bytes;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
+
 #if !defined(CYTHON_CCOMPLEX)
   #if defined(__cplusplus)
     #define CYTHON_CCOMPLEX 1
   #elif defined(_Complex_I)
     #define CYTHON_CCOMPLEX 1
   #else
     #define CYTHON_CCOMPLEX 0
   #endif
 #endif
+
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #include <complex>
   #else
     #include <complex.h>
   #endif
 #endif
+
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
-
 static const char *__pyx_f[] = {
   "_sphtools.pyx",
-  "_common.pxd",
-  "__init__.pxd",
-  "type.pxd",
+  "numpy.pxd",
 };
-#define IS_UNSIGNED(type) (((type) -1) > 0)
-struct __Pyx_StructField_;
-#define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
-typedef struct {
-  const char* name; /* for error messages only */
-  struct __Pyx_StructField_* fields;
-  size_t size;     /* sizeof(type) */
-  size_t arraysize[8]; /* length of array in each dimension */
-  int ndim;
-  char typegroup; /* _R_eal, _C_omplex, Signed _I_nt, _U_nsigned int, _S_truct, _P_ointer, _O_bject, c_H_ar */
-  char is_unsigned;
-  int flags;
-} __Pyx_TypeInfo;
-typedef struct __Pyx_StructField_ {
-  __Pyx_TypeInfo* type;
-  const char* name;
-  size_t offset;
-} __Pyx_StructField;
-typedef struct {
-  __Pyx_StructField* field;
-  size_t parent_offset;
-} __Pyx_BufFmt_StackElem;
-typedef struct {
-  __Pyx_StructField root;
-  __Pyx_BufFmt_StackElem* head;
-  size_t fmt_offset;
-  size_t new_count, enc_count;
-  size_t struct_alignment;
-  int is_complex;
-  char enc_type;
-  char new_packmode;
-  char enc_packmode;
-  char is_valid_array;
-} __Pyx_BufFmt_Context;
-
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":723
+/* "numpy.pxd":719
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":724
+/* "numpy.pxd":720
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":725
+/* "numpy.pxd":721
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":726
+/* "numpy.pxd":722
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":730
+/* "numpy.pxd":726
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":731
+/* "numpy.pxd":727
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":732
+/* "numpy.pxd":728
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":733
+/* "numpy.pxd":729
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":737
+/* "numpy.pxd":733
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":738
+/* "numpy.pxd":734
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":747
+/* "numpy.pxd":743
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":748
+/* "numpy.pxd":744
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":749
+/* "numpy.pxd":745
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":751
+/* "numpy.pxd":747
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":752
+/* "numpy.pxd":748
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":753
+/* "numpy.pxd":749
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":755
+/* "numpy.pxd":751
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":756
+/* "numpy.pxd":752
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":758
+/* "numpy.pxd":754
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":759
+/* "numpy.pxd":755
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":760
+/* "numpy.pxd":756
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
 
-/* "_common.pxd":6
- * from libcpp.vector cimport vector
- * 
+/* "healpy/src/_sphtools.pyx":12
+ * from healpy import npix2nside
+ * from healpy.pixelfunc import maptype
  * ctypedef unsigned size_t             # <<<<<<<<<<<<<<
  * ctypedef size_t tsize
- * 
+ * import os
  */
-typedef unsigned int __pyx_t_7_common_size_t;
+typedef unsigned int __pyx_t_6healpy_9_sphtools_size_t;
 
-/* "_common.pxd":7
- * 
+/* "healpy/src/_sphtools.pyx":13
+ * from healpy.pixelfunc import maptype
  * ctypedef unsigned size_t
  * ctypedef size_t tsize             # <<<<<<<<<<<<<<
- * 
- * cdef extern from "stddef.h":
+ * import os
+ * import cython
  */
-typedef size_t __pyx_t_7_common_tsize;
+typedef size_t __pyx_t_6healpy_9_sphtools_tsize;
 
-/* "_common.pxd":11
- * cdef extern from "stddef.h":
- *     ctypedef long ptrdiff_t
- * ctypedef ptrdiff_t tdiff             # <<<<<<<<<<<<<<
- * 
- * cdef extern from "datatypes.h":
- */
-typedef ptrdiff_t __pyx_t_7_common_tdiff;
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
-    typedef ::std::complex< double > __pyx_t_double_complex;
+    typedef ::std::complex< float > __pyx_t_float_complex;
   #else
-    typedef double _Complex __pyx_t_double_complex;
+    typedef float _Complex __pyx_t_float_complex;
   #endif
 #else
-    typedef struct { double real, imag; } __pyx_t_double_complex;
+    typedef struct { float real, imag; } __pyx_t_float_complex;
 #endif
 
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
-    typedef ::std::complex< float > __pyx_t_float_complex;
+    typedef ::std::complex< double > __pyx_t_double_complex;
   #else
-    typedef float _Complex __pyx_t_float_complex;
+    typedef double _Complex __pyx_t_double_complex;
   #endif
 #else
-    typedef struct { float real, imag; } __pyx_t_float_complex;
+    typedef struct { double real, imag; } __pyx_t_double_complex;
 #endif
 
-
 /*--- Type declarations ---*/
+struct __pyx_obj_6healpy_9_sphtools_WrapMap;
+struct __pyx_obj_6healpy_9_sphtools_WrapAlm;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":762
+/* "numpy.pxd":758
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":763
+/* "numpy.pxd":759
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":764
+/* "numpy.pxd":760
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":766
+/* "numpy.pxd":762
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
+
+/* "healpy/src/_sphtools.pyx":72
+ *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
+ * 
+ * cdef class WrapMap(object):             # <<<<<<<<<<<<<<
+ *     """This class provides a wrapper to a ndarray so it can be sent as Map to healpix_cxx functions.
+ *     """
+ */
+struct __pyx_obj_6healpy_9_sphtools_WrapMap {
+  PyObject_HEAD
+  Healpix_Map<double> *h;
+  arr<double> *a;
+  PyObject *m;
+  int is_init;
+};
+
+
+/* "healpy/src/_sphtools.pyx":94
+ *             del self.a, self.h
+ * 
+ * cdef class WrapAlm(object):             # <<<<<<<<<<<<<<
+ *     """This class provides a wrapper to a ndarray so it can be sent as Alm to healpix_cxx functions.
+ *     """
+ */
+struct __pyx_obj_6healpy_9_sphtools_WrapAlm {
+  PyObject_HEAD
+  Alm<xcomplex<double> > *h;
+  arr<xcomplex<double> > *a;
+  PyObject *m;
+  int is_init;
+};
+
+
+
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
+
 #if CYTHON_REFNANNY
   typedef struct {
     void (*INCREF)(void*, PyObject*, int);
     void (*DECREF)(void*, PyObject*, int);
     void (*GOTREF)(void*, PyObject*, int);
     void (*GIVEREF)(void*, PyObject*, int);
     void* (*SetupContext)(const char*, int, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
-#ifdef WITH_THREAD
-  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
-          if (acquire_gil) { \
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
-              PyGILState_Release(__pyx_gilstate_save); \
-          } else { \
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
-          }
-#else
-  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
-#endif
-  #define __Pyx_RefNannyFinishContext() \
-          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_RefNannySetupContext(name)           __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+  #define __Pyx_RefNannyFinishContext()           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
   #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
   #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
   #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
   #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
   #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
-  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannySetupContext(name)
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif /* CYTHON_REFNANNY */
-#define __Pyx_XDECREF_SET(r, v) do {                            \
-        PyObject *tmp = (PyObject *) r;                         \
-        r = v; __Pyx_XDECREF(tmp);                              \
-    } while (0)
-#define __Pyx_DECREF_SET(r, v) do {                             \
-        PyObject *tmp = (PyObject *) r;                         \
-        r = v; __Pyx_DECREF(tmp);                               \
-    } while (0)
-#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
-#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
-
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
-#endif
-    return PyObject_GetAttr(obj, attr_name);
-}
-#else
-#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
-#endif
 
-static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+static CYTHON_INLINE long __Pyx_div_long(long, long); /* proto */
 
-static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/
 
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
 
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact); /*proto*/
 
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
-    const char* function_name); /*proto*/
-
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len)) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        Py_SIZE(list) = len+1;
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
-#endif
+/* Run-time type information about structs used with buffers */
+struct __Pyx_StructField_;
 
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+typedef struct {
+  const char* name; /* for error messages only */
+  struct __Pyx_StructField_* fields;
+  size_t size;     /* sizeof(type) */
+  char typegroup; /* _R_eal, _C_omplex, Signed _I_nt, _U_nsigned int, _S_truct, _P_ointer, _O_bject */
+} __Pyx_TypeInfo;
 
-#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
-    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) : \
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) : \
-               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
-#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
-    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
-    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
-    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
-    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
-                                                     int is_list, int wraparound, int boundscheck);
+typedef struct __Pyx_StructField_ {
+  __Pyx_TypeInfo* type;
+  const char* name;
+  size_t offset;
+} __Pyx_StructField;
 
-static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
-static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+typedef struct {
+  __Pyx_StructField* field;
+  size_t parent_offset;
+} __Pyx_BufFmt_StackElem;
 
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
 
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+static CYTHON_INLINE int  __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
+static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
 
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
-static CYTHON_INLINE int __Pyx_IterFinish(void); /*proto*/
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
 
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected); /*proto*/
 
-static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_List_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+            PyObject *r = PyList_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyList_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyList_GET_ITEM(o, PyList_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
 
-static CYTHON_INLINE int  __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj,
-    __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
-static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Tuple_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyTuple_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyTuple_GET_ITEM(o, PyTuple_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
 
-static void __Pyx_RaiseBufferFallbackError(void); /*proto*/
 
-static void __Pyx_RaiseBufferIndexError(int axis); /*proto*/
+#define __Pyx_GetItemInt(o, i, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Fast(o, i) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
 
-#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        Py_SIZE(list) = len+1;
-        return 0;
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i) {
+    PyObject *r;
+    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
     }
-    return PyList_Append(list, x);
+    else if (PyTuple_CheckExact(o) && ((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+    }
+    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_item && (likely(i >= 0))) {
+        r = PySequence_GetItem(o, i);
+    }
+    else {
+        r = __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+    }
+    return r;
 }
-#else
-#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
-#endif
 
-static PyObject* __Pyx_PyObject_CallMethodTuple(PyObject* obj, PyObject* method_name, PyObject* args) {
-    PyObject *method, *result = NULL;
-    if (unlikely(!args)) return NULL;
-    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
-    if (unlikely(!method)) goto bad;
-    result = PyObject_Call(method, args, NULL);
-    Py_DECREF(method);
-bad:
-    Py_DECREF(args);
-    return result;
-}
-#define __Pyx_PyObject_CallMethod3(obj, name, arg1, arg2, arg3) \
-    __Pyx_PyObject_CallMethodTuple(obj, name, PyTuple_Pack(3, arg1, arg2, arg3))
-#define __Pyx_PyObject_CallMethod2(obj, name, arg1, arg2) \
-    __Pyx_PyObject_CallMethodTuple(obj, name, PyTuple_Pack(2, arg1, arg2))
-#define __Pyx_PyObject_CallMethod1(obj, name, arg1) \
-    __Pyx_PyObject_CallMethodTuple(obj, name, PyTuple_Pack(1, arg1))
-#define __Pyx_PyObject_CallMethod0(obj, name) \
-    __Pyx_PyObject_CallMethodTuple(obj, name, (Py_INCREF(__pyx_empty_tuple), __pyx_empty_tuple))
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
 
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x); /*proto*/
+static void __Pyx_RaiseBufferFallbackError(void); /*proto*/
 
-static CYTHON_INLINE long __Pyx_div_long(long, long); /* proto */
+static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback); /*proto*/
+#define __Pyx_SetItemInt(o, i, v, size, to_py_func) (((size) <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_SetItemInt_Fast(o, i, v) : \
+                                                    __Pyx_SetItemInt_Generic(o, to_py_func(i), v))
+
+static CYTHON_INLINE int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
+    int r;
+    if (!j) return -1;
+    r = PyObject_SetItem(o, j, v);
+    Py_DECREF(j);
+    return r;
+}
 
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_setattro))
-        return tp->tp_setattro(obj, attr_name, value);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_setattr))
-        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
-#endif
-    return PyObject_SetAttr(obj, attr_name, value);
+static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v) {
+    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        Py_INCREF(v);
+        Py_DECREF(PyList_GET_ITEM(o, i));
+        PyList_SET_ITEM(o, i, v);
+        return 1;
+    }
+    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_ass_item && (likely(i >= 0)))
+        return PySequence_SetItem(o, i, v);
+    else {
+        PyObject *j = PyInt_FromSsize_t(i);
+        return __Pyx_SetItemInt_Generic(o, j, v);
+    }
 }
-#else
-#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
-#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
-#endif
+static void __Pyx_RaiseBufferIndexError(int axis); /*proto*/
+#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
 
-static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
-    const char *name, int exact); /*proto*/
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
+    if (likely(PyList_CheckExact(L))) {
+        if (PyList_Append(L, x) < 0) return NULL;
+        Py_INCREF(Py_None);
+        return Py_None; /* this is just to have an accurate signature */
+    }
+    else {
+        PyObject *r, *m;
+        m = __Pyx_GetAttrString(L, "append");
+        if (!m) return NULL;
+        r = PyObject_CallFunctionObjArgs(m, x, NULL);
+        Py_DECREF(m);
+        return r;
+    }
+}
 
-#define __Pyx_BufPtrCContig1d(type, buf, i0, s0) ((type)buf + i0)
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
-typedef struct {
-  Py_ssize_t shape, strides, suboffsets;
-} __Pyx_Buf_DimInfo;
-typedef struct {
-  size_t refcount;
-  Py_buffer pybuffer;
-} __Pyx_Buffer;
-typedef struct {
-  __Pyx_Buffer *rcbuffer;
-  char *data;
-  __Pyx_Buf_DimInfo diminfo[8];
-} __Pyx_LocalBuf_ND;
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index); /*proto*/
 #if PY_MAJOR_VERSION < 3
-    static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
-    static void __Pyx_ReleaseBuffer(Py_buffer *view);
+static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
+static void __Pyx_ReleaseBuffer(Py_buffer *view);
 #else
-    #define __Pyx_GetBuffer PyObject_GetBuffer
-    #define __Pyx_ReleaseBuffer PyBuffer_Release
+#define __Pyx_GetBuffer PyObject_GetBuffer
+#define __Pyx_ReleaseBuffer PyBuffer_Release
 #endif
 
+Py_ssize_t __Pyx_zeros[] = {0};
+Py_ssize_t __Pyx_minusones[] = {-1};
 
-static Py_ssize_t __Pyx_zeros[] = {0, 0, 0, 0, 0, 0, 0, 0};
-static Py_ssize_t __Pyx_minusones[] = {-1, -1, -1, -1, -1, -1, -1, -1};
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, long level); /*proto*/
 
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
-
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
-
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
-
-#ifndef __Pyx_CppExn2PyErr
-#include <new>
-#include <typeinfo>
-#include <stdexcept>
-#include <ios>
-static void __Pyx_CppExn2PyErr() {
-  try {
-    if (PyErr_Occurred())
-      ; // let the latest Python exn pass through and ignore the current one
-    else
-      throw;
-  } catch (const std::bad_alloc& exn) {
-    PyErr_SetString(PyExc_MemoryError, exn.what());
-  } catch (const std::bad_cast& exn) {
-    PyErr_SetString(PyExc_TypeError, exn.what());
-  } catch (const std::domain_error& exn) {
-    PyErr_SetString(PyExc_ValueError, exn.what());
-  } catch (const std::invalid_argument& exn) {
-    PyErr_SetString(PyExc_ValueError, exn.what());
-  } catch (const std::ios_base::failure& exn) {
-    PyErr_SetString(PyExc_IOError, exn.what());
-  } catch (const std::out_of_range& exn) {
-    PyErr_SetString(PyExc_IndexError, exn.what());
-  } catch (const std::overflow_error& exn) {
-    PyErr_SetString(PyExc_OverflowError, exn.what());
-  } catch (const std::range_error& exn) {
-    PyErr_SetString(PyExc_ArithmeticError, exn.what());
-  } catch (const std::underflow_error& exn) {
-    PyErr_SetString(PyExc_ArithmeticError, exn.what());
-  } catch (const std::exception& exn) {
-    PyErr_SetString(PyExc_RuntimeError, exn.what());
-  }
-  catch (...)
-  {
-    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
-  }
-}
-#endif
+static CYTHON_INLINE long __Pyx_pow_long(long, long); /* proto */
 
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #define __Pyx_CREAL(z) ((z).real())
     #define __Pyx_CIMAG(z) ((z).imag())
   #else
     #define __Pyx_CREAL(z) (__real__(z))
     #define __Pyx_CIMAG(z) (__imag__(z))
   #endif
 #else
     #define __Pyx_CREAL(z) ((z).real)
     #define __Pyx_CIMAG(z) ((z).imag)
 #endif
-#if (defined(_WIN32) || defined(__clang__)) && defined(__cplusplus) && CYTHON_CCOMPLEX
+
+#if defined(_WIN32) && defined(__cplusplus) && CYTHON_CCOMPLEX
     #define __Pyx_SET_CREAL(z,x) ((z).real(x))
     #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
 #else
     #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
     #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
 #endif
 
+static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);
+
+#if CYTHON_CCOMPLEX
+    #define __Pyx_c_eqf(a, b)   ((a)==(b))
+    #define __Pyx_c_sumf(a, b)  ((a)+(b))
+    #define __Pyx_c_difff(a, b) ((a)-(b))
+    #define __Pyx_c_prodf(a, b) ((a)*(b))
+    #define __Pyx_c_quotf(a, b) ((a)/(b))
+    #define __Pyx_c_negf(a)     (-(a))
+  #ifdef __cplusplus
+    #define __Pyx_c_is_zerof(z) ((z)==(float)0)
+    #define __Pyx_c_conjf(z)    (::std::conj(z))
+    #if 1
+        #define __Pyx_c_absf(z)     (::std::abs(z))
+        #define __Pyx_c_powf(a, b)  (::std::pow(a, b))
+    #endif
+  #else
+    #define __Pyx_c_is_zerof(z) ((z)==0)
+    #define __Pyx_c_conjf(z)    (conjf(z))
+    #if 1
+        #define __Pyx_c_absf(z)     (cabsf(z))
+        #define __Pyx_c_powf(a, b)  (cpowf(a, b))
+    #endif
+ #endif
+#else
+    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex, __pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex, __pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex, __pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex, __pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex, __pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex);
+    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex);
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex);
+    #if 1
+        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex);
+        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex, __pyx_t_float_complex);
+    #endif
+#endif
+
 static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);
 
 #if CYTHON_CCOMPLEX
     #define __Pyx_c_eq(a, b)   ((a)==(b))
     #define __Pyx_c_sum(a, b)  ((a)+(b))
     #define __Pyx_c_diff(a, b) ((a)-(b))
     #define __Pyx_c_prod(a, b) ((a)*(b))
@@ -1228,2099 +981,1142 @@
     static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex);
     #if 1
         static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex);
         static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex, __pyx_t_double_complex);
     #endif
 #endif
 
-static CYTHON_INLINE long __Pyx_pow_long(long, long); /* proto */
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
 
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
 
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
 
-static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
 
-#if CYTHON_CCOMPLEX
-    #define __Pyx_c_eqf(a, b)   ((a)==(b))
-    #define __Pyx_c_sumf(a, b)  ((a)+(b))
-    #define __Pyx_c_difff(a, b) ((a)-(b))
-    #define __Pyx_c_prodf(a, b) ((a)*(b))
-    #define __Pyx_c_quotf(a, b) ((a)/(b))
-    #define __Pyx_c_negf(a)     (-(a))
-  #ifdef __cplusplus
-    #define __Pyx_c_is_zerof(z) ((z)==(float)0)
-    #define __Pyx_c_conjf(z)    (::std::conj(z))
-    #if 1
-        #define __Pyx_c_absf(z)     (::std::abs(z))
-        #define __Pyx_c_powf(a, b)  (::std::pow(a, b))
-    #endif
-  #else
-    #define __Pyx_c_is_zerof(z) ((z)==0)
-    #define __Pyx_c_conjf(z)    (conjf(z))
-    #if 1
-        #define __Pyx_c_absf(z)     (cabsf(z))
-        #define __Pyx_c_powf(a, b)  (cpowf(a, b))
-    #endif
- #endif
-#else
-    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex, __pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex, __pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex, __pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex, __pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex, __pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex);
-    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex);
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex);
-    #if 1
-        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex);
-        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex, __pyx_t_float_complex);
-    #endif
-#endif
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
 
-static int __Pyx_check_binary_version(void);
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
 
-#if !defined(__Pyx_PyIdentifier_FromString)
-#if PY_MAJOR_VERSION < 3
-  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
-#else
-  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
-#endif
-#endif
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
 
-static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename); /*proto*/
+
+static int __Pyx_check_binary_version(void);
 
 static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
 
-typedef struct {
-    int code_line;
-    PyCodeObject* code_object;
-} __Pyx_CodeObjectCacheEntry;
-struct __Pyx_CodeObjectCache {
-    int count;
-    int max_count;
-    __Pyx_CodeObjectCacheEntry* entries;
-};
-static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
-static PyCodeObject *__pyx_find_code_object(int code_line);
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
 
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename); /*proto*/
+static void __Pyx_AddTraceback(const char *funcname, int __pyx_clineno,
+                               int __pyx_lineno, const char *__pyx_filename); /*proto*/
 
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
 
-
 /* Module declarations from 'cpython.buffer' */
 
 /* Module declarations from 'cpython.ref' */
 
-/* Module declarations from 'libc.string' */
-
 /* Module declarations from 'libc.stdio' */
 
 /* Module declarations from 'cpython.object' */
 
-/* Module declarations from '__builtin__' */
-
-/* Module declarations from 'cpython.type' */
-static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
-
 /* Module declarations from 'libc.stdlib' */
 
 /* Module declarations from 'numpy' */
 
 /* Module declarations from 'numpy' */
 static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
 static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
 static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
 static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
 static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *, PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *, PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
 static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/
+static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *, PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *); /*proto*/
 
 /* Module declarations from 'libcpp.string' */
 
 /* Module declarations from 'libc.math' */
 
 /* Module declarations from 'libc' */
 
-/* Module declarations from 'cython' */
-
-/* Module declarations from 'libcpp' */
+/* Module declarations from 'cython.cython.view' */
 
-/* Module declarations from 'libcpp.vector' */
-
-/* Module declarations from '_common' */
-static CYTHON_INLINE Healpix_Map<double> *__pyx_f_7_common_ndarray2map(PyArrayObject *, enum Healpix_Ordering_Scheme); /*proto*/
-static CYTHON_INLINE Alm<xcomplex<double> > *__pyx_f_7_common_ndarray2alm(PyArrayObject *, int, int); /*proto*/
+/* Module declarations from 'cython' */
 
 /* Module declarations from 'healpy._sphtools' */
+static PyTypeObject *__pyx_ptype_6healpy_9_sphtools_WrapMap = 0;
+static PyTypeObject *__pyx_ptype_6healpy_9_sphtools_WrapAlm = 0;
 static double __pyx_v_6healpy_9_sphtools_UNSEEN;
 static double __pyx_v_6healpy_9_sphtools_rtol_UNSEEN;
-static int __pyx_f_6healpy_9_sphtools_alm_getn(int, int); /*proto*/
+static PyObject *__pyx_f_6healpy_9_sphtools_Num_Alms(int, int); /*proto*/
+static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getidx(int, int, int); /*proto*/
 static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getlmax(int); /*proto*/
 static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getlmax2(int, int); /*proto*/
-static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getidx(int, int, int); /*proto*/
 static PyObject *__pyx_f_6healpy_9_sphtools_mkmask(PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
 static int __pyx_f_6healpy_9_sphtools_count_bad(PyArrayObject *, int __pyx_skip_dispatch); /*proto*/
-static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo___pyx_t_double_complex = { "double complex", NULL, sizeof(__pyx_t_double_complex), { 0 }, 0, 'C', 0, 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t = { "int8_t", NULL, sizeof(__pyx_t_5numpy_int8_t), { 0 }, 0, IS_UNSIGNED(__pyx_t_5numpy_int8_t) ? 'U' : 'I', IS_UNSIGNED(__pyx_t_5numpy_int8_t), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t = { "float64_t", NULL, sizeof(__pyx_t_5numpy_float64_t), { 0 }, 0, 'R', 0, 0 };
+static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), 'R' };
+static __Pyx_TypeInfo __Pyx_TypeInfo___pyx_t_double_complex = { "double complex", NULL, sizeof(__pyx_t_double_complex), 'C' };
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t = { "float64_t", NULL, sizeof(__pyx_t_5numpy_float64_t), 'R' };
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t = { "int8_t", NULL, sizeof(__pyx_t_5numpy_int8_t), 'I' };
 #define __Pyx_MODULE_NAME "healpy._sphtools"
 int __pyx_module_is_main_healpy___sphtools = 0;
 
 /* Implementation of 'healpy._sphtools' */
 static PyObject *__pyx_builtin_ValueError;
-static PyObject *__pyx_builtin_zip;
+static PyObject *__pyx_builtin_Exception;
 static PyObject *__pyx_builtin_IOError;
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_xrange;
 static PyObject *__pyx_builtin_RuntimeError;
-static PyObject *__pyx_pf_6healpy_9_sphtools_get_datapath(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_2map2alm_spin_healpy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_maps, PyObject *__pyx_v_spin, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_4alm2map_spin_healpy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alms, PyObject *__pyx_v_nside, PyObject *__pyx_v_spin, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_6map2alm(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_m, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax, PyObject *__pyx_v_niter, PyObject *__pyx_v_use_weights, PyObject *__pyx_v_datapath); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_8alm2cl(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alms, PyObject *__pyx_v_alms2, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax, PyObject *__pyx_v_lmax_out); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_10almxfl(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alm, PyObject *__pyx_v_fl, PyObject *__pyx_v_mmax, PyObject *__pyx_v_inplace); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_12rotate_alm(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alm, double __pyx_v_psi, double __pyx_v_theta, double __pyx_v_phi, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_14alm_getlmmax(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_a, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_16mkmask(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_m); /* proto */
-static PyObject *__pyx_pf_6healpy_9_sphtools_18count_bad(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_m); /* proto */
-static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
-static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
-static char __pyx_k_B[] = "B";
-static char __pyx_k_H[] = "H";
-static char __pyx_k_I[] = "I";
-static char __pyx_k_L[] = "L";
-static char __pyx_k_O[] = "O";
-static char __pyx_k_Q[] = "Q";
-static char __pyx_k_a[] = "a";
-static char __pyx_k_b[] = "b";
-static char __pyx_k_d[] = "d";
-static char __pyx_k_f[] = "f";
-static char __pyx_k_g[] = "g";
-static char __pyx_k_h[] = "h";
-static char __pyx_k_i[] = "i";
-static char __pyx_k_j[] = "j";
-static char __pyx_k_l[] = "l";
-static char __pyx_k_m[] = "m";
-static char __pyx_k_n[] = "n";
-static char __pyx_k_q[] = "q";
-static char __pyx_k_A1[] = "A1";
-static char __pyx_k_A2[] = "A2";
-static char __pyx_k_AC[] = "AC";
-static char __pyx_k_AG[] = "AG";
-static char __pyx_k_AI[] = "AI";
-static char __pyx_k_M1[] = "M1";
-static char __pyx_k_M2[] = "M2";
-static char __pyx_k_MI[] = "MI";
-static char __pyx_k_MQ[] = "MQ";
-static char __pyx_k_MU[] = "MU";
-static char __pyx_k_Zd[] = "Zd";
-static char __pyx_k_Zf[] = "Zf";
-static char __pyx_k_Zg[] = "Zg";
-static char __pyx_k_ac[] = "ac";
-static char __pyx_k_ag[] = "ag";
-static char __pyx_k_ai[] = "ai";
-static char __pyx_k_fl[] = "fl";
-static char __pyx_k_mi[] = "mi";
-static char __pyx_k_mq[] = "mq";
-static char __pyx_k_mu[] = "mu";
-static char __pyx_k_np[] = "np";
-static char __pyx_k_os[] = "os";
-static char __pyx_k_alm[] = "alm";
-static char __pyx_k_len[] = "__len__";
-static char __pyx_k_phi[] = "phi";
-static char __pyx_k_psi[] = "psi";
-static char __pyx_k_zip[] = "zip";
-static char __pyx_k_alm1[] = "alm1_";
-static char __pyx_k_alm2[] = "alm2_";
-static char __pyx_k_almC[] = "almC";
-static char __pyx_k_almG[] = "almG";
-static char __pyx_k_almI[] = "almI";
-static char __pyx_k_alms[] = "alms";
-static char __pyx_k_copy[] = "copy";
-static char __pyx_k_data[] = "data";
-static char __pyx_k_file[] = "__file__";
-static char __pyx_k_fl_2[] = "fl_";
-static char __pyx_k_info[] = "info";
-static char __pyx_k_int8[] = "int8";
-static char __pyx_k_join[] = "join";
-static char __pyx_k_lmax[] = "lmax";
-static char __pyx_k_main[] = "__main__";
-static char __pyx_k_maps[] = "maps";
-static char __pyx_k_mask[] = "mask";
-static char __pyx_k_maxm[] = "maxm";
-static char __pyx_k_mmax[] = "mmax";
-static char __pyx_k_ndim[] = "ndim";
-static char __pyx_k_npix[] = "npix";
-static char __pyx_k_path[] = "path";
-static char __pyx_k_size[] = "size";
-static char __pyx_k_spin[] = "spin";
-static char __pyx_k_sqrt[] = "sqrt";
-static char __pyx_k_test[] = "__test__";
-static char __pyx_k_Nspec[] = "Nspec";
-static char __pyx_k_alm_2[] = "alm_";
-static char __pyx_k_alms2[] = "alms2";
-static char __pyx_k_array[] = "array";
-static char __pyx_k_dtype[] = "dtype";
-static char __pyx_k_empty[] = "empty";
-static char __pyx_k_limit[] = "limit";
-static char __pyx_k_masks[] = "masks";
-static char __pyx_k_n_alm[] = "n_alm";
-static char __pyx_k_niter[] = "niter";
-static char __pyx_k_nside[] = "nside";
-static char __pyx_k_numpy[] = "numpy";
-static char __pyx_k_range[] = "range";
-static char __pyx_k_theta[] = "theta";
-static char __pyx_k_w_arr[] = "w_arr";
-static char __pyx_k_zeros[] = "zeros";
-static char __pyx_k_Nspec2[] = "Nspec2";
-static char __pyx_k_alm2cl[] = "alm2cl";
-static char __pyx_k_alms_c[] = "alms_c";
-static char __pyx_k_almxfl[] = "almxfl";
-static char __pyx_k_append[] = "append";
-static char __pyx_k_flsize[] = "flsize";
-static char __pyx_k_healpy[] = "healpy";
-static char __pyx_k_import[] = "__import__";
-static char __pyx_k_isfile[] = "isfile";
-static char __pyx_k_lmax_2[] = "lmax_";
-static char __pyx_k_maps_c[] = "maps_c";
-static char __pyx_k_mmax_2[] = "mmax_";
-static char __pyx_k_xrange[] = "xrange";
-static char __pyx_k_IOError[] = "IOError";
-static char __pyx_k_abspath[] = "abspath";
-static char __pyx_k_almsize[] = "almsize";
-static char __pyx_k_dirname[] = "dirname";
-static char __pyx_k_float64[] = "float64";
-static char __pyx_k_inplace[] = "inplace";
-static char __pyx_k_map2alm[] = "map2alm";
-static char __pyx_k_maptype[] = "maptype";
-static char __pyx_k_mask_mi[] = "mask_mi";
-static char __pyx_k_mask_mq[] = "mask_mq";
-static char __pyx_k_mask_mu[] = "mask_mu";
-static char __pyx_k_powspec[] = "powspec_";
-static char __pyx_k_spectra[] = "spectra";
-static char __pyx_k_DATAPATH[] = "DATAPATH";
-static char __pyx_k_datapath[] = "datapath";
-static char __pyx_k_lmax_out[] = "lmax_out";
-static char __pyx_k_ValueError[] = "ValueError";
-static char __pyx_k_c_datapath[] = "c_datapath";
-static char __pyx_k_complex128[] = "complex128";
-static char __pyx_k_lmax_out_2[] = "lmax_out_";
-static char __pyx_k_npix2nside[] = "npix2nside";
-static char __pyx_k_nside2npix[] = "nside2npix";
-static char __pyx_k_rotate_alm[] = "rotate_alm";
-static char __pyx_k_weightfile[] = "weightfile";
-static char __pyx_k_alms_lonely[] = "alms_lonely";
-static char __pyx_k_use_weights[] = "use_weights";
-static char __pyx_k_RuntimeError[] = "RuntimeError";
-static char __pyx_k_alm_getlmmax[] = "alm_getlmmax";
-static char __pyx_k_get_datapath[] = "get_datapath";
-static char __pyx_k_polarization[] = "polarization";
-static char __pyx_k_Invalid_input[] = "Invalid input.";
-static char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
-static char __pyx_k_healpy__sphtools[] = "healpy._sphtools";
-static char __pyx_k_healpy_pixelfunc[] = "healpy.pixelfunc";
-static char __pyx_k_ascontiguousarray[] = "ascontiguousarray";
-static char __pyx_k_mmax_must_be_lmax[] = "mmax must be <= lmax";
-static char __pyx_k_pyx_releasebuffer[] = "__pyx_releasebuffer";
-static char __pyx_k_alm2map_spin_healpy[] = "alm2map_spin_healpy";
-static char __pyx_k_map2alm_spin_healpy[] = "map2alm_spin_healpy";
-static char __pyx_k_weight_ring_n_05d_fits[] = "weight_ring_n%05d.fits";
-static char __pyx_k_Weight_file_not_found_in_s[] = "Weight file not found in %s";
-static char __pyx_k_ndarray_is_not_C_contiguous[] = "ndarray is not C contiguous";
-static char __pyx_k_all_alms_must_have_same_size[] = "all alms must have same size";
-static char __pyx_k_Input_maps_must_have_same_size[] = "Input maps must have same size";
-static char __pyx_k_Wrong_input_map_must_be_a_valid[] = "Wrong input map (must be a valid healpix map or a sequence of 1 or 3 maps)";
-static char __pyx_k_home_zonca_healpy_healpy_src__s[] = "/home/zonca/healpy/healpy/src/_sphtools.pyx";
-static char __pyx_k_unknown_dtype_code_in_numpy_pxd[] = "unknown dtype code in numpy.pxd (%d)";
-static char __pyx_k_Format_string_allocated_too_shor[] = "Format string allocated too short, see comment in numpy.pxd";
-static char __pyx_k_Non_native_byte_order_not_suppor[] = "Non-native byte order not supported";
-static char __pyx_k_alms2_must_be_an_array_or_a_sequ[] = "alms2 must be an array or a sequence of arrays";
-static char __pyx_k_alms_and_alms2_must_have_same_nu[] = "alms and alms2 must have same number of spectra";
-static char __pyx_k_alms_must_be_an_array_or_a_seque[] = "alms must be an array or a sequence of arrays";
-static char __pyx_k_ndarray_is_not_Fortran_contiguou[] = "ndarray is not Fortran contiguous";
-static char __pyx_k_Format_string_allocated_too_shor_2[] = "Format string allocated too short.";
-static PyObject *__pyx_n_s_A1;
-static PyObject *__pyx_n_s_A2;
-static PyObject *__pyx_n_s_AC;
-static PyObject *__pyx_n_s_AG;
-static PyObject *__pyx_n_s_AI;
-static PyObject *__pyx_n_s_DATAPATH;
-static PyObject *__pyx_kp_u_Format_string_allocated_too_shor;
-static PyObject *__pyx_kp_u_Format_string_allocated_too_shor_2;
-static PyObject *__pyx_n_s_IOError;
-static PyObject *__pyx_kp_s_Input_maps_must_have_same_size;
-static PyObject *__pyx_kp_s_Invalid_input;
-static PyObject *__pyx_n_s_M1;
-static PyObject *__pyx_n_s_M2;
-static PyObject *__pyx_n_s_MI;
-static PyObject *__pyx_n_s_MQ;
-static PyObject *__pyx_n_s_MU;
-static PyObject *__pyx_kp_u_Non_native_byte_order_not_suppor;
-static PyObject *__pyx_n_s_Nspec;
-static PyObject *__pyx_n_s_Nspec2;
-static PyObject *__pyx_n_s_RuntimeError;
-static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_kp_s_Weight_file_not_found_in_s;
-static PyObject *__pyx_kp_s_Wrong_input_map_must_be_a_valid;
-static PyObject *__pyx_n_s_a;
-static PyObject *__pyx_n_s_abspath;
-static PyObject *__pyx_n_s_ac;
-static PyObject *__pyx_n_s_ag;
-static PyObject *__pyx_n_s_ai;
-static PyObject *__pyx_kp_s_all_alms_must_have_same_size;
-static PyObject *__pyx_n_s_alm;
-static PyObject *__pyx_n_s_alm1;
-static PyObject *__pyx_n_s_alm2;
-static PyObject *__pyx_n_s_alm2cl;
-static PyObject *__pyx_n_s_alm2map_spin_healpy;
-static PyObject *__pyx_n_s_almC;
-static PyObject *__pyx_n_s_almG;
-static PyObject *__pyx_n_s_almI;
-static PyObject *__pyx_n_s_alm_2;
-static PyObject *__pyx_n_s_alm_getlmmax;
-static PyObject *__pyx_n_s_alms;
-static PyObject *__pyx_n_s_alms2;
-static PyObject *__pyx_kp_s_alms2_must_be_an_array_or_a_sequ;
-static PyObject *__pyx_kp_s_alms_and_alms2_must_have_same_nu;
-static PyObject *__pyx_n_s_alms_c;
-static PyObject *__pyx_n_s_alms_lonely;
-static PyObject *__pyx_kp_s_alms_must_be_an_array_or_a_seque;
-static PyObject *__pyx_n_s_almsize;
-static PyObject *__pyx_n_s_almxfl;
-static PyObject *__pyx_n_s_append;
-static PyObject *__pyx_n_s_array;
-static PyObject *__pyx_n_s_ascontiguousarray;
-static PyObject *__pyx_n_s_c_datapath;
-static PyObject *__pyx_n_s_complex128;
-static PyObject *__pyx_n_s_copy;
-static PyObject *__pyx_n_s_data;
-static PyObject *__pyx_n_s_datapath;
-static PyObject *__pyx_n_s_dirname;
-static PyObject *__pyx_n_s_dtype;
-static PyObject *__pyx_n_s_empty;
-static PyObject *__pyx_n_s_f;
-static PyObject *__pyx_n_s_file;
-static PyObject *__pyx_n_s_fl;
-static PyObject *__pyx_n_s_fl_2;
-static PyObject *__pyx_n_s_float64;
-static PyObject *__pyx_n_s_flsize;
-static PyObject *__pyx_n_s_get_datapath;
-static PyObject *__pyx_n_s_healpy;
-static PyObject *__pyx_n_s_healpy__sphtools;
-static PyObject *__pyx_n_s_healpy_pixelfunc;
-static PyObject *__pyx_kp_s_home_zonca_healpy_healpy_src__s;
-static PyObject *__pyx_n_s_i;
-static PyObject *__pyx_n_s_import;
-static PyObject *__pyx_n_s_info;
-static PyObject *__pyx_n_s_inplace;
-static PyObject *__pyx_n_s_int8;
-static PyObject *__pyx_n_s_isfile;
-static PyObject *__pyx_n_s_j;
-static PyObject *__pyx_n_s_join;
-static PyObject *__pyx_n_s_l;
-static PyObject *__pyx_n_s_len;
-static PyObject *__pyx_n_s_limit;
-static PyObject *__pyx_n_s_lmax;
-static PyObject *__pyx_n_s_lmax_2;
-static PyObject *__pyx_n_s_lmax_out;
-static PyObject *__pyx_n_s_lmax_out_2;
-static PyObject *__pyx_n_s_m;
-static PyObject *__pyx_n_s_main;
-static PyObject *__pyx_n_s_map2alm;
-static PyObject *__pyx_n_s_map2alm_spin_healpy;
-static PyObject *__pyx_n_s_maps;
-static PyObject *__pyx_n_s_maps_c;
-static PyObject *__pyx_n_s_maptype;
-static PyObject *__pyx_n_s_mask;
-static PyObject *__pyx_n_s_mask_mi;
-static PyObject *__pyx_n_s_mask_mq;
-static PyObject *__pyx_n_s_mask_mu;
-static PyObject *__pyx_n_s_masks;
-static PyObject *__pyx_n_s_maxm;
-static PyObject *__pyx_n_s_mi;
-static PyObject *__pyx_n_s_mmax;
-static PyObject *__pyx_n_s_mmax_2;
-static PyObject *__pyx_kp_s_mmax_must_be_lmax;
-static PyObject *__pyx_n_s_mq;
-static PyObject *__pyx_n_s_mu;
-static PyObject *__pyx_n_s_n;
-static PyObject *__pyx_n_s_n_alm;
-static PyObject *__pyx_kp_u_ndarray_is_not_C_contiguous;
-static PyObject *__pyx_kp_u_ndarray_is_not_Fortran_contiguou;
-static PyObject *__pyx_n_s_ndim;
-static PyObject *__pyx_n_s_niter;
-static PyObject *__pyx_n_s_np;
-static PyObject *__pyx_n_s_npix;
-static PyObject *__pyx_n_s_npix2nside;
-static PyObject *__pyx_n_s_nside;
-static PyObject *__pyx_n_s_nside2npix;
-static PyObject *__pyx_n_s_numpy;
-static PyObject *__pyx_n_s_os;
-static PyObject *__pyx_n_s_path;
-static PyObject *__pyx_n_s_phi;
-static PyObject *__pyx_n_s_polarization;
-static PyObject *__pyx_n_s_powspec;
-static PyObject *__pyx_n_s_psi;
-static PyObject *__pyx_n_s_pyx_getbuffer;
-static PyObject *__pyx_n_s_pyx_releasebuffer;
-static PyObject *__pyx_n_s_range;
-static PyObject *__pyx_n_s_rotate_alm;
-static PyObject *__pyx_n_s_size;
-static PyObject *__pyx_n_s_spectra;
-static PyObject *__pyx_n_s_spin;
-static PyObject *__pyx_n_s_sqrt;
-static PyObject *__pyx_n_s_test;
-static PyObject *__pyx_n_s_theta;
-static PyObject *__pyx_kp_u_unknown_dtype_code_in_numpy_pxd;
-static PyObject *__pyx_n_s_use_weights;
-static PyObject *__pyx_n_s_w_arr;
-static PyObject *__pyx_kp_s_weight_ring_n_05d_fits;
-static PyObject *__pyx_n_s_weightfile;
-static PyObject *__pyx_n_s_xrange;
-static PyObject *__pyx_n_s_zeros;
-static PyObject *__pyx_n_s_zip;
-static PyObject *__pyx_float_0_0;
+static char __pyx_k_1[] = "mmax must be <= lmax";
+static char __pyx_k_3[] = "Already init...";
+static char __pyx_k_8[] = "Wrong input map (must be a valid healpix map or a sequence of 1 or 3 maps)";
+static char __pyx_k_10[] = "Input maps must have same size";
+static char __pyx_k_12[] = "weight_ring_n%05d.fits";
+static char __pyx_k_13[] = "Weight file not found in %s";
+static char __pyx_k_14[] = "alms must be an array or a sequence of arrays";
+static char __pyx_k_16[] = "alms2 must be an array or a sequence of arrays";
+static char __pyx_k_18[] = "alms and alms2 must have same number of spectra";
+static char __pyx_k_20[] = "all alms must have same size";
+static char __pyx_k_23[] = "ndarray is not C contiguous";
+static char __pyx_k_25[] = "ndarray is not Fortran contiguous";
+static char __pyx_k_27[] = "Non-native byte order not supported";
+static char __pyx_k_29[] = "unknown dtype code in numpy.pxd (%d)";
+static char __pyx_k_30[] = "Format string allocated too short, see comment in numpy.pxd";
+static char __pyx_k_33[] = "Format string allocated too short.";
+static char __pyx_k_35[] = "healpy.pixelfunc";
+static char __pyx_k_36[] = "healpy._sphtools";
+static char __pyx_k__B[] = "B";
+static char __pyx_k__H[] = "H";
+static char __pyx_k__I[] = "I";
+static char __pyx_k__L[] = "L";
+static char __pyx_k__O[] = "O";
+static char __pyx_k__Q[] = "Q";
+static char __pyx_k__b[] = "b";
+static char __pyx_k__d[] = "d";
+static char __pyx_k__f[] = "f";
+static char __pyx_k__g[] = "g";
+static char __pyx_k__h[] = "h";
+static char __pyx_k__i[] = "i";
+static char __pyx_k__l[] = "l";
+static char __pyx_k__m[] = "m";
+static char __pyx_k__q[] = "q";
+static char __pyx_k__Zd[] = "Zd";
+static char __pyx_k__Zf[] = "Zf";
+static char __pyx_k__Zg[] = "Zg";
+static char __pyx_k__fl[] = "fl";
+static char __pyx_k__np[] = "np";
+static char __pyx_k__os[] = "os";
+static char __pyx_k__pi[] = "pi";
+static char __pyx_k__alm[] = "alm";
+static char __pyx_k__alms[] = "alms";
+static char __pyx_k__copy[] = "copy";
+static char __pyx_k__data[] = "data";
+static char __pyx_k__int8[] = "int8";
+static char __pyx_k__join[] = "join";
+static char __pyx_k__lmax[] = "lmax";
+static char __pyx_k__mmax[] = "mmax";
+static char __pyx_k__path[] = "path";
+static char __pyx_k__size[] = "size";
+static char __pyx_k__sqrt[] = "sqrt";
+static char __pyx_k__alms2[] = "alms2";
+static char __pyx_k__array[] = "array";
+static char __pyx_k__dtype[] = "dtype";
+static char __pyx_k__empty[] = "empty";
+static char __pyx_k__niter[] = "niter";
+static char __pyx_k__numpy[] = "numpy";
+static char __pyx_k__range[] = "range";
+static char __pyx_k__zeros[] = "zeros";
+static char __pyx_k__alm2cl[] = "alm2cl";
+static char __pyx_k__almxfl[] = "almxfl";
+static char __pyx_k__healpy[] = "healpy";
+static char __pyx_k__isfile[] = "isfile";
+static char __pyx_k__xrange[] = "xrange";
+static char __pyx_k__IOError[] = "IOError";
+static char __pyx_k____len__[] = "__len__";
+static char __pyx_k__abspath[] = "abspath";
+static char __pyx_k__dirname[] = "dirname";
+static char __pyx_k__float64[] = "float64";
+static char __pyx_k__inplace[] = "inplace";
+static char __pyx_k__map2alm[] = "map2alm";
+static char __pyx_k__maptype[] = "maptype";
+static char __pyx_k__DATAPATH[] = "DATAPATH";
+static char __pyx_k____file__[] = "__file__";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__datapath[] = "datapath";
+static char __pyx_k__lmax_out[] = "lmax_out";
+static char __pyx_k__Exception[] = "Exception";
+static char __pyx_k__ValueError[] = "ValueError";
+static char __pyx_k__complex128[] = "complex128";
+static char __pyx_k__npix2nside[] = "npix2nside";
+static char __pyx_k__regression[] = "regression";
+static char __pyx_k__use_weights[] = "use_weights";
+static char __pyx_k__RuntimeError[] = "RuntimeError";
+static char __pyx_k__get_datapath[] = "get_datapath";
+static char __pyx_k__ascontiguousarray[] = "ascontiguousarray";
+static PyObject *__pyx_kp_s_1;
+static PyObject *__pyx_kp_s_10;
+static PyObject *__pyx_kp_s_12;
+static PyObject *__pyx_kp_s_13;
+static PyObject *__pyx_kp_s_14;
+static PyObject *__pyx_kp_s_16;
+static PyObject *__pyx_kp_s_18;
+static PyObject *__pyx_kp_s_20;
+static PyObject *__pyx_kp_u_23;
+static PyObject *__pyx_kp_u_25;
+static PyObject *__pyx_kp_u_27;
+static PyObject *__pyx_kp_u_29;
+static PyObject *__pyx_kp_s_3;
+static PyObject *__pyx_kp_u_30;
+static PyObject *__pyx_kp_u_33;
+static PyObject *__pyx_n_s_35;
+static PyObject *__pyx_n_s_36;
+static PyObject *__pyx_kp_s_8;
+static PyObject *__pyx_n_s__DATAPATH;
+static PyObject *__pyx_n_s__Exception;
+static PyObject *__pyx_n_s__IOError;
+static PyObject *__pyx_n_s__RuntimeError;
+static PyObject *__pyx_n_s__ValueError;
+static PyObject *__pyx_n_s____file__;
+static PyObject *__pyx_n_s____len__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__abspath;
+static PyObject *__pyx_n_s__alm;
+static PyObject *__pyx_n_s__alm2cl;
+static PyObject *__pyx_n_s__alms;
+static PyObject *__pyx_n_s__alms2;
+static PyObject *__pyx_n_s__almxfl;
+static PyObject *__pyx_n_s__array;
+static PyObject *__pyx_n_s__ascontiguousarray;
+static PyObject *__pyx_n_s__complex128;
+static PyObject *__pyx_n_s__copy;
+static PyObject *__pyx_n_s__data;
+static PyObject *__pyx_n_s__datapath;
+static PyObject *__pyx_n_s__dirname;
+static PyObject *__pyx_n_s__dtype;
+static PyObject *__pyx_n_s__empty;
+static PyObject *__pyx_n_s__fl;
+static PyObject *__pyx_n_s__float64;
+static PyObject *__pyx_n_s__get_datapath;
+static PyObject *__pyx_n_s__healpy;
+static PyObject *__pyx_n_s__inplace;
+static PyObject *__pyx_n_s__int8;
+static PyObject *__pyx_n_s__isfile;
+static PyObject *__pyx_n_s__join;
+static PyObject *__pyx_n_s__lmax;
+static PyObject *__pyx_n_s__lmax_out;
+static PyObject *__pyx_n_s__m;
+static PyObject *__pyx_n_s__map2alm;
+static PyObject *__pyx_n_s__maptype;
+static PyObject *__pyx_n_s__mmax;
+static PyObject *__pyx_n_s__niter;
+static PyObject *__pyx_n_s__np;
+static PyObject *__pyx_n_s__npix2nside;
+static PyObject *__pyx_n_s__numpy;
+static PyObject *__pyx_n_s__os;
+static PyObject *__pyx_n_s__path;
+static PyObject *__pyx_n_s__pi;
+static PyObject *__pyx_n_s__range;
+static PyObject *__pyx_n_s__regression;
+static PyObject *__pyx_n_s__size;
+static PyObject *__pyx_n_s__sqrt;
+static PyObject *__pyx_n_s__use_weights;
+static PyObject *__pyx_n_s__xrange;
+static PyObject *__pyx_n_s__zeros;
 static PyObject *__pyx_int_0;
 static PyObject *__pyx_int_1;
 static PyObject *__pyx_int_2;
 static PyObject *__pyx_int_3;
+static PyObject *__pyx_int_4;
 static PyObject *__pyx_int_neg_3;
-static PyObject *__pyx_tuple_;
-static PyObject *__pyx_tuple__2;
-static PyObject *__pyx_tuple__3;
-static PyObject *__pyx_tuple__4;
-static PyObject *__pyx_tuple__5;
-static PyObject *__pyx_tuple__6;
-static PyObject *__pyx_tuple__7;
-static PyObject *__pyx_tuple__8;
-static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_tuple__10;
-static PyObject *__pyx_tuple__11;
-static PyObject *__pyx_tuple__12;
-static PyObject *__pyx_tuple__13;
-static PyObject *__pyx_tuple__14;
-static PyObject *__pyx_tuple__15;
-static PyObject *__pyx_tuple__17;
-static PyObject *__pyx_tuple__19;
-static PyObject *__pyx_tuple__21;
-static PyObject *__pyx_tuple__23;
-static PyObject *__pyx_tuple__25;
-static PyObject *__pyx_tuple__27;
-static PyObject *__pyx_tuple__29;
-static PyObject *__pyx_codeobj__16;
-static PyObject *__pyx_codeobj__18;
-static PyObject *__pyx_codeobj__20;
-static PyObject *__pyx_codeobj__22;
-static PyObject *__pyx_codeobj__24;
-static PyObject *__pyx_codeobj__26;
-static PyObject *__pyx_codeobj__28;
-static PyObject *__pyx_codeobj__30;
+static PyObject *__pyx_int_15;
+static PyObject *__pyx_k_6;
+static PyObject *__pyx_k_7;
+static PyObject *__pyx_k_22;
+static PyObject *__pyx_k_tuple_2;
+static PyObject *__pyx_k_tuple_4;
+static PyObject *__pyx_k_tuple_5;
+static PyObject *__pyx_k_tuple_9;
+static PyObject *__pyx_k_tuple_11;
+static PyObject *__pyx_k_tuple_15;
+static PyObject *__pyx_k_tuple_17;
+static PyObject *__pyx_k_tuple_19;
+static PyObject *__pyx_k_tuple_21;
+static PyObject *__pyx_k_tuple_24;
+static PyObject *__pyx_k_tuple_26;
+static PyObject *__pyx_k_tuple_28;
+static PyObject *__pyx_k_tuple_31;
+static PyObject *__pyx_k_tuple_32;
+static PyObject *__pyx_k_tuple_34;
 
-/* "healpy/src/_sphtools.pyx":54
- * DATAPATH = None
+/* "healpy/src/_sphtools.pyx":67
+ *     cdef xcomplex[double]* cast_to_ptr_xcomplex_d(char *)
  * 
- * def get_datapath():             # <<<<<<<<<<<<<<
- *     global DATAPATH
- *     if DATAPATH is None:
+ * cdef Num_Alms(int l, int m):             # <<<<<<<<<<<<<<
+ *     if not m <= l:
+ *         raise ValueError("mmax must be <= lmax")
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_1get_datapath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_1get_datapath = {__Pyx_NAMESTR("get_datapath"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_1get_datapath, METH_NOARGS, __Pyx_DOCSTR(0)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_1get_datapath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("get_datapath (wrapper)", 0);
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_get_datapath(__pyx_self);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_get_datapath(CYTHON_UNUSED PyObject *__pyx_self) {
+static PyObject *__pyx_f_6healpy_9_sphtools_Num_Alms(int __pyx_v_l, int __pyx_v_m) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_datapath", 0);
+  __Pyx_RefNannySetupContext("Num_Alms");
 
-  /* "healpy/src/_sphtools.pyx":56
- * def get_datapath():
- *     global DATAPATH
- *     if DATAPATH is None:             # <<<<<<<<<<<<<<
- *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
- *     return DATAPATH
+  /* "healpy/src/_sphtools.pyx":68
+ * 
+ * cdef Num_Alms(int l, int m):
+ *     if not m <= l:             # <<<<<<<<<<<<<<
+ *         raise ValueError("mmax must be <= lmax")
+ *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
  */
-  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_DATAPATH); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__pyx_t_1 == Py_None);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (__pyx_t_2 != 0);
-  if (__pyx_t_3) {
+  __pyx_t_1 = (!(__pyx_v_m <= __pyx_v_l));
+  if (__pyx_t_1) {
 
-    /* "healpy/src/_sphtools.pyx":57
- *     global DATAPATH
- *     if DATAPATH is None:
- *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')             # <<<<<<<<<<<<<<
- *     return DATAPATH
+    /* "healpy/src/_sphtools.pyx":69
+ * cdef Num_Alms(int l, int m):
+ *     if not m <= l:
+ *         raise ValueError("mmax must be <= lmax")             # <<<<<<<<<<<<<<
+ *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
  * 
  */
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_path); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_join); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_dirname); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_abspath); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_file); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_6);
-    __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_6);
-    __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_6);
-    __Pyx_INCREF(__pyx_n_s_data);
-    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_n_s_data);
-    __Pyx_GIVEREF(__pyx_n_s_data);
-    __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_1, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (PyDict_SetItem(__pyx_d, __pyx_n_s_DATAPATH, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_2), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     goto __pyx_L3;
   }
   __pyx_L3:;
 
-  /* "healpy/src/_sphtools.pyx":58
- *     if DATAPATH is None:
- *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
- *     return DATAPATH             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":70
+ *     if not m <= l:
+ *         raise ValueError("mmax must be <= lmax")
+ *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)             # <<<<<<<<<<<<<<
  * 
- * def map2alm_spin_healpy(maps, spin, lmax = None, mmax = None):
+ * cdef class WrapMap(object):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_DATAPATH); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_r = __pyx_t_6;
-  __pyx_t_6 = 0;
+  __pyx_t_2 = PyInt_FromLong((__Pyx_div_long(((__pyx_v_m + 1) * (__pyx_v_m + 2)), 2) + ((__pyx_v_m + 1) * (__pyx_v_l - __pyx_v_m)))); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":54
- * DATAPATH = None
- * 
- * def get_datapath():             # <<<<<<<<<<<<<<
- *     global DATAPATH
- *     if DATAPATH is None:
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("healpy._sphtools.get_datapath", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("healpy._sphtools.Num_Alms", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":60
- *     return DATAPATH
- * 
- * def map2alm_spin_healpy(maps, spin, lmax = None, mmax = None):             # <<<<<<<<<<<<<<
- *     """Computes the spinned alm of a 2 Healpix maps.
+/* "healpy/src/_sphtools.pyx":80
+ *     cdef int is_init
  * 
+ *     def __init__(self, np.ndarray[double] m):             # <<<<<<<<<<<<<<
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_3map2alm_spin_healpy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_2map2alm_spin_healpy[] = "Computes the spinned alm of a 2 Healpix maps.\n\n    Parameters\n    ----------\n    m : list of 2 arrays\n        list of 2 input maps as numpy arrays\n    spin : int\n        spin of the alms (either 1, 2 or 3)\n    lmax : int, scalar, optional\n      Maximum l of the power spectrum. Default: 3*nside-1\n    mmax : int, scalar, optional\n      Maximum m of the alm. Default: lmax\n    \n    Returns\n    -------\n    alms : list of 2 arrays\n      list of 2 alms\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_3map2alm_spin_healpy = {__Pyx_NAMESTR("map2alm_spin_healpy"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_3map2alm_spin_healpy, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_2map2alm_spin_healpy)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_3map2alm_spin_healpy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_maps = 0;
-  PyObject *__pyx_v_spin = 0;
-  PyObject *__pyx_v_lmax = 0;
-  PyObject *__pyx_v_mmax = 0;
+static int __pyx_pf_6healpy_9_sphtools_7WrapMap___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pf_6healpy_9_sphtools_7WrapMap___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_m = 0;
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  size_t __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("map2alm_spin_healpy (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,0};
+  __Pyx_RefNannySetupContext("__init__");
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_maps,&__pyx_n_s_spin,&__pyx_n_s_lmax,&__pyx_n_s_mmax,0};
-    PyObject* values[4] = {0,0,0,0};
-    values[2] = ((PyObject *)Py_None);
-    values[3] = ((PyObject *)Py_None);
+    PyObject* values[1] = {0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maps)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
-        case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_spin)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("map2alm_spin_healpy", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  2:
-        if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax);
-          if (value) { values[2] = value; kw_args--; }
-        }
-        case  3:
-        if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
-          if (value) { values[3] = value; kw_args--; }
-        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map2alm_spin_healpy") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (PyTuple_GET_SIZE(__pyx_args)) {
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
-    __pyx_v_maps = values[0];
-    __pyx_v_spin = values[1];
-    __pyx_v_lmax = values[2];
-    __pyx_v_mmax = values[3];
+    __pyx_v_m = ((PyArrayObject *)values[0]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("map2alm_spin_healpy", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._sphtools.map2alm_spin_healpy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._sphtools.WrapMap.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
-  return NULL;
+  return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_2map2alm_spin_healpy(__pyx_self, __pyx_v_maps, __pyx_v_spin, __pyx_v_lmax, __pyx_v_mmax);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_2map2alm_spin_healpy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_maps, PyObject *__pyx_v_spin, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax) {
-  PyObject *__pyx_v_maps_c = NULL;
-  PyObject *__pyx_v_masks = NULL;
-  int __pyx_v_lmax_;
-  int __pyx_v_mmax_;
-  int __pyx_v_nside;
-  int __pyx_v_npix;
-  Healpix_Map<double> *__pyx_v_M1;
-  Healpix_Map<double> *__pyx_v_M2;
-  PyObject *__pyx_v_m = NULL;
-  PyObject *__pyx_v_mask = NULL;
-  int __pyx_v_n_alm;
-  PyObject *__pyx_v_alms = NULL;
-  Alm<xcomplex<double> > *__pyx_v_A1;
-  Alm<xcomplex<double> > *__pyx_v_A2;
-  arr<double> *__pyx_v_w_arr;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
-  PyObject *(*__pyx_t_4)(PyObject *);
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  int __pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_t_12;
-  Healpix_Map<double> *__pyx_t_13;
-  PyObject *(*__pyx_t_14)(PyObject *);
-  Alm<xcomplex<double> > *__pyx_t_15;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("map2alm_spin_healpy", 0);
-
-  /* "healpy/src/_sphtools.pyx":79
- *       list of 2 alms
- *     """
- *     maps_c = [np.ascontiguousarray(m, dtype=np.float64) for m in maps]             # <<<<<<<<<<<<<<
- * 
- *     # create UNSEEN mask for map
- */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyList_CheckExact(__pyx_v_maps) || PyTuple_CheckExact(__pyx_v_maps)) {
-    __pyx_t_2 = __pyx_v_maps; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_maps); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext;
-  }
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_5 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_5)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_5);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_m, __pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_INCREF(__pyx_v_m);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_m);
-    __Pyx_GIVEREF(__pyx_v_m);
-    __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_float64); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_dtype, __pyx_t_9) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __pyx_t_9 = PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_7); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_9))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_maps_c = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "healpy/src/_sphtools.pyx":82
- * 
- *     # create UNSEEN mask for map
- *     masks = [False if count_bad(m) == 0 else mkmask(m) for m in maps_c]             # <<<<<<<<<<<<<<
- * 
- *     # Adjust lmax and mmax
- */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __pyx_v_maps_c; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-  for (;;) {
-    if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    __pyx_t_9 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_9); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #else
-    __pyx_t_9 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #endif
-    __Pyx_XDECREF_SET(__pyx_v_m, __pyx_t_9);
-    __pyx_t_9 = 0;
-    if (!(likely(((__pyx_v_m) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_m, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_m), 0) == 0) != 0)) {
-      __Pyx_INCREF(Py_False);
-      __pyx_t_9 = Py_False;
-    } else {
-      if (!(likely(((__pyx_v_m) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_m, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_7 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_m), 0); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_t_9 = __pyx_t_7;
-      __pyx_t_7 = 0;
-    }
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_9))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_masks = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "healpy/src/_sphtools.pyx":86
- *     # Adjust lmax and mmax
- *     cdef int lmax_, mmax_, nside, npix
- *     npix = maps_c[0].size             # <<<<<<<<<<<<<<
- *     nside = npix2nside(npix)
- *     if lmax is None:
- */
-  __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_maps_c, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_size); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_npix = __pyx_t_10;
-
-  /* "healpy/src/_sphtools.pyx":87
- *     cdef int lmax_, mmax_, nside, npix
- *     npix = maps_c[0].size
- *     nside = npix2nside(npix)             # <<<<<<<<<<<<<<
- *     if lmax is None:
- *         lmax_ = 3 * nside - 1
- */
-  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_npix2nside); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_npix); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __pyx_t_1 = 0;
-  __pyx_t_1 = PyObject_Call(__pyx_t_2, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_nside = __pyx_t_10;
-
-  /* "healpy/src/_sphtools.pyx":88
- *     npix = maps_c[0].size
- *     nside = npix2nside(npix)
- *     if lmax is None:             # <<<<<<<<<<<<<<
- *         lmax_ = 3 * nside - 1
- *     else:
- */
-  __pyx_t_11 = (__pyx_v_lmax == Py_None);
-  __pyx_t_12 = (__pyx_t_11 != 0);
-  if (__pyx_t_12) {
-
-    /* "healpy/src/_sphtools.pyx":89
- *     nside = npix2nside(npix)
- *     if lmax is None:
- *         lmax_ = 3 * nside - 1             # <<<<<<<<<<<<<<
- *     else:
- *         lmax_ = lmax
- */
-    __pyx_v_lmax_ = ((3 * __pyx_v_nside) - 1);
-    goto __pyx_L7;
-  }
-  /*else*/ {
-
-    /* "healpy/src/_sphtools.pyx":91
- *         lmax_ = 3 * nside - 1
- *     else:
- *         lmax_ = lmax             # <<<<<<<<<<<<<<
- *     if mmax is None:
- *         mmax_ = lmax_
- */
-    __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_lmax_ = __pyx_t_10;
-  }
-  __pyx_L7:;
-
-  /* "healpy/src/_sphtools.pyx":92
- *     else:
- *         lmax_ = lmax
- *     if mmax is None:             # <<<<<<<<<<<<<<
- *         mmax_ = lmax_
- *     else:
- */
-  __pyx_t_12 = (__pyx_v_mmax == Py_None);
-  __pyx_t_11 = (__pyx_t_12 != 0);
-  if (__pyx_t_11) {
-
-    /* "healpy/src/_sphtools.pyx":93
- *         lmax_ = lmax
- *     if mmax is None:
- *         mmax_ = lmax_             # <<<<<<<<<<<<<<
- *     else:
- *         mmax_ = mmax
- */
-    __pyx_v_mmax_ = __pyx_v_lmax_;
-    goto __pyx_L8;
+  __pyx_bstruct_m.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  /*else*/ {
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
 
-    /* "healpy/src/_sphtools.pyx":95
- *         mmax_ = lmax_
- *     else:
- *         mmax_ = mmax             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":81
  * 
- *     # Check all maps have same npix
+ *     def __init__(self, np.ndarray[double] m):
+ *         if self.is_init == 1:             # <<<<<<<<<<<<<<
+ *             raise Exception('Already init...')
+ *         self.is_init = 1
  */
-    __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_mmax_ = __pyx_t_10;
-  }
-  __pyx_L8:;
+  __pyx_t_1 = (((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->is_init == 1);
+  if (__pyx_t_1) {
 
-  /* "healpy/src/_sphtools.pyx":98
- * 
- *     # Check all maps have same npix
- *     if maps_c[1].size != npix:             # <<<<<<<<<<<<<<
- *         raise ValueError("Input maps must have same size")
- * 
+    /* "healpy/src/_sphtools.pyx":82
+ *     def __init__(self, np.ndarray[double] m):
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')             # <<<<<<<<<<<<<<
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
  */
-  __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_maps_c, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_size); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_npix); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_9, __pyx_t_1, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_11 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__pyx_t_11) {
-
-    /* "healpy/src/_sphtools.pyx":99
- *     # Check all maps have same npix
- *     if maps_c[1].size != npix:
- *         raise ValueError("Input maps must have same size")             # <<<<<<<<<<<<<<
- * 
- *     # View the ndarray as a Healpix_Map
- */
-    __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
   }
+  __pyx_L6:;
 
-  /* "healpy/src/_sphtools.pyx":102
- * 
- *     # View the ndarray as a Healpix_Map
- *     M1 = ndarray2map(maps_c[0], RING)             # <<<<<<<<<<<<<<
- *     M2 = ndarray2map(maps_c[1], RING)
- * 
- */
-  __pyx_t_2 = __Pyx_GetItemInt_List(__pyx_v_maps_c, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_t_2), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_M1 = __pyx_t_13;
-
-  /* "healpy/src/_sphtools.pyx":103
- *     # View the ndarray as a Healpix_Map
- *     M1 = ndarray2map(maps_c[0], RING)
- *     M2 = ndarray2map(maps_c[1], RING)             # <<<<<<<<<<<<<<
- * 
- *     # replace UNSEEN pixels with zeros
- */
-  __pyx_t_2 = __Pyx_GetItemInt_List(__pyx_v_maps_c, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_t_2), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_M2 = __pyx_t_13;
-
-  /* "healpy/src/_sphtools.pyx":106
- * 
- *     # replace UNSEEN pixels with zeros
- *     for m, mask in zip(maps_c, masks):             # <<<<<<<<<<<<<<
- *         if mask:
- *             m[mask] = 0.0
+  /* "healpy/src/_sphtools.pyx":83
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')
+ *         self.is_init = 1             # <<<<<<<<<<<<<<
+ *         self.m = np.ascontiguousarray(m)
+ *         self.a = new arr[double](<double*>(<np.ndarray>self.m).data, (<np.ndarray>self.m).size)
+ */
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->is_init = 1;
+
+  /* "healpy/src/_sphtools.pyx":84
+ *             raise Exception('Already init...')
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)             # <<<<<<<<<<<<<<
+ *         self.a = new arr[double](<double*>(<np.ndarray>self.m).data, (<np.ndarray>self.m).size)
+ *         self.h = new Healpix_Map[double]()
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_v_maps_c);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_maps_c);
-  __Pyx_GIVEREF(__pyx_v_maps_c);
-  __Pyx_INCREF(__pyx_v_masks);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_masks);
-  __Pyx_GIVEREF(__pyx_v_masks);
-  __pyx_t_1 = PyObject_Call(__pyx_builtin_zip, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyList_CheckExact(__pyx_t_1) || PyTuple_CheckExact(__pyx_t_1)) {
-    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext;
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_1)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_1);
-    }
-    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-      PyObject* sequence = __pyx_t_1;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      Py_ssize_t size = Py_SIZE(sequence);
-      #else
-      Py_ssize_t size = PySequence_Size(sequence);
-      #endif
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      }
-      #if CYTHON_COMPILING_IN_CPYTHON
-      if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_9 = PyTuple_GET_ITEM(sequence, 0); 
-        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
-      } else {
-        __pyx_t_9 = PyList_GET_ITEM(sequence, 0); 
-        __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
-      }
-      __Pyx_INCREF(__pyx_t_9);
-      __Pyx_INCREF(__pyx_t_7);
-      #else
-      __pyx_t_9 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_7);
-      #endif
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    } else {
-      Py_ssize_t index = -1;
-      __pyx_t_5 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_14 = Py_TYPE(__pyx_t_5)->tp_iternext;
-      index = 0; __pyx_t_9 = __pyx_t_14(__pyx_t_5); if (unlikely(!__pyx_t_9)) goto __pyx_L12_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_9);
-      index = 1; __pyx_t_7 = __pyx_t_14(__pyx_t_5); if (unlikely(!__pyx_t_7)) goto __pyx_L12_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_7);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_14(__pyx_t_5), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_14 = NULL;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      goto __pyx_L13_unpacking_done;
-      __pyx_L12_unpacking_failed:;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_14 = NULL;
-      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_L13_unpacking_done:;
-    }
-    __Pyx_XDECREF_SET(__pyx_v_m, __pyx_t_9);
-    __pyx_t_9 = 0;
-    __Pyx_XDECREF_SET(__pyx_v_mask, __pyx_t_7);
-    __pyx_t_7 = 0;
-
-    /* "healpy/src/_sphtools.pyx":107
- *     # replace UNSEEN pixels with zeros
- *     for m, mask in zip(maps_c, masks):
- *         if mask:             # <<<<<<<<<<<<<<
- *             m[mask] = 0.0
- * 
- */
-    __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_v_mask); if (unlikely(__pyx_t_11 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (__pyx_t_11) {
-
-      /* "healpy/src/_sphtools.pyx":108
- *     for m, mask in zip(maps_c, masks):
- *         if mask:
- *             m[mask] = 0.0             # <<<<<<<<<<<<<<
- * 
- *     # Create an ndarray object that will contain the alm for output (to be returned)
- */
-      if (unlikely(PyObject_SetItem(__pyx_v_m, __pyx_v_mask, __pyx_float_0_0) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      goto __pyx_L14;
-    }
-    __pyx_L14:;
-  }
+  __pyx_t_3 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  __Pyx_INCREF(((PyObject *)__pyx_v_m));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_m));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_m));
+  __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  __Pyx_GIVEREF(__pyx_t_4);
+  __Pyx_GOTREF(((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->m);
+  __Pyx_DECREF(((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->m);
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->m = __pyx_t_4;
+  __pyx_t_4 = 0;
 
-  /* "healpy/src/_sphtools.pyx":111
- * 
- *     # Create an ndarray object that will contain the alm for output (to be returned)
- *     n_alm = alm_getn(lmax_, mmax_)             # <<<<<<<<<<<<<<
- *     alms = [np.empty(n_alm, dtype=np.complex128) for m in maps]
- * 
- */
-  __pyx_v_n_alm = __pyx_f_6healpy_9_sphtools_alm_getn(__pyx_v_lmax_, __pyx_v_mmax_);
-
-  /* "healpy/src/_sphtools.pyx":112
- *     # Create an ndarray object that will contain the alm for output (to be returned)
- *     n_alm = alm_getn(lmax_, mmax_)
- *     alms = [np.empty(n_alm, dtype=np.complex128) for m in maps]             # <<<<<<<<<<<<<<
- * 
- *     # View the ndarray as an Alm
+  /* "healpy/src/_sphtools.pyx":85
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
+ *         self.a = new arr[double](<double*>(<np.ndarray>self.m).data, (<np.ndarray>self.m).size)             # <<<<<<<<<<<<<<
+ *         self.h = new Healpix_Map[double]()
+ *         self.h.Set(self.a[0], RING)
  */
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyList_CheckExact(__pyx_v_maps) || PyTuple_CheckExact(__pyx_v_maps)) {
-    __pyx_t_1 = __pyx_v_maps; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_maps); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext;
-  }
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_1)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_1)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_7 = __pyx_t_4(__pyx_t_1);
-      if (unlikely(!__pyx_t_7)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_7);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_m, __pyx_t_7);
-    __pyx_t_7 = 0;
-    __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_empty); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_n_alm); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7);
-    __Pyx_GIVEREF(__pyx_t_7);
-    __pyx_t_7 = 0;
-    __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_complex128); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_dtype, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_8 = PyObject_Call(__pyx_t_9, __pyx_t_5, __pyx_t_7); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_8))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_alms = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
+  __pyx_t_4 = PyObject_GetAttr(((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->m, __pyx_n_s__size); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = __Pyx_PyInt_AsSize_t(__pyx_t_4); if (unlikely((__pyx_t_5 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->a = new arr<double>(((double *)((PyArrayObject *)((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->m)->data), __pyx_t_5);
 
-  /* "healpy/src/_sphtools.pyx":116
- *     # View the ndarray as an Alm
- *     # Alms = [ndarray2alm(alm, lmax_, mmax_) for alm in alms]
- *     A1 = ndarray2alm(alms[0], lmax_, mmax_)             # <<<<<<<<<<<<<<
- *     A2 = ndarray2alm(alms[1], lmax_, mmax_)
+  /* "healpy/src/_sphtools.pyx":86
+ *         self.m = np.ascontiguousarray(m)
+ *         self.a = new arr[double](<double*>(<np.ndarray>self.m).data, (<np.ndarray>self.m).size)
+ *         self.h = new Healpix_Map[double]()             # <<<<<<<<<<<<<<
+ *         self.h.Set(self.a[0], RING)
  * 
  */
-  __pyx_t_2 = __Pyx_GetItemInt_List(__pyx_v_alms, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_t_2), __pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_A1 = __pyx_t_15;
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->h = new Healpix_Map<double>();
 
-  /* "healpy/src/_sphtools.pyx":117
- *     # Alms = [ndarray2alm(alm, lmax_, mmax_) for alm in alms]
- *     A1 = ndarray2alm(alms[0], lmax_, mmax_)
- *     A2 = ndarray2alm(alms[1], lmax_, mmax_)             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":87
+ *         self.a = new arr[double](<double*>(<np.ndarray>self.m).data, (<np.ndarray>self.m).size)
+ *         self.h = new Healpix_Map[double]()
+ *         self.h.Set(self.a[0], RING)             # <<<<<<<<<<<<<<
  * 
- *     # ring weights
+ *     def __dealloc__(self):
  */
-  __pyx_t_2 = __Pyx_GetItemInt_List(__pyx_v_alms, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_t_2), __pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_A2 = __pyx_t_15;
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->h->Set(((arr<double> &)(((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->a[0])), RING);
 
-  /* "healpy/src/_sphtools.pyx":120
- * 
- *     # ring weights
- *     cdef arr[double] * w_arr = new arr[double]()             # <<<<<<<<<<<<<<
- *     cdef int i
- *     cdef char *c_datapath
- */
-  __pyx_v_w_arr = new arr<double>();
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("healpy._sphtools.WrapMap.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
+  __pyx_L2:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-  /* "healpy/src/_sphtools.pyx":123
- *     cdef int i
- *     cdef char *c_datapath
- *     w_arr.allocAndFill(2 * nside, 1.)             # <<<<<<<<<<<<<<
+/* "healpy/src/_sphtools.pyx":89
+ *         self.h.Set(self.a[0], RING)
  * 
- *     map2alm_spin(M1[0], M2[0], A1[0], A2[0], spin, w_arr[0], False)
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         if self.is_init == 1:
+ *             #print "deallocating map wrapper..."
  */
-  __pyx_v_w_arr->allocAndFill((2 * __pyx_v_nside), 1.);
 
-  /* "healpy/src/_sphtools.pyx":125
- *     w_arr.allocAndFill(2 * nside, 1.)
- * 
- *     map2alm_spin(M1[0], M2[0], A1[0], A2[0], spin, w_arr[0], False)             # <<<<<<<<<<<<<<
- * 
- *     # restore input map with UNSEEN pixels
- */
-  __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_v_spin); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  map2alm_spin((__pyx_v_M1[0]), (__pyx_v_M2[0]), (__pyx_v_A1[0]), (__pyx_v_A2[0]), __pyx_t_10, (__pyx_v_w_arr[0]), 0);
+static void __pyx_pf_6healpy_9_sphtools_7WrapMap_1__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pf_6healpy_9_sphtools_7WrapMap_1__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("__dealloc__");
 
-  /* "healpy/src/_sphtools.pyx":128
+  /* "healpy/src/_sphtools.pyx":90
  * 
- *     # restore input map with UNSEEN pixels
- *     for m, mask in zip(maps_c, masks):             # <<<<<<<<<<<<<<
- *         if mask:
- *             m[mask] = UNSEEN
+ *     def __dealloc__(self):
+ *         if self.is_init == 1:             # <<<<<<<<<<<<<<
+ *             #print "deallocating map wrapper..."
+ *             del self.a, self.h
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_v_maps_c);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_maps_c);
-  __Pyx_GIVEREF(__pyx_v_maps_c);
-  __Pyx_INCREF(__pyx_v_masks);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_masks);
-  __Pyx_GIVEREF(__pyx_v_masks);
-  __pyx_t_1 = PyObject_Call(__pyx_builtin_zip, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyList_CheckExact(__pyx_t_1) || PyTuple_CheckExact(__pyx_t_1)) {
-    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext;
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_1)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_1);
-    }
-    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-      PyObject* sequence = __pyx_t_1;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      Py_ssize_t size = Py_SIZE(sequence);
-      #else
-      Py_ssize_t size = PySequence_Size(sequence);
-      #endif
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      }
-      #if CYTHON_COMPILING_IN_CPYTHON
-      if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 0); 
-        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
-      } else {
-        __pyx_t_8 = PyList_GET_ITEM(sequence, 0); 
-        __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
-      }
-      __Pyx_INCREF(__pyx_t_8);
-      __Pyx_INCREF(__pyx_t_7);
-      #else
-      __pyx_t_8 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_7);
-      #endif
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    } else {
-      Py_ssize_t index = -1;
-      __pyx_t_5 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_14 = Py_TYPE(__pyx_t_5)->tp_iternext;
-      index = 0; __pyx_t_8 = __pyx_t_14(__pyx_t_5); if (unlikely(!__pyx_t_8)) goto __pyx_L19_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_8);
-      index = 1; __pyx_t_7 = __pyx_t_14(__pyx_t_5); if (unlikely(!__pyx_t_7)) goto __pyx_L19_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_7);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_14(__pyx_t_5), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_14 = NULL;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      goto __pyx_L20_unpacking_done;
-      __pyx_L19_unpacking_failed:;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_14 = NULL;
-      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_L20_unpacking_done:;
-    }
-    __Pyx_XDECREF_SET(__pyx_v_m, __pyx_t_8);
-    __pyx_t_8 = 0;
-    __Pyx_XDECREF_SET(__pyx_v_mask, __pyx_t_7);
-    __pyx_t_7 = 0;
+  __pyx_t_1 = (((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->is_init == 1);
+  if (__pyx_t_1) {
 
-    /* "healpy/src/_sphtools.pyx":129
- *     # restore input map with UNSEEN pixels
- *     for m, mask in zip(maps_c, masks):
- *         if mask:             # <<<<<<<<<<<<<<
- *             m[mask] = UNSEEN
+    /* "healpy/src/_sphtools.pyx":92
+ *         if self.is_init == 1:
+ *             #print "deallocating map wrapper..."
+ *             del self.a, self.h             # <<<<<<<<<<<<<<
  * 
+ * cdef class WrapAlm(object):
  */
-    __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_v_mask); if (unlikely(__pyx_t_11 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (__pyx_t_11) {
-
-      /* "healpy/src/_sphtools.pyx":130
- *     for m, mask in zip(maps_c, masks):
- *         if mask:
- *             m[mask] = UNSEEN             # <<<<<<<<<<<<<<
- * 
- *     del w_arr
- */
-      __pyx_t_1 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_1);
-      if (unlikely(PyObject_SetItem(__pyx_v_m, __pyx_v_mask, __pyx_t_1) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      goto __pyx_L21;
-    }
-    __pyx_L21:;
+    delete ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->a;
+    delete ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_v_self)->h;
+    goto __pyx_L5;
   }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "healpy/src/_sphtools.pyx":132
- *             m[mask] = UNSEEN
- * 
- *     del w_arr             # <<<<<<<<<<<<<<
- *     del M1, M2, A1, A2
- *     return alms
- */
-  delete __pyx_v_w_arr;
-
-  /* "healpy/src/_sphtools.pyx":133
- * 
- *     del w_arr
- *     del M1, M2, A1, A2             # <<<<<<<<<<<<<<
- *     return alms
- * 
- */
-  delete __pyx_v_M1;
-  delete __pyx_v_M2;
-  delete __pyx_v_A1;
-  delete __pyx_v_A2;
-
-  /* "healpy/src/_sphtools.pyx":134
- *     del w_arr
- *     del M1, M2, A1, A2
- *     return alms             # <<<<<<<<<<<<<<
- * 
- * def alm2map_spin_healpy(alms, nside, spin, lmax, mmax=None):
- */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_alms);
-  __pyx_r = __pyx_v_alms;
-  goto __pyx_L0;
-
-  /* "healpy/src/_sphtools.pyx":60
- *     return DATAPATH
- * 
- * def map2alm_spin_healpy(maps, spin, lmax = None, mmax = None):             # <<<<<<<<<<<<<<
- *     """Computes the spinned alm of a 2 Healpix maps.
- * 
- */
+  __pyx_L5:;
 
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_9);
-  __Pyx_AddTraceback("healpy._sphtools.map2alm_spin_healpy", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_maps_c);
-  __Pyx_XDECREF(__pyx_v_masks);
-  __Pyx_XDECREF(__pyx_v_m);
-  __Pyx_XDECREF(__pyx_v_mask);
-  __Pyx_XDECREF(__pyx_v_alms);
-  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
-  return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":136
- *     return alms
+/* "healpy/src/_sphtools.pyx":102
+ *     cdef int is_init
  * 
- * def alm2map_spin_healpy(alms, nside, spin, lmax, mmax=None):             # <<<<<<<<<<<<<<
- *     """Computes maps from a set of 2 spinned alm
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_5alm2map_spin_healpy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_4alm2map_spin_healpy[] = "Computes maps from a set of 2 spinned alm\n\n    Parameters\n    ----------\n    alms : list of 2 arrays\n      list of 2 alms\n    nside : int\n        requested nside of the output map \n    spin : int\n        spin of the alms (either 1, 2 or 3)\n    lmax : int, scalar\n      Maximum l of the power spectrum.\n    mmax : int, scalar, optional\n      Maximum m of the alm. Default: lmax\n    \n    Returns\n    -------\n    m : list of 2 arrays\n        list of 2 out maps in RING scheme as numpy arrays\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_5alm2map_spin_healpy = {__Pyx_NAMESTR("alm2map_spin_healpy"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_5alm2map_spin_healpy, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_4alm2map_spin_healpy)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_5alm2map_spin_healpy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_alms = 0;
-  PyObject *__pyx_v_nside = 0;
-  PyObject *__pyx_v_spin = 0;
-  PyObject *__pyx_v_lmax = 0;
-  PyObject *__pyx_v_mmax = 0;
+ *     def __init__(self, np.ndarray[np.complex128_t] m, int lmax, int mmax):             # <<<<<<<<<<<<<<
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')
+ */
+
+static int __pyx_pf_6healpy_9_sphtools_7WrapAlm___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pf_6healpy_9_sphtools_7WrapAlm___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_m = 0;
+  int __pyx_v_lmax;
+  int __pyx_v_mmax;
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  size_t __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("alm2map_spin_healpy (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__lmax,&__pyx_n_s__mmax,0};
+  __Pyx_RefNannySetupContext("__init__");
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alms,&__pyx_n_s_nside,&__pyx_n_s_spin,&__pyx_n_s_lmax,&__pyx_n_s_mmax,0};
-    PyObject* values[5] = {0,0,0,0,0};
-    values[4] = ((PyObject *)Py_None);
+    PyObject* values[3] = {0,0,0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_alms)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nside)) != 0)) kw_args--;
+        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__lmax);
+        if (likely(values[1])) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("alm2map_spin_healpy", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
         }
         case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_spin)) != 0)) kw_args--;
+        values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mmax);
+        if (likely(values[2])) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("alm2map_spin_healpy", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  3:
-        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("alm2map_spin_healpy", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  4:
-        if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
-          if (value) { values[4] = value; kw_args--; }
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "alm2map_spin_healpy") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (PyTuple_GET_SIZE(__pyx_args)) {
-        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
-    __pyx_v_alms = values[0];
-    __pyx_v_nside = values[1];
-    __pyx_v_spin = values[2];
-    __pyx_v_lmax = values[3];
-    __pyx_v_mmax = values[4];
+    __pyx_v_m = ((PyArrayObject *)values[0]);
+    __pyx_v_lmax = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_lmax == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    __pyx_v_mmax = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_mmax == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("alm2map_spin_healpy", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._sphtools.alm2map_spin_healpy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._sphtools.WrapAlm.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
-  return NULL;
+  return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_4alm2map_spin_healpy(__pyx_self, __pyx_v_alms, __pyx_v_nside, __pyx_v_spin, __pyx_v_lmax, __pyx_v_mmax);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_4alm2map_spin_healpy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alms, PyObject *__pyx_v_nside, PyObject *__pyx_v_spin, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax) {
-  PyObject *__pyx_v_alms_c = NULL;
-  PyObject *__pyx_v_npix = NULL;
-  PyObject *__pyx_v_maps = NULL;
-  Healpix_Map<double> *__pyx_v_M1;
-  Healpix_Map<double> *__pyx_v_M2;
-  Alm<xcomplex<double> > *__pyx_v_A1;
-  Alm<xcomplex<double> > *__pyx_v_A2;
-  PyObject *__pyx_v_alm = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
-  PyObject *(*__pyx_t_4)(PyObject *);
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  Healpix_Map<double> *__pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_t_12;
-  int __pyx_t_13;
-  int __pyx_t_14;
-  Alm<xcomplex<double> > *__pyx_t_15;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("alm2map_spin_healpy", 0);
-  __Pyx_INCREF(__pyx_v_mmax);
+  __pyx_bstruct_m.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
 
-  /* "healpy/src/_sphtools.pyx":157
- *         list of 2 out maps in RING scheme as numpy arrays
- *     """
- *     alms_c = [np.ascontiguousarray(alm, dtype=np.complex128) for alm in alms]             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":103
  * 
- *     npix = nside2npix(nside)
+ *     def __init__(self, np.ndarray[np.complex128_t] m, int lmax, int mmax):
+ *         if self.is_init == 1:             # <<<<<<<<<<<<<<
+ *             raise Exception('Already init...')
+ *         self.is_init = 1
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyList_CheckExact(__pyx_v_alms) || PyTuple_CheckExact(__pyx_v_alms)) {
-    __pyx_t_2 = __pyx_v_alms; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_alms); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = (((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->is_init == 1);
+  if (__pyx_t_1) {
+
+    /* "healpy/src/_sphtools.pyx":104
+ *     def __init__(self, np.ndarray[np.complex128_t] m, int lmax, int mmax):
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')             # <<<<<<<<<<<<<<
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_5), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext;
-  }
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_5 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_5)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_5);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_alm, __pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_INCREF(__pyx_v_alm);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_alm);
-    __Pyx_GIVEREF(__pyx_v_alm);
-    __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_complex128); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_dtype, __pyx_t_9) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __pyx_t_9 = PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_7); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_9))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
   }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_alms_c = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_L6:;
 
-  /* "healpy/src/_sphtools.pyx":159
- *     alms_c = [np.ascontiguousarray(alm, dtype=np.complex128) for alm in alms]
- * 
- *     npix = nside2npix(nside)             # <<<<<<<<<<<<<<
- *     maps = [np.zeros(npix, dtype=np.float64) for alm in alms]
- * 
+  /* "healpy/src/_sphtools.pyx":105
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')
+ *         self.is_init = 1             # <<<<<<<<<<<<<<
+ *         self.m = np.ascontiguousarray(m)
+ *         self.h = new Alm[xcomplex[double]]()
  */
-  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_nside2npix); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->is_init = 1;
+
+  /* "healpy/src/_sphtools.pyx":106
+ *             raise Exception('Already init...')
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)             # <<<<<<<<<<<<<<
+ *         self.h = new Alm[xcomplex[double]]()
+ *         self.a = new arr[xcomplex[double]](cast_to_ptr_xcomplex_d((<np.ndarray>self.m).data),
+ */
+  __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_v_nside);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_nside);
-  __Pyx_GIVEREF(__pyx_v_nside);
-  __pyx_t_9 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_npix = __pyx_t_9;
-  __pyx_t_9 = 0;
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  __Pyx_INCREF(((PyObject *)__pyx_v_m));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_m));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_m));
+  __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  __Pyx_GIVEREF(__pyx_t_4);
+  __Pyx_GOTREF(((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->m);
+  __Pyx_DECREF(((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->m);
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->m = __pyx_t_4;
+  __pyx_t_4 = 0;
 
-  /* "healpy/src/_sphtools.pyx":160
- * 
- *     npix = nside2npix(nside)
- *     maps = [np.zeros(npix, dtype=np.float64) for alm in alms]             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":107
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
+ *         self.h = new Alm[xcomplex[double]]()             # <<<<<<<<<<<<<<
+ *         self.a = new arr[xcomplex[double]](cast_to_ptr_xcomplex_d((<np.ndarray>self.m).data),
+ *                                            (<np.ndarray>self.m).size)
+ */
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->h = new Alm<xcomplex<double> >(NULL);
+
+  /* "healpy/src/_sphtools.pyx":109
+ *         self.h = new Alm[xcomplex[double]]()
+ *         self.a = new arr[xcomplex[double]](cast_to_ptr_xcomplex_d((<np.ndarray>self.m).data),
+ *                                            (<np.ndarray>self.m).size)             # <<<<<<<<<<<<<<
+ *         self.h.Set(self.a[0], lmax, mmax)
  * 
- *     # View the ndarray as a Healpix_Map
  */
-  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  if (PyList_CheckExact(__pyx_v_alms) || PyTuple_CheckExact(__pyx_v_alms)) {
-    __pyx_t_2 = __pyx_v_alms; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_alms); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext;
-  }
-  for (;;) {
-    if (!__pyx_t_4 && PyList_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_4 && PyTuple_CheckExact(__pyx_t_2)) {
-      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else {
-      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_1)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_1);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_alm, __pyx_t_1);
-    __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_v_npix);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_npix);
-    __Pyx_GIVEREF(__pyx_v_npix);
-    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_float64); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_8 = PyObject_Call(__pyx_t_7, __pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_9, (PyObject*)__pyx_t_8))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_maps = ((PyObject*)__pyx_t_9);
-  __pyx_t_9 = 0;
+  __pyx_t_4 = PyObject_GetAttr(((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->m, __pyx_n_s__size); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = __Pyx_PyInt_AsSize_t(__pyx_t_4); if (unlikely((__pyx_t_5 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "healpy/src/_sphtools.pyx":163
+  /* "healpy/src/_sphtools.pyx":108
+ *         self.m = np.ascontiguousarray(m)
+ *         self.h = new Alm[xcomplex[double]]()
+ *         self.a = new arr[xcomplex[double]](cast_to_ptr_xcomplex_d((<np.ndarray>self.m).data),             # <<<<<<<<<<<<<<
+ *                                            (<np.ndarray>self.m).size)
+ *         self.h.Set(self.a[0], lmax, mmax)
+ */
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->a = new arr<xcomplex<double> >(cast_to_ptr_xcomplex_d(((PyArrayObject *)((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->m)->data), __pyx_t_5);
+
+  /* "healpy/src/_sphtools.pyx":110
+ *         self.a = new arr[xcomplex[double]](cast_to_ptr_xcomplex_d((<np.ndarray>self.m).data),
+ *                                            (<np.ndarray>self.m).size)
+ *         self.h.Set(self.a[0], lmax, mmax)             # <<<<<<<<<<<<<<
  * 
- *     # View the ndarray as a Healpix_Map
- *     M1 = ndarray2map(maps[0], RING)             # <<<<<<<<<<<<<<
- *     M2 = ndarray2map(maps[1], RING)
- * 
- */
-  __pyx_t_9 = __Pyx_GetItemInt_List(__pyx_v_maps, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_9);
-  if (!(likely(((__pyx_t_9) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_9, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_10 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_t_9), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_v_M1 = __pyx_t_10;
-
-  /* "healpy/src/_sphtools.pyx":164
- *     # View the ndarray as a Healpix_Map
- *     M1 = ndarray2map(maps[0], RING)
- *     M2 = ndarray2map(maps[1], RING)             # <<<<<<<<<<<<<<
- * 
- *     if not mmax:
- */
-  __pyx_t_9 = __Pyx_GetItemInt_List(__pyx_v_maps, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_9);
-  if (!(likely(((__pyx_t_9) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_9, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_10 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_t_9), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_v_M2 = __pyx_t_10;
+ *     def __dealloc__(self):
+ */
+  ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->h->Set(((arr<xcomplex<double> > &)(((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->a[0])), __pyx_v_lmax, __pyx_v_mmax);
 
-  /* "healpy/src/_sphtools.pyx":166
- *     M2 = ndarray2map(maps[1], RING)
- * 
- *     if not mmax:             # <<<<<<<<<<<<<<
- *         mmax = lmax
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("healpy._sphtools.WrapAlm.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
+  __pyx_L2:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "healpy/src/_sphtools.pyx":112
+ *         self.h.Set(self.a[0], lmax, mmax)
  * 
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         if self.is_init == 1:
+ *             #print "deallocating alm wrapper..."
  */
-  __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_v_mmax); if (unlikely(__pyx_t_11 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_12 = ((!__pyx_t_11) != 0);
-  if (__pyx_t_12) {
 
-    /* "healpy/src/_sphtools.pyx":167
- * 
- *     if not mmax:
- *         mmax = lmax             # <<<<<<<<<<<<<<
+static void __pyx_pf_6healpy_9_sphtools_7WrapAlm_1__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pf_6healpy_9_sphtools_7WrapAlm_1__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("__dealloc__");
+
+  /* "healpy/src/_sphtools.pyx":113
  * 
- *     # View the ndarray as an Alm
+ *     def __dealloc__(self):
+ *         if self.is_init == 1:             # <<<<<<<<<<<<<<
+ *             #print "deallocating alm wrapper..."
+ *             del self.a, self.h
  */
-    __Pyx_INCREF(__pyx_v_lmax);
-    __Pyx_DECREF_SET(__pyx_v_mmax, __pyx_v_lmax);
-    goto __pyx_L7;
-  }
-  __pyx_L7:;
+  __pyx_t_1 = (((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->is_init == 1);
+  if (__pyx_t_1) {
 
-  /* "healpy/src/_sphtools.pyx":170
- * 
- *     # View the ndarray as an Alm
- *     A1 = ndarray2alm(alms_c[0], lmax, mmax)             # <<<<<<<<<<<<<<
- *     A2 = ndarray2alm(alms_c[1], lmax, mmax)
+    /* "healpy/src/_sphtools.pyx":115
+ *         if self.is_init == 1:
+ *             #print "deallocating alm wrapper..."
+ *             del self.a, self.h             # <<<<<<<<<<<<<<
  * 
+ * DATAPATH = None
  */
-  __pyx_t_9 = __Pyx_GetItemInt_List(__pyx_v_alms_c, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_9);
-  if (!(likely(((__pyx_t_9) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_9, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_t_9), __pyx_t_13, __pyx_t_14); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_v_A1 = __pyx_t_15;
+    delete ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->a;
+    delete ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_v_self)->h;
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
 
-  /* "healpy/src/_sphtools.pyx":171
- *     # View the ndarray as an Alm
- *     A1 = ndarray2alm(alms_c[0], lmax, mmax)
- *     A2 = ndarray2alm(alms_c[1], lmax, mmax)             # <<<<<<<<<<<<<<
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "healpy/src/_sphtools.pyx":119
+ * DATAPATH = None
  * 
- *     alm2map_spin(A1[0], A2[0], M1[0], M2[0], spin)
+ * def get_datapath():             # <<<<<<<<<<<<<<
+ *     global DATAPATH
+ *     if DATAPATH is None:
  */
-  __pyx_t_9 = __Pyx_GetItemInt_List(__pyx_v_alms_c, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_9);
-  if (!(likely(((__pyx_t_9) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_9, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_t_9), __pyx_t_14, __pyx_t_13); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_v_A2 = __pyx_t_15;
 
-  /* "healpy/src/_sphtools.pyx":173
- *     A2 = ndarray2alm(alms_c[1], lmax, mmax)
- * 
- *     alm2map_spin(A1[0], A2[0], M1[0], M2[0], spin)             # <<<<<<<<<<<<<<
- * 
- *     del M1, M2, A1, A2
+static PyObject *__pyx_pf_6healpy_9_sphtools_get_datapath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_get_datapath[] = "get_datapath()";
+static PyMethodDef __pyx_mdef_6healpy_9_sphtools_get_datapath = {__Pyx_NAMESTR("get_datapath"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_get_datapath, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_get_datapath)};
+static PyObject *__pyx_pf_6healpy_9_sphtools_get_datapath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_datapath");
+  __pyx_self = __pyx_self;
+
+  /* "healpy/src/_sphtools.pyx":121
+ * def get_datapath():
+ *     global DATAPATH
+ *     if DATAPATH is None:             # <<<<<<<<<<<<<<
+ *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
+ *     return DATAPATH
  */
-  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_spin); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  alm2map_spin((__pyx_v_A1[0]), (__pyx_v_A2[0]), (__pyx_v_M1[0]), (__pyx_v_M2[0]), __pyx_t_13);
+  __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__DATAPATH); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = (__pyx_t_1 == Py_None);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
 
-  /* "healpy/src/_sphtools.pyx":175
- *     alm2map_spin(A1[0], A2[0], M1[0], M2[0], spin)
- * 
- *     del M1, M2, A1, A2             # <<<<<<<<<<<<<<
- *     return maps
+    /* "healpy/src/_sphtools.pyx":122
+ *     global DATAPATH
+ *     if DATAPATH is None:
+ *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')             # <<<<<<<<<<<<<<
+ *     return DATAPATH
  * 
  */
-  delete __pyx_v_M1;
-  delete __pyx_v_M2;
-  delete __pyx_v_A1;
-  delete __pyx_v_A2;
+    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__path); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__join); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__path); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__dirname); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__path); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__abspath); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s____file__); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_5);
+    __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_5);
+    __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_5);
+    __Pyx_INCREF(((PyObject *)__pyx_n_s__data));
+    PyTuple_SET_ITEM(__pyx_t_6, 1, ((PyObject *)__pyx_n_s__data));
+    __Pyx_GIVEREF(((PyObject *)__pyx_n_s__data));
+    __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    if (PyObject_SetAttr(__pyx_m, __pyx_n_s__DATAPATH, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
 
-  /* "healpy/src/_sphtools.pyx":176
- * 
- *     del M1, M2, A1, A2
- *     return maps             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":123
+ *     if DATAPATH is None:
+ *         DATAPATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
+ *     return DATAPATH             # <<<<<<<<<<<<<<
  * 
  * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_maps);
-  __pyx_r = __pyx_v_maps;
+  __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__DATAPATH); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":136
- *     return alms
- * 
- * def alm2map_spin_healpy(alms, nside, spin, lmax, mmax=None):             # <<<<<<<<<<<<<<
- *     """Computes maps from a set of 2 spinned alm
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_9);
-  __Pyx_AddTraceback("healpy._sphtools.alm2map_spin_healpy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("healpy._sphtools.get_datapath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_alms_c);
-  __Pyx_XDECREF(__pyx_v_npix);
-  __Pyx_XDECREF(__pyx_v_maps);
-  __Pyx_XDECREF(__pyx_v_alm);
-  __Pyx_XDECREF(__pyx_v_mmax);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":178
- *     return maps
+/* "healpy/src/_sphtools.pyx":125
+ *     return DATAPATH
  * 
  * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
- *             datapath = None):
- *     """Computes the alm of a Healpix map.
+ *             regression = True, datapath = None):
+ *     """Computes the alm of an Healpix map.
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_7map2alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_6map2alm[] = "Computes the alm of a Healpix map.\n\n    Parameters\n    ----------\n    m : array-like, shape (Npix,) or (3, Npix)\n      The input map or a list of 3 input maps (polariztion).\n    lmax : int, scalar, optional\n      Maximum l of the power spectrum. Default: 3*nside-1\n    mmax : int, scalar, optional\n      Maximum m of the alm. Default: lmax\n    iter : int, scalar, optional\n      Number of iteration (default: 1)\n    use_weights: bool, scalar, optional\n      If True, use the ring weighting. Default: False.\n    \n    Returns\n    -------\n    alm : array or tuple of arrays\n      alm or a tuple of 3 alm (almT, almE, almB) if polarized input.\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_7map2alm = {__Pyx_NAMESTR("map2alm"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_7map2alm, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_6map2alm)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_7map2alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pf_6healpy_9_sphtools_1map2alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_1map2alm[] = "map2alm(m, lmax=None, mmax=None, niter=3, use_weights=False, regression=True, datapath=None)\nComputes the alm of an Healpix map.\n\n    Parameters\n    ----------\n    m : array-like, shape (Npix,) or (3, Npix)\n      The input map or a list of 3 input maps (polariztion).\n    lmax : int, scalar, optional\n      Maximum l of the power spectrum. Default: 3*nside-1\n    mmax : int, scalar, optional\n      Maximum m of the alm. Default: lmax\n    iter : int, scalar, optional\n      Number of iteration (default: 1)\n    use_weights: bool, scalar, optional\n      If True, use the ring weighting. Default: False.\n    regression: bool, scalar, optional\n      If True, subtract map average before computing alm. Default: True.\n    \n    Returns\n    -------\n    alm : array or tuple of arrays\n      alm or a tuple of 3 alm (almT, almE, almB) if polarized input.\n    ";
+static PyMethodDef __pyx_mdef_6healpy_9_sphtools_1map2alm = {__Pyx_NAMESTR("map2alm"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_1map2alm, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_1map2alm)};
+static PyObject *__pyx_pf_6healpy_9_sphtools_1map2alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_m = 0;
   PyObject *__pyx_v_lmax = 0;
   PyObject *__pyx_v_mmax = 0;
   PyObject *__pyx_v_niter = 0;
   PyObject *__pyx_v_use_weights = 0;
+  PyObject *__pyx_v_regression = 0;
   PyObject *__pyx_v_datapath = 0;
+  PyObject *__pyx_v_info = NULL;
+  int __pyx_v_polarization;
+  PyObject *__pyx_v_mmi = NULL;
+  PyObject *__pyx_v_mmq = NULL;
+  PyObject *__pyx_v_mmu = NULL;
+  PyArrayObject *__pyx_v_mi = 0;
+  PyArrayObject *__pyx_v_mq = 0;
+  PyArrayObject *__pyx_v_mu = 0;
+  PyObject *__pyx_v_mask_mi = NULL;
+  PyObject *__pyx_v_mask_mq = NULL;
+  PyObject *__pyx_v_mask_mu = NULL;
+  int __pyx_v_lmax_;
+  int __pyx_v_mmax_;
+  int __pyx_v_nside;
+  int __pyx_v_npix;
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *__pyx_v_MI = NULL;
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *__pyx_v_MQ = NULL;
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *__pyx_v_MU = NULL;
+  double __pyx_v_avg;
+  PyArrayObject *__pyx_v_almI = 0;
+  PyArrayObject *__pyx_v_almC = 0;
+  PyObject *__pyx_v_n_alm = NULL;
+  PyObject *__pyx_v_almG = NULL;
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *__pyx_v_AI = NULL;
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *__pyx_v_AG = NULL;
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *__pyx_v_AC = NULL;
+  arr<double> *__pyx_v_w_arr;
+  int __pyx_v_i;
+  char *__pyx_v_c_datapath;
+  PyObject *__pyx_v_weightfile = NULL;
+  Py_buffer __pyx_bstruct_mi;
+  Py_ssize_t __pyx_bstride_0_mi = 0;
+  Py_ssize_t __pyx_bshape_0_mi = 0;
+  Py_buffer __pyx_bstruct_mu;
+  Py_ssize_t __pyx_bstride_0_mu = 0;
+  Py_ssize_t __pyx_bshape_0_mu = 0;
+  Py_buffer __pyx_bstruct_mq;
+  Py_ssize_t __pyx_bstride_0_mq = 0;
+  Py_ssize_t __pyx_bshape_0_mq = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyArrayObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  int __pyx_t_12;
+  int __pyx_t_13;
+  char *__pyx_t_14;
+  size_t __pyx_t_15;
+  long __pyx_t_16;
+  int __pyx_t_17;
+  Py_ssize_t __pyx_t_18;
+  double __pyx_t_19;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("map2alm (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__lmax,&__pyx_n_s__mmax,&__pyx_n_s__niter,&__pyx_n_s__use_weights,&__pyx_n_s__regression,&__pyx_n_s__datapath,0};
+  __Pyx_RefNannySetupContext("map2alm");
+  __pyx_self = __pyx_self;
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_m,&__pyx_n_s_lmax,&__pyx_n_s_mmax,&__pyx_n_s_niter,&__pyx_n_s_use_weights,&__pyx_n_s_datapath,0};
-    PyObject* values[6] = {0,0,0,0,0,0};
+    PyObject* values[7] = {0,0,0,0,0,0,0};
     values[1] = ((PyObject *)Py_None);
     values[2] = ((PyObject *)Py_None);
     values[3] = ((PyObject *)__pyx_int_3);
-    values[4] = ((PyObject *)Py_False);
+    values[4] = __pyx_k_6;
+    values[5] = __pyx_k_7;
 
-    /* "healpy/src/_sphtools.pyx":179
+    /* "healpy/src/_sphtools.pyx":126
  * 
  * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,
- *             datapath = None):             # <<<<<<<<<<<<<<
- *     """Computes the alm of a Healpix map.
+ *             regression = True, datapath = None):             # <<<<<<<<<<<<<<
+ *     """Computes the alm of an Healpix map.
  * 
  */
-    values[5] = ((PyObject *)Py_None);
+    values[6] = ((PyObject *)Py_None);
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__lmax);
           if (value) { values[1] = value; kw_args--; }
         }
         case  2:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mmax);
           if (value) { values[2] = value; kw_args--; }
         }
         case  3:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_niter);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__niter);
           if (value) { values[3] = value; kw_args--; }
         }
         case  4:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_use_weights);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__use_weights);
           if (value) { values[4] = value; kw_args--; }
         }
         case  5:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_datapath);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__regression);
           if (value) { values[5] = value; kw_args--; }
         }
+        case  6:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__datapath);
+          if (value) { values[6] = value; kw_args--; }
+        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map2alm") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "map2alm") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -3328,1447 +2124,1634 @@
       }
     }
     __pyx_v_m = values[0];
     __pyx_v_lmax = values[1];
     __pyx_v_mmax = values[2];
     __pyx_v_niter = values[3];
     __pyx_v_use_weights = values[4];
-    __pyx_v_datapath = values[5];
+    __pyx_v_regression = values[5];
+    __pyx_v_datapath = values[6];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("map2alm", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("map2alm", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_AddTraceback("healpy._sphtools.map2alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_6map2alm(__pyx_self, __pyx_v_m, __pyx_v_lmax, __pyx_v_mmax, __pyx_v_niter, __pyx_v_use_weights, __pyx_v_datapath);
-
-  /* "healpy/src/_sphtools.pyx":178
- *     return maps
- * 
- * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
- *             datapath = None):
- *     """Computes the alm of a Healpix map.
- */
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_6map2alm(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_m, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax, PyObject *__pyx_v_niter, PyObject *__pyx_v_use_weights, PyObject *__pyx_v_datapath) {
-  PyObject *__pyx_v_info = NULL;
-  int __pyx_v_polarization;
-  PyObject *__pyx_v_mi = NULL;
-  PyObject *__pyx_v_mq = NULL;
-  PyObject *__pyx_v_mu = NULL;
-  PyObject *__pyx_v_mask_mi = NULL;
-  PyObject *__pyx_v_mask_mq = NULL;
-  PyObject *__pyx_v_mask_mu = NULL;
-  int __pyx_v_lmax_;
-  int __pyx_v_mmax_;
-  int __pyx_v_nside;
-  int __pyx_v_npix;
-  Healpix_Map<double> *__pyx_v_MI;
-  Healpix_Map<double> *__pyx_v_MQ;
-  Healpix_Map<double> *__pyx_v_MU;
-  int __pyx_v_n_alm;
-  PyObject *__pyx_v_almI = NULL;
-  PyObject *__pyx_v_almG = NULL;
-  PyObject *__pyx_v_almC = NULL;
-  Alm<xcomplex<double> > *__pyx_v_AI;
-  Alm<xcomplex<double> > *__pyx_v_AG;
-  Alm<xcomplex<double> > *__pyx_v_AC;
-  arr<double> *__pyx_v_w_arr;
-  int __pyx_v_i;
-  char *__pyx_v_c_datapath;
-  PyObject *__pyx_v_weightfile = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  int __pyx_t_9;
-  Healpix_Map<double> *__pyx_t_10;
-  Alm<xcomplex<double> > *__pyx_t_11;
-  char *__pyx_t_12;
-  std::string __pyx_t_13;
-  size_t __pyx_t_14;
-  long __pyx_t_15;
-  int __pyx_t_16;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("map2alm", 0);
   __Pyx_INCREF(__pyx_v_datapath);
+  __pyx_bstruct_mi.buf = NULL;
+  __pyx_bstruct_mq.buf = NULL;
+  __pyx_bstruct_mu.buf = NULL;
 
-  /* "healpy/src/_sphtools.pyx":201
+  /* "healpy/src/_sphtools.pyx":150
  *     """
  *     # Check if the input map is polarized or not
  *     info = maptype(m)             # <<<<<<<<<<<<<<
  *     if info == 0:
  *         polarization = False
  */
-  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_maptype); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__maptype); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
   __Pyx_INCREF(__pyx_v_m);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_m);
   __Pyx_GIVEREF(__pyx_v_m);
-  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
   __pyx_v_info = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "healpy/src/_sphtools.pyx":202
+  /* "healpy/src/_sphtools.pyx":151
  *     # Check if the input map is polarized or not
  *     info = maptype(m)
  *     if info == 0:             # <<<<<<<<<<<<<<
  *         polarization = False
- *         mi = np.ascontiguousarray(m, dtype=np.float64)
+ *         mmi = m
  */
-  __pyx_t_3 = PyObject_RichCompare(__pyx_v_info, __pyx_int_0, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_RichCompare(__pyx_v_info, __pyx_int_0, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":203
+    /* "healpy/src/_sphtools.pyx":152
  *     info = maptype(m)
  *     if info == 0:
  *         polarization = False             # <<<<<<<<<<<<<<
- *         mi = np.ascontiguousarray(m, dtype=np.float64)
+ *         mmi = m
  *     elif info == 1:
  */
     __pyx_v_polarization = 0;
 
-    /* "healpy/src/_sphtools.pyx":204
+    /* "healpy/src/_sphtools.pyx":153
  *     if info == 0:
  *         polarization = False
- *         mi = np.ascontiguousarray(m, dtype=np.float64)             # <<<<<<<<<<<<<<
+ *         mmi = m             # <<<<<<<<<<<<<<
  *     elif info == 1:
  *         polarization = False
  */
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_m);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_m);
-    __Pyx_GIVEREF(__pyx_v_m);
-    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_float64); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_v_mi = __pyx_t_6;
-    __pyx_t_6 = 0;
-    goto __pyx_L3;
+    __pyx_v_mmi = __pyx_v_m;
+    goto __pyx_L6;
   }
 
-  /* "healpy/src/_sphtools.pyx":205
+  /* "healpy/src/_sphtools.pyx":154
  *         polarization = False
- *         mi = np.ascontiguousarray(m, dtype=np.float64)
+ *         mmi = m
  *     elif info == 1:             # <<<<<<<<<<<<<<
  *         polarization = False
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
+ *         mmi = m[0]
  */
-  __pyx_t_6 = PyObject_RichCompare(__pyx_v_info, __pyx_int_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_3 = PyObject_RichCompare(__pyx_v_info, __pyx_int_1, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":206
- *         mi = np.ascontiguousarray(m, dtype=np.float64)
+    /* "healpy/src/_sphtools.pyx":155
+ *         mmi = m
  *     elif info == 1:
  *         polarization = False             # <<<<<<<<<<<<<<
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
+ *         mmi = m[0]
  *     elif info == 3:
  */
     __pyx_v_polarization = 0;
 
-    /* "healpy/src/_sphtools.pyx":207
+    /* "healpy/src/_sphtools.pyx":156
  *     elif info == 1:
  *         polarization = False
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)             # <<<<<<<<<<<<<<
+ *         mmi = m[0]             # <<<<<<<<<<<<<<
  *     elif info == 3:
  *         polarization = True
  */
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_m, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_6 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_m, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_6);
-    __pyx_t_6 = 0;
-    __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_float64); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_dtype, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_v_mi = __pyx_t_5;
-    __pyx_t_5 = 0;
-    goto __pyx_L3;
+    __pyx_v_mmi = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L6;
   }
 
-  /* "healpy/src/_sphtools.pyx":208
+  /* "healpy/src/_sphtools.pyx":157
  *         polarization = False
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
+ *         mmi = m[0]
  *     elif info == 3:             # <<<<<<<<<<<<<<
  *         polarization = True
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
+ *         mmi = m[0]
  */
-  __pyx_t_5 = PyObject_RichCompare(__pyx_v_info, __pyx_int_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_3 = PyObject_RichCompare(__pyx_v_info, __pyx_int_3, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":209
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
+    /* "healpy/src/_sphtools.pyx":158
+ *         mmi = m[0]
  *     elif info == 3:
  *         polarization = True             # <<<<<<<<<<<<<<
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
- *         mq = np.ascontiguousarray(m[1], dtype=np.float64)
+ *         mmi = m[0]
+ *         mmq = m[1]
  */
     __pyx_v_polarization = 1;
 
-    /* "healpy/src/_sphtools.pyx":210
+    /* "healpy/src/_sphtools.pyx":159
  *     elif info == 3:
  *         polarization = True
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)             # <<<<<<<<<<<<<<
- *         mq = np.ascontiguousarray(m[1], dtype=np.float64)
- *         mu = np.ascontiguousarray(m[2], dtype=np.float64)
+ *         mmi = m[0]             # <<<<<<<<<<<<<<
+ *         mmq = m[1]
+ *         mmu = m[2]
  */
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_m, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_m, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyObject_Call(__pyx_t_6, __pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_v_mi = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_v_mmi = __pyx_t_3;
+    __pyx_t_3 = 0;
 
-    /* "healpy/src/_sphtools.pyx":211
+    /* "healpy/src/_sphtools.pyx":160
  *         polarization = True
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
- *         mq = np.ascontiguousarray(m[1], dtype=np.float64)             # <<<<<<<<<<<<<<
- *         mu = np.ascontiguousarray(m[2], dtype=np.float64)
+ *         mmi = m[0]
+ *         mmq = m[1]             # <<<<<<<<<<<<<<
+ *         mmu = m[2]
  *     else:
  */
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_m, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_m, 1, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    __pyx_t_2 = 0;
-    __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_float64); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyObject_Call(__pyx_t_5, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_mq = __pyx_t_1;
-    __pyx_t_1 = 0;
+    __pyx_v_mmq = __pyx_t_3;
+    __pyx_t_3 = 0;
 
-    /* "healpy/src/_sphtools.pyx":212
- *         mi = np.ascontiguousarray(m[0], dtype=np.float64)
- *         mq = np.ascontiguousarray(m[1], dtype=np.float64)
- *         mu = np.ascontiguousarray(m[2], dtype=np.float64)             # <<<<<<<<<<<<<<
+    /* "healpy/src/_sphtools.pyx":161
+ *         mmi = m[0]
+ *         mmq = m[1]
+ *         mmu = m[2]             # <<<<<<<<<<<<<<
  *     else:
  *         raise ValueError("Wrong input map (must be a valid healpix map "
  */
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_m, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_m, 2, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-    __Pyx_GIVEREF(__pyx_t_1);
-    __pyx_t_1 = 0;
-    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_float64); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_v_mu = __pyx_t_6;
-    __pyx_t_6 = 0;
-    goto __pyx_L3;
+    __pyx_v_mmu = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L6;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":214
- *         mu = np.ascontiguousarray(m[2], dtype=np.float64)
+    /* "healpy/src/_sphtools.pyx":163
+ *         mmu = m[2]
  *     else:
  *         raise ValueError("Wrong input map (must be a valid healpix map "             # <<<<<<<<<<<<<<
  *                          "or a sequence of 1 or 3 maps)")
  * 
  */
-    __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_9), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_L3:;
+  __pyx_L6:;
 
-  /* "healpy/src/_sphtools.pyx":218
- * 
+  /* "healpy/src/_sphtools.pyx":168
+ *     # Get the map as a contiguous ndarray object if it isn't
+ *     cdef np.ndarray[np.float64_t, ndim=1] mi, mq, mu
+ *     mi = np.ascontiguousarray(mmi, dtype = np.float64)             # <<<<<<<<<<<<<<
+ *     # create UNSEEN mask for I map
+ *     mask_mi = False if count_bad(mi) == 0 else mkmask(mi)
+ */
+  __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(__pyx_v_mmi);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_mmi);
+  __Pyx_GIVEREF(__pyx_v_mmi);
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_6 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__float64); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__dtype), __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = PyEval_CallObjectWithKeywords(__pyx_t_2, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (!(likely(((__pyx_t_6) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_6, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_7 = ((PyArrayObject *)__pyx_t_6);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mi);
+    __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_mi, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+    if (unlikely(__pyx_t_8 < 0)) {
+      PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
+      if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mi, (PyObject*)__pyx_v_mi, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+        Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
+        __Pyx_RaiseBufferFallbackError();
+      } else {
+        PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
+      }
+    }
+    __pyx_bstride_0_mi = __pyx_bstruct_mi.strides[0];
+    __pyx_bshape_0_mi = __pyx_bstruct_mi.shape[0];
+    if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_t_7 = 0;
+  __pyx_v_mi = ((PyArrayObject *)__pyx_t_6);
+  __pyx_t_6 = 0;
+
+  /* "healpy/src/_sphtools.pyx":170
+ *     mi = np.ascontiguousarray(mmi, dtype = np.float64)
  *     # create UNSEEN mask for I map
  *     mask_mi = False if count_bad(mi) == 0 else mkmask(mi)             # <<<<<<<<<<<<<<
  *     # same for polarization maps if needed
  *     if polarization:
  */
-  if (!(likely(((__pyx_v_mi) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mi, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  if (((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mi), 0) == 0) != 0)) {
-    __Pyx_INCREF(Py_False);
-    __pyx_t_6 = Py_False;
+  if ((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mi), 0) == 0)) {
+    __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_6 = __pyx_t_1;
+    __pyx_t_1 = 0;
   } else {
-    if (!(likely(((__pyx_v_mi) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mi, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mi), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mi), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_6 = __pyx_t_1;
     __pyx_t_1 = 0;
   }
   __pyx_v_mask_mi = __pyx_t_6;
   __pyx_t_6 = 0;
 
-  /* "healpy/src/_sphtools.pyx":220
+  /* "healpy/src/_sphtools.pyx":172
  *     mask_mi = False if count_bad(mi) == 0 else mkmask(mi)
  *     # same for polarization maps if needed
  *     if polarization:             # <<<<<<<<<<<<<<
+ *         mq = np.ascontiguousarray(mmq, dtype = np.float64)
  *         mask_mq = False if count_bad(mq) == 0 else mkmask(mq)
- *         mask_mu = False if count_bad(mu) == 0 else mkmask(mu)
  */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
+  if (__pyx_v_polarization) {
 
-    /* "healpy/src/_sphtools.pyx":221
+    /* "healpy/src/_sphtools.pyx":173
  *     # same for polarization maps if needed
  *     if polarization:
+ *         mq = np.ascontiguousarray(mmq, dtype = np.float64)             # <<<<<<<<<<<<<<
+ *         mask_mq = False if count_bad(mq) == 0 else mkmask(mq)
+ *         mu = np.ascontiguousarray(mmu, dtype = np.float64)
+ */
+    __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_1 = PyObject_GetAttr(__pyx_t_6, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_v_mmq)) { __Pyx_RaiseUnboundLocalError("mmq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __Pyx_INCREF(__pyx_v_mmq);
+    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_mmq);
+    __Pyx_GIVEREF(__pyx_v_mmq);
+    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__float64); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (PyDict_SetItem(__pyx_t_3, ((PyObject *)__pyx_n_s__dtype), __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_6), ((PyObject *)__pyx_t_3)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = ((PyArrayObject *)__pyx_t_5);
+    {
+      __Pyx_BufFmt_StackElem __pyx_stack[1];
+      __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mq);
+      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_mq, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+      if (unlikely(__pyx_t_8 < 0)) {
+        PyErr_Fetch(&__pyx_t_11, &__pyx_t_10, &__pyx_t_9);
+        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mq, (PyObject*)__pyx_v_mq, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+          Py_XDECREF(__pyx_t_11); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_9);
+          __Pyx_RaiseBufferFallbackError();
+        } else {
+          PyErr_Restore(__pyx_t_11, __pyx_t_10, __pyx_t_9);
+        }
+      }
+      __pyx_bstride_0_mq = __pyx_bstruct_mq.strides[0];
+      __pyx_bshape_0_mq = __pyx_bstruct_mq.shape[0];
+      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_t_7 = 0;
+    __pyx_v_mq = ((PyArrayObject *)__pyx_t_5);
+    __pyx_t_5 = 0;
+
+    /* "healpy/src/_sphtools.pyx":174
+ *     if polarization:
+ *         mq = np.ascontiguousarray(mmq, dtype = np.float64)
  *         mask_mq = False if count_bad(mq) == 0 else mkmask(mq)             # <<<<<<<<<<<<<<
+ *         mu = np.ascontiguousarray(mmu, dtype = np.float64)
  *         mask_mu = False if count_bad(mu) == 0 else mkmask(mu)
- * 
  */
-    if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_mq) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mq, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mq), 0) == 0) != 0)) {
-      __Pyx_INCREF(Py_False);
-      __pyx_t_6 = Py_False;
+    if ((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mq), 0) == 0)) {
+      __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = __pyx_t_3;
+      __pyx_t_3 = 0;
     } else {
-      if (!(likely(((__pyx_v_mq) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mq, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mq), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_6 = __pyx_t_1;
-      __pyx_t_1 = 0;
+      __pyx_t_3 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mq), 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = __pyx_t_3;
+      __pyx_t_3 = 0;
     }
-    __pyx_v_mask_mq = __pyx_t_6;
-    __pyx_t_6 = 0;
+    __pyx_v_mask_mq = __pyx_t_5;
+    __pyx_t_5 = 0;
 
-    /* "healpy/src/_sphtools.pyx":222
- *     if polarization:
+    /* "healpy/src/_sphtools.pyx":175
+ *         mq = np.ascontiguousarray(mmq, dtype = np.float64)
+ *         mask_mq = False if count_bad(mq) == 0 else mkmask(mq)
+ *         mu = np.ascontiguousarray(mmu, dtype = np.float64)             # <<<<<<<<<<<<<<
+ *         mask_mu = False if count_bad(mu) == 0 else mkmask(mu)
+ * 
+ */
+    __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (unlikely(!__pyx_v_mmu)) { __Pyx_RaiseUnboundLocalError("mmu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+    __Pyx_INCREF(__pyx_v_mmu);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_mmu);
+    __Pyx_GIVEREF(__pyx_v_mmu);
+    __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__float64); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (PyDict_SetItem(__pyx_t_6, ((PyObject *)__pyx_n_s__dtype), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_5), ((PyObject *)__pyx_t_6)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = ((PyArrayObject *)__pyx_t_2);
+    {
+      __Pyx_BufFmt_StackElem __pyx_stack[1];
+      __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mu);
+      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_mu, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+      if (unlikely(__pyx_t_8 < 0)) {
+        PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
+        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mu, (PyObject*)__pyx_v_mu, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+          Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
+          __Pyx_RaiseBufferFallbackError();
+        } else {
+          PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
+        }
+      }
+      __pyx_bstride_0_mu = __pyx_bstruct_mu.strides[0];
+      __pyx_bshape_0_mu = __pyx_bstruct_mu.shape[0];
+      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_t_7 = 0;
+    __pyx_v_mu = ((PyArrayObject *)__pyx_t_2);
+    __pyx_t_2 = 0;
+
+    /* "healpy/src/_sphtools.pyx":176
  *         mask_mq = False if count_bad(mq) == 0 else mkmask(mq)
+ *         mu = np.ascontiguousarray(mmu, dtype = np.float64)
  *         mask_mu = False if count_bad(mu) == 0 else mkmask(mu)             # <<<<<<<<<<<<<<
  * 
- *     # Adjust lmax and mmax
+ *     # replace UNSEEN pixels with zeros
  */
-    if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_mu) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mu, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mu), 0) == 0) != 0)) {
-      __Pyx_INCREF(Py_False);
-      __pyx_t_6 = Py_False;
+    if ((__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_mu), 0) == 0)) {
+      __pyx_t_6 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_2 = __pyx_t_6;
+      __pyx_t_6 = 0;
     } else {
-      if (!(likely(((__pyx_v_mu) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mu, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mu), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_6 = __pyx_t_1;
-      __pyx_t_1 = 0;
+      __pyx_t_6 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_mu), 0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_2 = __pyx_t_6;
+      __pyx_t_6 = 0;
     }
-    __pyx_v_mask_mu = __pyx_t_6;
-    __pyx_t_6 = 0;
-    goto __pyx_L4;
+    __pyx_v_mask_mu = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L7;
   }
-  __pyx_L4:;
+  __pyx_L7:;
 
-  /* "healpy/src/_sphtools.pyx":226
+  /* "healpy/src/_sphtools.pyx":179
+ * 
+ *     # replace UNSEEN pixels with zeros
+ *     if mask_mi is not False:             # <<<<<<<<<<<<<<
+ *         mi[mask_mi] = 0.0
+ *     if polarization:
+ */
+  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = (__pyx_v_mask_mi != __pyx_t_2);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (__pyx_t_4) {
+
+    /* "healpy/src/_sphtools.pyx":180
+ *     # replace UNSEEN pixels with zeros
+ *     if mask_mi is not False:
+ *         mi[mask_mi] = 0.0             # <<<<<<<<<<<<<<
+ *     if polarization:
+ *         if mask_mq is not False:
+ */
+    __pyx_t_2 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    if (PyObject_SetItem(((PyObject *)__pyx_v_mi), __pyx_v_mask_mi, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    goto __pyx_L8;
+  }
+  __pyx_L8:;
+
+  /* "healpy/src/_sphtools.pyx":181
+ *     if mask_mi is not False:
+ *         mi[mask_mi] = 0.0
+ *     if polarization:             # <<<<<<<<<<<<<<
+ *         if mask_mq is not False:
+ *             mq[mask_mq] = 0.0
+ */
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_mask_mq)) { __Pyx_RaiseUnboundLocalError("mask_mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "healpy/src/_sphtools.pyx":182
+ *         mi[mask_mi] = 0.0
+ *     if polarization:
+ *         if mask_mq is not False:             # <<<<<<<<<<<<<<
+ *             mq[mask_mq] = 0.0
+ *         if mask_mu is not False:
+ */
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = (__pyx_v_mask_mq != __pyx_t_2);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_4) {
+
+      /* "healpy/src/_sphtools.pyx":183
+ *     if polarization:
+ *         if mask_mq is not False:
+ *             mq[mask_mq] = 0.0             # <<<<<<<<<<<<<<
+ *         if mask_mu is not False:
+ *             mu[mask_mu] = 0.0
+ */
+      __pyx_t_2 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (PyObject_SetItem(((PyObject *)__pyx_v_mq), __pyx_v_mask_mq, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      goto __pyx_L10;
+    }
+    __pyx_L10:;
+    if (unlikely(!__pyx_v_mask_mu)) { __Pyx_RaiseUnboundLocalError("mask_mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "healpy/src/_sphtools.pyx":184
+ *         if mask_mq is not False:
+ *             mq[mask_mq] = 0.0
+ *         if mask_mu is not False:             # <<<<<<<<<<<<<<
+ *             mu[mask_mu] = 0.0
+ * 
+ */
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = (__pyx_v_mask_mu != __pyx_t_2);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_4) {
+
+      /* "healpy/src/_sphtools.pyx":185
+ *             mq[mask_mq] = 0.0
+ *         if mask_mu is not False:
+ *             mu[mask_mu] = 0.0             # <<<<<<<<<<<<<<
+ * 
+ *     # Adjust lmax and mmax
+ */
+      __pyx_t_2 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (PyObject_SetItem(((PyObject *)__pyx_v_mu), __pyx_v_mask_mu, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      goto __pyx_L11;
+    }
+    __pyx_L11:;
+    goto __pyx_L9;
+  }
+  __pyx_L9:;
+
+  /* "healpy/src/_sphtools.pyx":189
  *     # Adjust lmax and mmax
  *     cdef int lmax_, mmax_, nside, npix
  *     npix = mi.size             # <<<<<<<<<<<<<<
  *     nside = npix2nside(npix)
  *     if lmax is None:
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_mi, __pyx_n_s_size); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_6); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_v_npix = __pyx_t_7;
+  __pyx_t_2 = PyObject_GetAttr(((PyObject *)__pyx_v_mi), __pyx_n_s__size); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_t_2); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v_npix = __pyx_t_8;
 
-  /* "healpy/src/_sphtools.pyx":227
+  /* "healpy/src/_sphtools.pyx":190
  *     cdef int lmax_, mmax_, nside, npix
  *     npix = mi.size
  *     nside = npix2nside(npix)             # <<<<<<<<<<<<<<
  *     if lmax is None:
  *         lmax_ = 3 * nside - 1
  */
-  __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_npix2nside); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__npix2nside); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_6 = PyInt_FromLong(__pyx_v_npix); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_npix); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __pyx_t_1 = 0;
-  __pyx_t_1 = PyObject_Call(__pyx_t_6, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6);
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+  __pyx_t_6 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_t_6); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_nside = __pyx_t_7;
+  __pyx_v_nside = __pyx_t_8;
 
-  /* "healpy/src/_sphtools.pyx":228
+  /* "healpy/src/_sphtools.pyx":191
  *     npix = mi.size
  *     nside = npix2nside(npix)
  *     if lmax is None:             # <<<<<<<<<<<<<<
  *         lmax_ = 3 * nside - 1
  *     else:
  */
   __pyx_t_4 = (__pyx_v_lmax == Py_None);
-  __pyx_t_8 = (__pyx_t_4 != 0);
-  if (__pyx_t_8) {
+  if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":229
+    /* "healpy/src/_sphtools.pyx":192
  *     nside = npix2nside(npix)
  *     if lmax is None:
  *         lmax_ = 3 * nside - 1             # <<<<<<<<<<<<<<
  *     else:
  *         lmax_ = lmax
  */
     __pyx_v_lmax_ = ((3 * __pyx_v_nside) - 1);
-    goto __pyx_L5;
+    goto __pyx_L12;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":231
+    /* "healpy/src/_sphtools.pyx":194
  *         lmax_ = 3 * nside - 1
  *     else:
  *         lmax_ = lmax             # <<<<<<<<<<<<<<
  *     if mmax is None:
  *         mmax_ = lmax_
  */
-    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_lmax_ = __pyx_t_7;
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_lmax); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_lmax_ = __pyx_t_8;
   }
-  __pyx_L5:;
+  __pyx_L12:;
 
-  /* "healpy/src/_sphtools.pyx":232
+  /* "healpy/src/_sphtools.pyx":195
  *     else:
  *         lmax_ = lmax
  *     if mmax is None:             # <<<<<<<<<<<<<<
  *         mmax_ = lmax_
  *     else:
  */
-  __pyx_t_8 = (__pyx_v_mmax == Py_None);
-  __pyx_t_4 = (__pyx_t_8 != 0);
+  __pyx_t_4 = (__pyx_v_mmax == Py_None);
   if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":233
+    /* "healpy/src/_sphtools.pyx":196
  *         lmax_ = lmax
  *     if mmax is None:
  *         mmax_ = lmax_             # <<<<<<<<<<<<<<
  *     else:
  *         mmax_ = mmax
  */
     __pyx_v_mmax_ = __pyx_v_lmax_;
-    goto __pyx_L6;
+    goto __pyx_L13;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":235
+    /* "healpy/src/_sphtools.pyx":198
  *         mmax_ = lmax_
  *     else:
  *         mmax_ = mmax             # <<<<<<<<<<<<<<
  * 
  *     # Check all maps have same npix
  */
-    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_mmax_ = __pyx_t_7;
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_mmax); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 198; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_mmax_ = __pyx_t_8;
   }
-  __pyx_L6:;
+  __pyx_L13:;
 
-  /* "healpy/src/_sphtools.pyx":238
+  /* "healpy/src/_sphtools.pyx":201
  * 
  *     # Check all maps have same npix
  *     if polarization:             # <<<<<<<<<<<<<<
  *         if mq.size != npix or mu.size != npix:
  *             raise ValueError("Input maps must have same size")
  */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_6 = PyObject_GetAttr(((PyObject *)__pyx_v_mq), __pyx_n_s__size); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":239
+    /* "healpy/src/_sphtools.pyx":202
  *     # Check all maps have same npix
  *     if polarization:
  *         if mq.size != npix or mu.size != npix:             # <<<<<<<<<<<<<<
  *             raise ValueError("Input maps must have same size")
  * 
  */
-    if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_mq, __pyx_n_s_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_npix); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_6 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_5 = PyInt_FromLong(__pyx_v_npix); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_2 = PyObject_RichCompare(__pyx_t_6, __pyx_t_5, Py_NE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     if (!__pyx_t_4) {
-      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_mu, __pyx_n_s_size); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_2 = PyObject_GetAttr(((PyObject *)__pyx_v_mu), __pyx_n_s__size); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_5 = PyInt_FromLong(__pyx_v_npix); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyObject_RichCompare(__pyx_t_2, __pyx_t_5, Py_NE); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_npix); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_1 = PyObject_RichCompare(__pyx_t_6, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_12 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_9 = __pyx_t_8;
+      __pyx_t_13 = __pyx_t_12;
     } else {
-      __pyx_t_9 = __pyx_t_4;
+      __pyx_t_13 = __pyx_t_4;
     }
-    if (__pyx_t_9) {
+    if (__pyx_t_13) {
 
-      /* "healpy/src/_sphtools.pyx":240
+      /* "healpy/src/_sphtools.pyx":203
  *     if polarization:
  *         if mq.size != npix or mu.size != npix:
  *             raise ValueError("Input maps must have same size")             # <<<<<<<<<<<<<<
  * 
- *     # View the ndarray as a Healpix_Map
+ *     # Wrap the map into an Healpix_Map
  */
-      __pyx_t_1 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_11), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L15;
     }
-    goto __pyx_L7;
+    __pyx_L15:;
+    goto __pyx_L14;
   }
-  __pyx_L7:;
+  __pyx_L14:;
 
-  /* "healpy/src/_sphtools.pyx":243
+  /* "healpy/src/_sphtools.pyx":206
  * 
- *     # View the ndarray as a Healpix_Map
- *     MI = ndarray2map(mi, RING)             # <<<<<<<<<<<<<<
+ *     # Wrap the map into an Healpix_Map
+ *     MI = WrapMap(mi)             # <<<<<<<<<<<<<<
  *     if polarization:
- *         MQ = ndarray2map(mq, RING)
+ *         MQ = WrapMap(mq)
  */
-  if (!(likely(((__pyx_v_mi) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mi, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_10 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_v_mi), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_MI = __pyx_t_10;
-
-  /* "healpy/src/_sphtools.pyx":244
- *     # View the ndarray as a Healpix_Map
- *     MI = ndarray2map(mi, RING)
+  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+  __Pyx_INCREF(((PyObject *)__pyx_v_mi));
+  PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_v_mi));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_mi));
+  __pyx_t_5 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapMap)), ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+  __pyx_v_MI = ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_t_5);
+  __pyx_t_5 = 0;
+
+  /* "healpy/src/_sphtools.pyx":207
+ *     # Wrap the map into an Healpix_Map
+ *     MI = WrapMap(mi)
  *     if polarization:             # <<<<<<<<<<<<<<
- *         MQ = ndarray2map(mq, RING)
- *         MU = ndarray2map(mu, RING)
+ *         MQ = WrapMap(mq)
+ *         MU = WrapMap(mu)
  */
-  __pyx_t_9 = (__pyx_v_polarization != 0);
-  if (__pyx_t_9) {
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":245
- *     MI = ndarray2map(mi, RING)
+    /* "healpy/src/_sphtools.pyx":208
+ *     MI = WrapMap(mi)
  *     if polarization:
- *         MQ = ndarray2map(mq, RING)             # <<<<<<<<<<<<<<
- *         MU = ndarray2map(mu, RING)
+ *         MQ = WrapMap(mq)             # <<<<<<<<<<<<<<
+ *         MU = WrapMap(mu)
  * 
  */
-    if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_mq) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mq, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_10 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_v_mq), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_MQ = __pyx_t_10;
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+    __Pyx_INCREF(((PyObject *)__pyx_v_mq));
+    PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_v_mq));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_mq));
+    __pyx_t_6 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapMap)), ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __pyx_v_MQ = ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_t_6);
+    __pyx_t_6 = 0;
+    if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":246
+    /* "healpy/src/_sphtools.pyx":209
  *     if polarization:
- *         MQ = ndarray2map(mq, RING)
- *         MU = ndarray2map(mu, RING)             # <<<<<<<<<<<<<<
+ *         MQ = WrapMap(mq)
+ *         MU = WrapMap(mu)             # <<<<<<<<<<<<<<
  * 
- *     # replace UNSEEN pixels with zeros
+ *     # if regression is True, remove average of the intensity map before computing alm
  */
-    if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_mu) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_mu, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_10 = __pyx_f_7_common_ndarray2map(((PyArrayObject *)__pyx_v_mu), RING); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_MU = __pyx_t_10;
-    goto __pyx_L9;
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __Pyx_INCREF(((PyObject *)__pyx_v_mu));
+    PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_v_mu));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_mu));
+    __pyx_t_5 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapMap)), ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __pyx_v_MU = ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)__pyx_t_5);
+    __pyx_t_5 = 0;
+    goto __pyx_L16;
   }
-  __pyx_L9:;
+  __pyx_L16:;
 
-  /* "healpy/src/_sphtools.pyx":249
+  /* "healpy/src/_sphtools.pyx":212
  * 
- *     # replace UNSEEN pixels with zeros
- *     if mask_mi is not False:             # <<<<<<<<<<<<<<
- *         mi[mask_mi] = 0.0
- *     if polarization:
+ *     # if regression is True, remove average of the intensity map before computing alm
+ *     cdef double avg = 0.0             # <<<<<<<<<<<<<<
+ *     if regression:
+ *         avg = MI.h.average()
+ */
+  __pyx_v_avg = 0.0;
+
+  /* "healpy/src/_sphtools.pyx":213
+ *     # if regression is True, remove average of the intensity map before computing alm
+ *     cdef double avg = 0.0
+ *     if regression:             # <<<<<<<<<<<<<<
+ *         avg = MI.h.average()
+ *         MI.h.Add(-avg)
  */
-  __pyx_t_9 = (__pyx_v_mask_mi != Py_False);
-  __pyx_t_4 = (__pyx_t_9 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_13 = __Pyx_PyObject_IsTrue(__pyx_v_regression); if (unlikely(__pyx_t_13 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_13) {
 
-    /* "healpy/src/_sphtools.pyx":250
- *     # replace UNSEEN pixels with zeros
- *     if mask_mi is not False:
- *         mi[mask_mi] = 0.0             # <<<<<<<<<<<<<<
- *     if polarization:
- *         if mask_mq is not False:
- */
-    if (unlikely(PyObject_SetItem(__pyx_v_mi, __pyx_v_mask_mi, __pyx_float_0_0) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    goto __pyx_L10;
-  }
-  __pyx_L10:;
-
-  /* "healpy/src/_sphtools.pyx":251
- *     if mask_mi is not False:
- *         mi[mask_mi] = 0.0
- *     if polarization:             # <<<<<<<<<<<<<<
- *         if mask_mq is not False:
- *             mq[mask_mq] = 0.0
- */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
-
-    /* "healpy/src/_sphtools.pyx":252
- *         mi[mask_mi] = 0.0
- *     if polarization:
- *         if mask_mq is not False:             # <<<<<<<<<<<<<<
- *             mq[mask_mq] = 0.0
- *         if mask_mu is not False:
- */
-    if (unlikely(!__pyx_v_mask_mq)) { __Pyx_RaiseUnboundLocalError("mask_mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_4 = (__pyx_v_mask_mq != Py_False);
-    __pyx_t_9 = (__pyx_t_4 != 0);
-    if (__pyx_t_9) {
-
-      /* "healpy/src/_sphtools.pyx":253
- *     if polarization:
- *         if mask_mq is not False:
- *             mq[mask_mq] = 0.0             # <<<<<<<<<<<<<<
- *         if mask_mu is not False:
- *             mu[mask_mu] = 0.0
- */
-      if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-      if (unlikely(PyObject_SetItem(__pyx_v_mq, __pyx_v_mask_mq, __pyx_float_0_0) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      goto __pyx_L12;
-    }
-    __pyx_L12:;
-
-    /* "healpy/src/_sphtools.pyx":254
- *         if mask_mq is not False:
- *             mq[mask_mq] = 0.0
- *         if mask_mu is not False:             # <<<<<<<<<<<<<<
- *             mu[mask_mu] = 0.0
+    /* "healpy/src/_sphtools.pyx":214
+ *     cdef double avg = 0.0
+ *     if regression:
+ *         avg = MI.h.average()             # <<<<<<<<<<<<<<
+ *         MI.h.Add(-avg)
  * 
  */
-    if (unlikely(!__pyx_v_mask_mu)) { __Pyx_RaiseUnboundLocalError("mask_mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_9 = (__pyx_v_mask_mu != Py_False);
-    __pyx_t_4 = (__pyx_t_9 != 0);
-    if (__pyx_t_4) {
-
-      /* "healpy/src/_sphtools.pyx":255
- *             mq[mask_mq] = 0.0
- *         if mask_mu is not False:
- *             mu[mask_mu] = 0.0             # <<<<<<<<<<<<<<
- * 
+    __pyx_v_avg = __pyx_v_MI->h->average();
+
+    /* "healpy/src/_sphtools.pyx":215
+ *     if regression:
+ *         avg = MI.h.average()
+ *         MI.h.Add(-avg)             # <<<<<<<<<<<<<<
  * 
+ *     # Create an ndarray object that will contain the alm for output (to be returned)
  */
-      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-      if (unlikely(PyObject_SetItem(__pyx_v_mu, __pyx_v_mask_mu, __pyx_float_0_0) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      goto __pyx_L13;
-    }
-    __pyx_L13:;
-    goto __pyx_L11;
+    __pyx_v_MI->h->Add((-__pyx_v_avg));
+    goto __pyx_L17;
   }
-  __pyx_L11:;
+  __pyx_L17:;
 
-  /* "healpy/src/_sphtools.pyx":259
- * 
+  /* "healpy/src/_sphtools.pyx":219
  *     # Create an ndarray object that will contain the alm for output (to be returned)
- *     n_alm = alm_getn(lmax_, mmax_)             # <<<<<<<<<<<<<<
- *     almI = np.empty(n_alm, dtype=np.complex128)
+ *     cdef np.ndarray almI, almQ, almC
+ *     n_alm = Num_Alms(lmax_, mmax_)             # <<<<<<<<<<<<<<
+ *     almI = np.empty(n_alm, dtype = np.complex128)
  *     if polarization:
  */
-  __pyx_v_n_alm = __pyx_f_6healpy_9_sphtools_alm_getn(__pyx_v_lmax_, __pyx_v_mmax_);
+  __pyx_t_5 = __pyx_f_6healpy_9_sphtools_Num_Alms(__pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_v_n_alm = __pyx_t_5;
+  __pyx_t_5 = 0;
 
-  /* "healpy/src/_sphtools.pyx":260
- *     # Create an ndarray object that will contain the alm for output (to be returned)
- *     n_alm = alm_getn(lmax_, mmax_)
- *     almI = np.empty(n_alm, dtype=np.complex128)             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":220
+ *     cdef np.ndarray almI, almQ, almC
+ *     n_alm = Num_Alms(lmax_, mmax_)
+ *     almI = np.empty(n_alm, dtype = np.complex128)             # <<<<<<<<<<<<<<
  *     if polarization:
- *         almG = np.empty(n_alm, dtype=np.complex128)
+ *         almG = np.empty(n_alm, dtype = np.complex128)
  */
-  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_n_alm); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __pyx_t_1 = 0;
-  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_complex128); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__empty); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = PyObject_Call(__pyx_t_3, __pyx_t_6, __pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  __Pyx_INCREF(__pyx_v_n_alm);
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_n_alm);
+  __Pyx_GIVEREF(__pyx_v_n_alm);
+  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__complex128); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_n_s__dtype), __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_almI = __pyx_t_5;
-  __pyx_t_5 = 0;
+  __pyx_t_1 = PyEval_CallObjectWithKeywords(__pyx_t_6, ((PyObject *)__pyx_t_5), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_almI = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":261
- *     n_alm = alm_getn(lmax_, mmax_)
- *     almI = np.empty(n_alm, dtype=np.complex128)
+  /* "healpy/src/_sphtools.pyx":221
+ *     n_alm = Num_Alms(lmax_, mmax_)
+ *     almI = np.empty(n_alm, dtype = np.complex128)
  *     if polarization:             # <<<<<<<<<<<<<<
- *         almG = np.empty(n_alm, dtype=np.complex128)
- *         almC = np.empty(n_alm, dtype=np.complex128)
+ *         almG = np.empty(n_alm, dtype = np.complex128)
+ *         almC = np.empty(n_alm, dtype = np.complex128)
  */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
+  if (__pyx_v_polarization) {
 
-    /* "healpy/src/_sphtools.pyx":262
- *     almI = np.empty(n_alm, dtype=np.complex128)
+    /* "healpy/src/_sphtools.pyx":222
+ *     almI = np.empty(n_alm, dtype = np.complex128)
  *     if polarization:
- *         almG = np.empty(n_alm, dtype=np.complex128)             # <<<<<<<<<<<<<<
- *         almC = np.empty(n_alm, dtype=np.complex128)
+ *         almG = np.empty(n_alm, dtype = np.complex128)             # <<<<<<<<<<<<<<
+ *         almC = np.empty(n_alm, dtype = np.complex128)
  * 
  */
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_n_alm); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__empty); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_v_n_alm);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_n_alm);
+    __Pyx_GIVEREF(__pyx_v_n_alm);
+    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+    __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
-    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_6, __pyx_n_s__complex128); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_complex128); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (PyDict_SetItem(__pyx_t_5, ((PyObject *)__pyx_n_s__dtype), __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_2, ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_t_5)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyObject_Call(__pyx_t_1, __pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_v_almG = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __pyx_v_almG = __pyx_t_3;
+    __pyx_t_3 = 0;
 
-    /* "healpy/src/_sphtools.pyx":263
+    /* "healpy/src/_sphtools.pyx":223
  *     if polarization:
- *         almG = np.empty(n_alm, dtype=np.complex128)
- *         almC = np.empty(n_alm, dtype=np.complex128)             # <<<<<<<<<<<<<<
+ *         almG = np.empty(n_alm, dtype = np.complex128)
+ *         almC = np.empty(n_alm, dtype = np.complex128)             # <<<<<<<<<<<<<<
  * 
- *     # View the ndarray as an Alm
+ *     # Wrap it into an healpix Alm object
  */
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__empty); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_n_alm); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __Pyx_INCREF(__pyx_v_n_alm);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_n_alm);
+    __Pyx_GIVEREF(__pyx_v_n_alm);
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__complex128); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
-    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    __pyx_t_2 = 0;
-    __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_complex128); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_almC = __pyx_t_3;
-    __pyx_t_3 = 0;
-    goto __pyx_L14;
+    if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__dtype), __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_6 = PyEval_CallObjectWithKeywords(__pyx_t_5, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    if (!(likely(((__pyx_t_6) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_6, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_almC = ((PyArrayObject *)__pyx_t_6);
+    __pyx_t_6 = 0;
+    goto __pyx_L18;
   }
-  __pyx_L14:;
+  __pyx_L18:;
 
-  /* "healpy/src/_sphtools.pyx":266
+  /* "healpy/src/_sphtools.pyx":226
  * 
- *     # View the ndarray as an Alm
- *     AI = ndarray2alm(almI, lmax_, mmax_)             # <<<<<<<<<<<<<<
+ *     # Wrap it into an healpix Alm object
+ *     AI = WrapAlm(almI, lmax_, mmax_)             # <<<<<<<<<<<<<<
  *     if polarization:
- *         AG = ndarray2alm(almG, lmax_, mmax_)
+ *         AG = WrapAlm(almG, lmax_, mmax_)
  */
-  if (!(likely(((__pyx_v_almI) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_almI, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_11 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_almI), __pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_AI = __pyx_t_11;
+  __pyx_t_6 = PyInt_FromLong(__pyx_v_lmax_); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_mmax_); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_almI));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_almI));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_almI));
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_6);
+  __Pyx_GIVEREF(__pyx_t_6);
+  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_6 = 0;
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapAlm)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_v_AI = ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":267
- *     # View the ndarray as an Alm
- *     AI = ndarray2alm(almI, lmax_, mmax_)
+  /* "healpy/src/_sphtools.pyx":227
+ *     # Wrap it into an healpix Alm object
+ *     AI = WrapAlm(almI, lmax_, mmax_)
  *     if polarization:             # <<<<<<<<<<<<<<
- *         AG = ndarray2alm(almG, lmax_, mmax_)
- *         AC = ndarray2alm(almC, lmax_, mmax_)
+ *         AG = WrapAlm(almG, lmax_, mmax_)
+ *         AC = WrapAlm(almC, lmax_, mmax_)
  */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_almG)) { __Pyx_RaiseUnboundLocalError("almG"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_1 = PyInt_FromLong(__pyx_v_lmax_); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":268
- *     AI = ndarray2alm(almI, lmax_, mmax_)
+    /* "healpy/src/_sphtools.pyx":228
+ *     AI = WrapAlm(almI, lmax_, mmax_)
  *     if polarization:
- *         AG = ndarray2alm(almG, lmax_, mmax_)             # <<<<<<<<<<<<<<
- *         AC = ndarray2alm(almC, lmax_, mmax_)
+ *         AG = WrapAlm(almG, lmax_, mmax_)             # <<<<<<<<<<<<<<
+ *         AC = WrapAlm(almC, lmax_, mmax_)
  * 
  */
-    if (unlikely(!__pyx_v_almG)) { __Pyx_RaiseUnboundLocalError("almG"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_almG) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_almG, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_11 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_almG), __pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_AG = __pyx_t_11;
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyInt_FromLong(__pyx_v_mmax_); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __Pyx_INCREF(__pyx_v_almG);
+    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_almG);
+    __Pyx_GIVEREF(__pyx_v_almG);
+    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_3);
+    __pyx_t_1 = 0;
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapAlm)), ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __pyx_v_AG = ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_t_3);
+    __pyx_t_3 = 0;
+    if (unlikely(!__pyx_v_almC)) { __Pyx_RaiseUnboundLocalError("almC"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_3 = PyInt_FromLong(__pyx_v_lmax_); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":269
+    /* "healpy/src/_sphtools.pyx":229
  *     if polarization:
- *         AG = ndarray2alm(almG, lmax_, mmax_)
- *         AC = ndarray2alm(almC, lmax_, mmax_)             # <<<<<<<<<<<<<<
+ *         AG = WrapAlm(almG, lmax_, mmax_)
+ *         AC = WrapAlm(almC, lmax_, mmax_)             # <<<<<<<<<<<<<<
  * 
  *     # ring weights
  */
-    if (unlikely(!__pyx_v_almC)) { __Pyx_RaiseUnboundLocalError("almC"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (!(likely(((__pyx_v_almC) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_almC, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_11 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_almC), __pyx_v_lmax_, __pyx_v_mmax_); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_AC = __pyx_t_11;
-    goto __pyx_L15;
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = PyInt_FromLong(__pyx_v_mmax_); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(((PyObject *)__pyx_v_almC));
+    PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_almC));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_almC));
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_6);
+    __Pyx_GIVEREF(__pyx_t_6);
+    __pyx_t_3 = 0;
+    __pyx_t_6 = 0;
+    __pyx_t_6 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6healpy_9_sphtools_WrapAlm)), ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __pyx_v_AC = ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)__pyx_t_6);
+    __pyx_t_6 = 0;
+    goto __pyx_L19;
   }
-  __pyx_L15:;
+  __pyx_L19:;
 
-  /* "healpy/src/_sphtools.pyx":272
+  /* "healpy/src/_sphtools.pyx":232
  * 
  *     # ring weights
  *     cdef arr[double] * w_arr = new arr[double]()             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char *c_datapath
  */
   __pyx_v_w_arr = new arr<double>();
 
-  /* "healpy/src/_sphtools.pyx":275
+  /* "healpy/src/_sphtools.pyx":235
  *     cdef int i
  *     cdef char *c_datapath
  *     if use_weights:             # <<<<<<<<<<<<<<
  *         if datapath is None:
  *             datapath = get_datapath()
  */
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_use_weights); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  if (__pyx_t_4) {
+  __pyx_t_13 = __Pyx_PyObject_IsTrue(__pyx_v_use_weights); if (unlikely(__pyx_t_13 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_13) {
 
-    /* "healpy/src/_sphtools.pyx":276
+    /* "healpy/src/_sphtools.pyx":236
  *     cdef char *c_datapath
  *     if use_weights:
  *         if datapath is None:             # <<<<<<<<<<<<<<
  *             datapath = get_datapath()
  *         c_datapath = datapath
  */
-    __pyx_t_4 = (__pyx_v_datapath == Py_None);
-    __pyx_t_9 = (__pyx_t_4 != 0);
-    if (__pyx_t_9) {
+    __pyx_t_13 = (__pyx_v_datapath == Py_None);
+    if (__pyx_t_13) {
 
-      /* "healpy/src/_sphtools.pyx":277
+      /* "healpy/src/_sphtools.pyx":237
  *     if use_weights:
  *         if datapath is None:
  *             datapath = get_datapath()             # <<<<<<<<<<<<<<
  *         c_datapath = datapath
  *         weightfile = 'weight_ring_n%05d.fits' % (nside)
  */
-      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_datapath); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_2 = PyObject_Call(__pyx_t_3, __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF_SET(__pyx_v_datapath, __pyx_t_2);
-      __pyx_t_2 = 0;
-      goto __pyx_L17;
+      __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__get_datapath); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_1 = PyObject_Call(__pyx_t_6, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_v_datapath);
+      __pyx_v_datapath = __pyx_t_1;
+      __pyx_t_1 = 0;
+      goto __pyx_L21;
     }
-    __pyx_L17:;
+    __pyx_L21:;
 
-    /* "healpy/src/_sphtools.pyx":278
+    /* "healpy/src/_sphtools.pyx":238
  *         if datapath is None:
  *             datapath = get_datapath()
  *         c_datapath = datapath             # <<<<<<<<<<<<<<
  *         weightfile = 'weight_ring_n%05d.fits' % (nside)
  *         if not os.path.isfile(os.path.join(datapath, weightfile)):
  */
-    __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_datapath); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_c_datapath = __pyx_t_12;
+    __pyx_t_14 = PyBytes_AsString(__pyx_v_datapath); if (unlikely((!__pyx_t_14) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_c_datapath = __pyx_t_14;
 
-    /* "healpy/src/_sphtools.pyx":279
+    /* "healpy/src/_sphtools.pyx":239
  *             datapath = get_datapath()
  *         c_datapath = datapath
  *         weightfile = 'weight_ring_n%05d.fits' % (nside)             # <<<<<<<<<<<<<<
  *         if not os.path.isfile(os.path.join(datapath, weightfile)):
  *             raise IOError('Weight file not found in %s' % (datapath))
  */
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_nside); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_weight_ring_n_05d_fits, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_weightfile = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_t_1 = PyInt_FromLong(__pyx_v_nside); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_6 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_12), __pyx_t_1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_v_weightfile = ((PyObject *)__pyx_t_6);
+    __pyx_t_6 = 0;
 
-    /* "healpy/src/_sphtools.pyx":280
+    /* "healpy/src/_sphtools.pyx":240
  *         c_datapath = datapath
  *         weightfile = 'weight_ring_n%05d.fits' % (nside)
  *         if not os.path.isfile(os.path.join(datapath, weightfile)):             # <<<<<<<<<<<<<<
  *             raise IOError('Weight file not found in %s' % (datapath))
  *         read_weight_ring(string(c_datapath), nside, w_arr[0])
  */
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isfile); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_join); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = PyObject_GetAttr(__pyx_t_6, __pyx_n_s__path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__isfile); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__path); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__join); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
     __Pyx_INCREF(__pyx_v_datapath);
-    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_datapath);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_datapath);
     __Pyx_GIVEREF(__pyx_v_datapath);
     __Pyx_INCREF(__pyx_v_weightfile);
-    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_weightfile);
+    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_weightfile);
     __Pyx_GIVEREF(__pyx_v_weightfile);
-    __pyx_t_5 = PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_5 = PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyObject_Call(__pyx_t_6, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_9 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __pyx_t_13 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_13 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_4 = ((!__pyx_t_9) != 0);
+    __pyx_t_4 = (!__pyx_t_13);
     if (__pyx_t_4) {
 
-      /* "healpy/src/_sphtools.pyx":281
+      /* "healpy/src/_sphtools.pyx":241
  *         weightfile = 'weight_ring_n%05d.fits' % (nside)
  *         if not os.path.isfile(os.path.join(datapath, weightfile)):
  *             raise IOError('Weight file not found in %s' % (datapath))             # <<<<<<<<<<<<<<
  *         read_weight_ring(string(c_datapath), nside, w_arr[0])
  *         for i in range(w_arr.size()):
  */
-      __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Weight_file_not_found_in_s, __pyx_v_datapath); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_5);
+      __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_13), __pyx_v_datapath); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_5));
       __pyx_t_5 = 0;
-      __pyx_t_5 = PyObject_Call(__pyx_builtin_IOError, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_IOError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L22;
     }
+    __pyx_L22:;
 
-    /* "healpy/src/_sphtools.pyx":282
+    /* "healpy/src/_sphtools.pyx":242
  *         if not os.path.isfile(os.path.join(datapath, weightfile)):
  *             raise IOError('Weight file not found in %s' % (datapath))
  *         read_weight_ring(string(c_datapath), nside, w_arr[0])             # <<<<<<<<<<<<<<
  *         for i in range(w_arr.size()):
  *             w_arr[0][i] += 1
  */
-    try {
-      __pyx_t_13 = std::string(__pyx_v_c_datapath);
-    } catch(...) {
-      __Pyx_CppExn2PyErr();
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    read_weight_ring(__pyx_t_13, __pyx_v_nside, (__pyx_v_w_arr[0]));
+    read_weight_ring(std::string(__pyx_v_c_datapath), __pyx_v_nside, (__pyx_v_w_arr[0]));
 
-    /* "healpy/src/_sphtools.pyx":283
+    /* "healpy/src/_sphtools.pyx":243
  *             raise IOError('Weight file not found in %s' % (datapath))
  *         read_weight_ring(string(c_datapath), nside, w_arr[0])
  *         for i in range(w_arr.size()):             # <<<<<<<<<<<<<<
  *             w_arr[0][i] += 1
  *     else:
  */
-    __pyx_t_14 = __pyx_v_w_arr->size();
-    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_14; __pyx_t_7+=1) {
-      __pyx_v_i = __pyx_t_7;
+    __pyx_t_15 = __pyx_v_w_arr->size();
+    for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_15; __pyx_t_8+=1) {
+      __pyx_v_i = __pyx_t_8;
 
-      /* "healpy/src/_sphtools.pyx":284
+      /* "healpy/src/_sphtools.pyx":244
  *         read_weight_ring(string(c_datapath), nside, w_arr[0])
  *         for i in range(w_arr.size()):
  *             w_arr[0][i] += 1             # <<<<<<<<<<<<<<
  *     else:
  *         w_arr.allocAndFill(2 * nside, 1.)
  */
-      __pyx_t_15 = 0;
-      __pyx_t_16 = __pyx_v_i;
-      ((__pyx_v_w_arr[__pyx_t_15])[__pyx_t_16]) = (((__pyx_v_w_arr[__pyx_t_15])[__pyx_t_16]) + 1.0);
+      __pyx_t_16 = 0;
+      __pyx_t_17 = __pyx_v_i;
+      ((__pyx_v_w_arr[__pyx_t_16])[__pyx_t_17]) = (((__pyx_v_w_arr[__pyx_t_16])[__pyx_t_17]) + 1.0);
     }
-    goto __pyx_L16;
+    goto __pyx_L20;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":286
+    /* "healpy/src/_sphtools.pyx":246
  *             w_arr[0][i] += 1
  *     else:
  *         w_arr.allocAndFill(2 * nside, 1.)             # <<<<<<<<<<<<<<
  * 
  *     if polarization:
  */
     __pyx_v_w_arr->allocAndFill((2 * __pyx_v_nside), 1.);
   }
-  __pyx_L16:;
+  __pyx_L20:;
 
-  /* "healpy/src/_sphtools.pyx":288
+  /* "healpy/src/_sphtools.pyx":248
  *         w_arr.allocAndFill(2 * nside, 1.)
  * 
  *     if polarization:             # <<<<<<<<<<<<<<
- *         map2alm_pol_iter(MI[0], MQ[0], MU[0], AI[0], AG[0], AC[0], niter, w_arr[0])
- *     else:
+ *         map2alm_pol_iter(MI.h[0], MQ.h[0], MU.h[0], AI.h[0], AG.h[0], AC.h[0],
+ *                          niter, w_arr[0])
  */
-  __pyx_t_4 = (__pyx_v_polarization != 0);
-  if (__pyx_t_4) {
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_MQ)) { __Pyx_RaiseUnboundLocalError("MQ"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (unlikely(!__pyx_v_MU)) { __Pyx_RaiseUnboundLocalError("MU"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (unlikely(!__pyx_v_AG)) { __Pyx_RaiseUnboundLocalError("AG"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (unlikely(!__pyx_v_AC)) { __Pyx_RaiseUnboundLocalError("AC"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_niter); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":289
- * 
+    /* "healpy/src/_sphtools.pyx":250
  *     if polarization:
- *         map2alm_pol_iter(MI[0], MQ[0], MU[0], AI[0], AG[0], AC[0], niter, w_arr[0])             # <<<<<<<<<<<<<<
+ *         map2alm_pol_iter(MI.h[0], MQ.h[0], MU.h[0], AI.h[0], AG.h[0], AC.h[0],
+ *                          niter, w_arr[0])             # <<<<<<<<<<<<<<
  *     else:
- *         map2alm_iter(MI[0], AI[0], niter, w_arr[0])
+ *         map2alm_iter(MI.h[0], AI.h[0], niter, w_arr[0])
  */
-    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_niter); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    map2alm_pol_iter((__pyx_v_MI[0]), (__pyx_v_MQ[0]), (__pyx_v_MU[0]), (__pyx_v_AI[0]), (__pyx_v_AG[0]), (__pyx_v_AC[0]), __pyx_t_7, (__pyx_v_w_arr[0]));
-    goto __pyx_L21;
+    map2alm_pol_iter((__pyx_v_MI->h[0]), (__pyx_v_MQ->h[0]), (__pyx_v_MU->h[0]), (__pyx_v_AI->h[0]), (__pyx_v_AG->h[0]), (__pyx_v_AC->h[0]), __pyx_t_8, (__pyx_v_w_arr[0]));
+    goto __pyx_L25;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":291
- *         map2alm_pol_iter(MI[0], MQ[0], MU[0], AI[0], AG[0], AC[0], niter, w_arr[0])
+    /* "healpy/src/_sphtools.pyx":252
+ *                          niter, w_arr[0])
  *     else:
- *         map2alm_iter(MI[0], AI[0], niter, w_arr[0])             # <<<<<<<<<<<<<<
+ *         map2alm_iter(MI.h[0], AI.h[0], niter, w_arr[0])             # <<<<<<<<<<<<<<
  * 
  *     # restore input map with UNSEEN pixels
  */
-    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_niter); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    map2alm_iter((__pyx_v_MI[0]), (__pyx_v_AI[0]), __pyx_t_7, (__pyx_v_w_arr[0]));
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_niter); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    map2alm_iter((__pyx_v_MI->h[0]), (__pyx_v_AI->h[0]), __pyx_t_8, (__pyx_v_w_arr[0]));
   }
-  __pyx_L21:;
+  __pyx_L25:;
 
-  /* "healpy/src/_sphtools.pyx":294
+  /* "healpy/src/_sphtools.pyx":255
  * 
  *     # restore input map with UNSEEN pixels
  *     if mask_mi is not False:             # <<<<<<<<<<<<<<
  *         mi[mask_mi] = UNSEEN
  *     if polarization:
  */
-  __pyx_t_4 = (__pyx_v_mask_mi != Py_False);
-  __pyx_t_9 = (__pyx_t_4 != 0);
-  if (__pyx_t_9) {
+  __pyx_t_5 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_4 = (__pyx_v_mask_mi != __pyx_t_5);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (__pyx_t_4) {
 
-    /* "healpy/src/_sphtools.pyx":295
+    /* "healpy/src/_sphtools.pyx":256
  *     # restore input map with UNSEEN pixels
  *     if mask_mi is not False:
  *         mi[mask_mi] = UNSEEN             # <<<<<<<<<<<<<<
  *     if polarization:
  *         if mask_mq is not False:
  */
-    __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(PyObject_SetItem(__pyx_v_mi, __pyx_v_mask_mi, __pyx_t_5) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (PyObject_SetItem(((PyObject *)__pyx_v_mi), __pyx_v_mask_mi, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    goto __pyx_L22;
+    goto __pyx_L26;
   }
-  __pyx_L22:;
+  __pyx_L26:;
 
-  /* "healpy/src/_sphtools.pyx":296
+  /* "healpy/src/_sphtools.pyx":257
  *     if mask_mi is not False:
  *         mi[mask_mi] = UNSEEN
  *     if polarization:             # <<<<<<<<<<<<<<
  *         if mask_mq is not False:
  *             mq[mask_mq] = UNSEEN
  */
-  __pyx_t_9 = (__pyx_v_polarization != 0);
-  if (__pyx_t_9) {
+  if (__pyx_v_polarization) {
+    if (unlikely(!__pyx_v_mask_mq)) { __Pyx_RaiseUnboundLocalError("mask_mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_5 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":297
+    /* "healpy/src/_sphtools.pyx":258
  *         mi[mask_mi] = UNSEEN
  *     if polarization:
  *         if mask_mq is not False:             # <<<<<<<<<<<<<<
  *             mq[mask_mq] = UNSEEN
  *         if mask_mu is not False:
  */
-    if (unlikely(!__pyx_v_mask_mq)) { __Pyx_RaiseUnboundLocalError("mask_mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_9 = (__pyx_v_mask_mq != Py_False);
-    __pyx_t_4 = (__pyx_t_9 != 0);
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_4 = (__pyx_v_mask_mq != __pyx_t_5);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     if (__pyx_t_4) {
 
-      /* "healpy/src/_sphtools.pyx":298
+      /* "healpy/src/_sphtools.pyx":259
  *     if polarization:
  *         if mask_mq is not False:
  *             mq[mask_mq] = UNSEEN             # <<<<<<<<<<<<<<
  *         if mask_mu is not False:
  *             mu[mask_mu] = UNSEEN
  */
-      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_5);
-      if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-      if (unlikely(PyObject_SetItem(__pyx_v_mq, __pyx_v_mask_mq, __pyx_t_5) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      if (unlikely(!__pyx_v_mq)) { __Pyx_RaiseUnboundLocalError("mq"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (PyObject_SetItem(((PyObject *)__pyx_v_mq), __pyx_v_mask_mq, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      goto __pyx_L24;
+      goto __pyx_L28;
     }
-    __pyx_L24:;
+    __pyx_L28:;
+    if (unlikely(!__pyx_v_mask_mu)) { __Pyx_RaiseUnboundLocalError("mask_mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_5 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-    /* "healpy/src/_sphtools.pyx":299
+    /* "healpy/src/_sphtools.pyx":260
  *         if mask_mq is not False:
  *             mq[mask_mq] = UNSEEN
  *         if mask_mu is not False:             # <<<<<<<<<<<<<<
  *             mu[mask_mu] = UNSEEN
  * 
  */
-    if (unlikely(!__pyx_v_mask_mu)) { __Pyx_RaiseUnboundLocalError("mask_mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_4 = (__pyx_v_mask_mu != Py_False);
-    __pyx_t_9 = (__pyx_t_4 != 0);
-    if (__pyx_t_9) {
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_4 = (__pyx_v_mask_mu != __pyx_t_5);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (__pyx_t_4) {
 
-      /* "healpy/src/_sphtools.pyx":300
+      /* "healpy/src/_sphtools.pyx":261
  *             mq[mask_mq] = UNSEEN
  *         if mask_mu is not False:
  *             mu[mask_mu] = UNSEEN             # <<<<<<<<<<<<<<
  * 
- *     del w_arr
+ *     if regression:
  */
-      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_6healpy_9_sphtools_UNSEEN); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_5);
-      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-      if (unlikely(PyObject_SetItem(__pyx_v_mu, __pyx_v_mask_mu, __pyx_t_5) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      if (unlikely(!__pyx_v_mu)) { __Pyx_RaiseUnboundLocalError("mu"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (PyObject_SetItem(((PyObject *)__pyx_v_mu), __pyx_v_mask_mu, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      goto __pyx_L25;
+      goto __pyx_L29;
     }
-    __pyx_L25:;
-    goto __pyx_L23;
+    __pyx_L29:;
+    goto __pyx_L27;
   }
-  __pyx_L23:;
+  __pyx_L27:;
 
-  /* "healpy/src/_sphtools.pyx":302
+  /* "healpy/src/_sphtools.pyx":263
  *             mu[mask_mu] = UNSEEN
  * 
- *     del w_arr             # <<<<<<<<<<<<<<
- *     if polarization:
- *         del MI, MQ, MU, AI, AG, AC
+ *     if regression:             # <<<<<<<<<<<<<<
+ *         MI.h.Add(avg)
+ *         almI[0] += avg * sqrt(4 * np.pi)
  */
-  delete __pyx_v_w_arr;
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_regression); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_4) {
 
-  /* "healpy/src/_sphtools.pyx":303
+    /* "healpy/src/_sphtools.pyx":264
+ * 
+ *     if regression:
+ *         MI.h.Add(avg)             # <<<<<<<<<<<<<<
+ *         almI[0] += avg * sqrt(4 * np.pi)
+ * 
+ */
+    __pyx_v_MI->h->Add(__pyx_v_avg);
+
+    /* "healpy/src/_sphtools.pyx":265
+ *     if regression:
+ *         MI.h.Add(avg)
+ *         almI[0] += avg * sqrt(4 * np.pi)             # <<<<<<<<<<<<<<
  * 
  *     del w_arr
- *     if polarization:             # <<<<<<<<<<<<<<
- *         del MI, MQ, MU, AI, AG, AC
+ */
+    __pyx_t_18 = 0;
+    __pyx_t_5 = __Pyx_GetItemInt(((PyObject *)__pyx_v_almI), __pyx_t_18, sizeof(Py_ssize_t), PyInt_FromSsize_t); if (!__pyx_t_5) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__pi); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyNumber_Multiply(__pyx_int_4, __pyx_t_6); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_19 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_19 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyFloat_FromDouble((__pyx_v_avg * sqrt(__pyx_t_19))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = PyNumber_InPlaceAdd(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__Pyx_SetItemInt(((PyObject *)__pyx_v_almI), __pyx_t_18, __pyx_t_6, sizeof(Py_ssize_t), PyInt_FromSsize_t) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    goto __pyx_L30;
+  }
+  __pyx_L30:;
+
+  /* "healpy/src/_sphtools.pyx":267
+ *         almI[0] += avg * sqrt(4 * np.pi)
+ * 
+ *     del w_arr             # <<<<<<<<<<<<<<
+ *     if polarization:
  *         return almI, almG, almC
  */
-  __pyx_t_9 = (__pyx_v_polarization != 0);
-  if (__pyx_t_9) {
+  delete __pyx_v_w_arr;
 
-    /* "healpy/src/_sphtools.pyx":304
+  /* "healpy/src/_sphtools.pyx":268
+ * 
  *     del w_arr
- *     if polarization:
- *         del MI, MQ, MU, AI, AG, AC             # <<<<<<<<<<<<<<
+ *     if polarization:             # <<<<<<<<<<<<<<
  *         return almI, almG, almC
  *     else:
  */
-    delete __pyx_v_MI;
-    delete __pyx_v_MQ;
-    delete __pyx_v_MU;
-    delete __pyx_v_AI;
-    delete __pyx_v_AG;
-    delete __pyx_v_AC;
+  if (__pyx_v_polarization) {
 
-    /* "healpy/src/_sphtools.pyx":305
+    /* "healpy/src/_sphtools.pyx":269
+ *     del w_arr
  *     if polarization:
- *         del MI, MQ, MU, AI, AG, AC
  *         return almI, almG, almC             # <<<<<<<<<<<<<<
  *     else:
- *         del MI, AI
+ *         return almI
  */
     __Pyx_XDECREF(__pyx_r);
-    if (unlikely(!__pyx_v_almG)) { __Pyx_RaiseUnboundLocalError("almG"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    if (unlikely(!__pyx_v_almC)) { __Pyx_RaiseUnboundLocalError("almC"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_INCREF(__pyx_v_almI);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_almI);
-    __Pyx_GIVEREF(__pyx_v_almI);
+    if (unlikely(!__pyx_v_almG)) { __Pyx_RaiseUnboundLocalError("almG"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }if (unlikely(!__pyx_v_almC)) { __Pyx_RaiseUnboundLocalError("almC"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;} }__pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+    __Pyx_INCREF(((PyObject *)__pyx_v_almI));
+    PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_v_almI));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_almI));
     __Pyx_INCREF(__pyx_v_almG);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_almG);
+    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_almG);
     __Pyx_GIVEREF(__pyx_v_almG);
-    __Pyx_INCREF(__pyx_v_almC);
-    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_almC);
-    __Pyx_GIVEREF(__pyx_v_almC);
-    __pyx_r = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __Pyx_INCREF(((PyObject *)__pyx_v_almC));
+    PyTuple_SET_ITEM(__pyx_t_6, 2, ((PyObject *)__pyx_v_almC));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_almC));
+    __pyx_r = ((PyObject *)__pyx_t_6);
+    __pyx_t_6 = 0;
     goto __pyx_L0;
+    goto __pyx_L31;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":307
+    /* "healpy/src/_sphtools.pyx":271
  *         return almI, almG, almC
  *     else:
- *         del MI, AI             # <<<<<<<<<<<<<<
- *         return almI
- * 
- */
-    delete __pyx_v_MI;
-    delete __pyx_v_AI;
-
-    /* "healpy/src/_sphtools.pyx":308
- *     else:
- *         del MI, AI
  *         return almI             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(__pyx_v_almI);
-    __pyx_r = __pyx_v_almI;
+    __Pyx_INCREF(((PyObject *)__pyx_v_almI));
+    __pyx_r = ((PyObject *)__pyx_v_almI);
     goto __pyx_L0;
   }
+  __pyx_L31:;
 
-  /* "healpy/src/_sphtools.pyx":178
- *     return maps
- * 
- * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
- *             datapath = None):
- *     """Computes the alm of a Healpix map.
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mi);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mu);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mq);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.map2alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
+  goto __pyx_L2;
   __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mi);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mu);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mq);
+  __pyx_L2:;
   __Pyx_XDECREF(__pyx_v_info);
-  __Pyx_XDECREF(__pyx_v_mi);
-  __Pyx_XDECREF(__pyx_v_mq);
-  __Pyx_XDECREF(__pyx_v_mu);
+  __Pyx_XDECREF(__pyx_v_mmi);
+  __Pyx_XDECREF(__pyx_v_mmq);
+  __Pyx_XDECREF(__pyx_v_mmu);
+  __Pyx_XDECREF((PyObject *)__pyx_v_mi);
+  __Pyx_XDECREF((PyObject *)__pyx_v_mq);
+  __Pyx_XDECREF((PyObject *)__pyx_v_mu);
   __Pyx_XDECREF(__pyx_v_mask_mi);
   __Pyx_XDECREF(__pyx_v_mask_mq);
   __Pyx_XDECREF(__pyx_v_mask_mu);
-  __Pyx_XDECREF(__pyx_v_almI);
+  __Pyx_XDECREF((PyObject *)__pyx_v_MI);
+  __Pyx_XDECREF((PyObject *)__pyx_v_MQ);
+  __Pyx_XDECREF((PyObject *)__pyx_v_MU);
+  __Pyx_XDECREF((PyObject *)__pyx_v_almI);
+  __Pyx_XDECREF((PyObject *)__pyx_v_almC);
+  __Pyx_XDECREF(__pyx_v_n_alm);
   __Pyx_XDECREF(__pyx_v_almG);
-  __Pyx_XDECREF(__pyx_v_almC);
+  __Pyx_XDECREF((PyObject *)__pyx_v_AI);
+  __Pyx_XDECREF((PyObject *)__pyx_v_AG);
+  __Pyx_XDECREF((PyObject *)__pyx_v_AC);
   __Pyx_XDECREF(__pyx_v_weightfile);
   __Pyx_XDECREF(__pyx_v_datapath);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":311
+/* "healpy/src/_sphtools.pyx":274
  * 
  * 
  * def alm2cl(alms, alms2 = None, lmax = None, mmax = None, lmax_out = None):             # <<<<<<<<<<<<<<
  *     """Computes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between
  *     alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_9alm2cl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_8alm2cl[] = "Computes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between\n    alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,\n    then n(n+1)/2 auto and cross-spectra are returned.\n\n    Parameters\n    ----------\n    alms : complex, array or sequence of arrays\n      The alm from which to compute the power spectrum. If n>=2 arrays are given,\n      computes both auto- and cross-spectra.\n    alms2 : complex, array or sequence of 3 arrays, optional\n      If provided, computes cross-spectra between alm and alm2.\n      Default: alm2=alm, so auto-spectra are computed.\n    lmax : None or int, optional\n      The maximum l of the input alm. Default: computed from size of alm\n      and mmax_in\n    mmax : None or int, optional\n      The maximum m of the input alm. Default: assume mmax_in = lmax_in\n    lmax_out : None or int, optional\n      The maximum l of the returned spectra. By default: the lmax of the given\n      alm(s).\n\n    Returns\n    -------\n    cl : array or tuple of n(n+1)/2 arrays\n      the spectrum <*alm* x *alm2*> if *alm* (and *alm2*) is one alm, or \n      the auto- and cross-spectra <*alm*[i] x *alm2*[j]> if alm (and alm2)\n      contains more than one spectra.\n      If more than one spectrum is returned, they are ordered by diagonal.\n      For example, if *alm* is almT, almE, almB, then the returned spectra are:\n      TT, EE, BB, TE, EB, TB.\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_9alm2cl = {__Pyx_NAMESTR("alm2cl"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_9alm2cl, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_8alm2cl)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_9alm2cl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pf_6healpy_9_sphtools_2alm2cl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_2alm2cl[] = "alm2cl(alms, alms2=None, lmax=None, mmax=None, lmax_out=None)\nComputes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between\n    alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,\n    then n(n+1)/2 auto and cross-spectra are returned.\n\n    Parameters\n    ----------\n    alms : complex, array or sequence of arrays\n      The alm from which to compute the power spectrum. If n>=2 arrays are given,\n      computes both auto- and cross-spectra.\n    alms2 : complex, array or sequence of 3 arrays, optional\n      If provided, computes cross-spectra between alm and alm2.\n      Default: alm2=alm, so auto-spectra are computed.\n    lmax : None or int, optional\n      The maximum l of the input alm. Default: computed from size of alm\n      and mmax_in\n    mmax : None or int, optional\n      The maximum m of the input alm. Default: assume mmax_in = lmax_in\n    lmax_out : None or int, optional\n      The maximum l of the returned spectra. By default: the lmax of the given\n      alm(s).\n\n    Returns\n    -------\n    cl : array or tuple of n(n+1)/2 arrays\n      the spectrum <*alm* x *alm2*> if *alm* (and *alm2*) is one alm, or \n      the auto- and cross-spectra <*alm*[i] x *alm2*[j]> if alm (and alm2)\n      contains more than one spectra.\n      If more than one spectrum is returned, they are ordered by diagonal.\n      For example, if *alm* is almT, almE, almB, then the returned spectra are:\n      TT, EE, BB, TE, EB, TB.\n    ";
+static PyMethodDef __pyx_mdef_6healpy_9_sphtools_2alm2cl = {__Pyx_NAMESTR("alm2cl"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_2alm2cl, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_2alm2cl)};
+static PyObject *__pyx_pf_6healpy_9_sphtools_2alm2cl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_alms = 0;
   PyObject *__pyx_v_alms2 = 0;
   PyObject *__pyx_v_lmax = 0;
   PyObject *__pyx_v_mmax = 0;
   PyObject *__pyx_v_lmax_out = 0;
+  int __pyx_v_Nspec;
+  int __pyx_v_Nspec2;
+  int __pyx_v_alms_lonely;
+  int __pyx_v_almsize;
+  int __pyx_v_i;
+  int __pyx_v_j;
+  int __pyx_v_l;
+  int __pyx_v_m;
+  int __pyx_v_limit;
+  int __pyx_v_lmax_;
+  int __pyx_v_mmax_;
+  int __pyx_v_lmax_out_;
+  PyArrayObject *__pyx_v_powspec_ = 0;
+  PyArrayObject *__pyx_v_alm1_ = 0;
+  PyArrayObject *__pyx_v_alm2_ = 0;
+  PyObject *__pyx_v_spectra = NULL;
+  PyObject *__pyx_v_n = NULL;
+  Py_buffer __pyx_bstruct_alm1_;
+  Py_ssize_t __pyx_bstride_0_alm1_ = 0;
+  Py_ssize_t __pyx_bshape_0_alm1_ = 0;
+  Py_buffer __pyx_bstruct_alm2_;
+  Py_ssize_t __pyx_bstride_0_alm2_ = 0;
+  Py_ssize_t __pyx_bshape_0_alm2_ = 0;
+  Py_buffer __pyx_bstruct_powspec_;
+  Py_ssize_t __pyx_bstride_0_powspec_ = 0;
+  Py_ssize_t __pyx_bshape_0_powspec_ = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_t_9;
+  PyObject *(*__pyx_t_10)(PyObject *);
+  long __pyx_t_11;
+  PyObject *__pyx_t_12 = NULL;
+  PyArrayObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  PyObject *__pyx_t_15 = NULL;
+  PyObject *__pyx_t_16 = NULL;
+  PyArrayObject *__pyx_t_17 = NULL;
+  PyArrayObject *__pyx_t_18 = NULL;
+  long __pyx_t_19;
+  int __pyx_t_20;
+  int __pyx_t_21;
+  int __pyx_t_22;
+  int __pyx_t_23;
+  long __pyx_t_24;
+  int __pyx_t_25;
+  int __pyx_t_26;
+  int __pyx_t_27;
+  int __pyx_t_28;
+  int __pyx_t_29;
+  int __pyx_t_30;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("alm2cl (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__alms,&__pyx_n_s__alms2,&__pyx_n_s__lmax,&__pyx_n_s__mmax,&__pyx_n_s__lmax_out,0};
+  __Pyx_RefNannySetupContext("alm2cl");
+  __pyx_self = __pyx_self;
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alms,&__pyx_n_s_alms2,&__pyx_n_s_lmax,&__pyx_n_s_mmax,&__pyx_n_s_lmax_out,0};
     PyObject* values[5] = {0,0,0,0,0};
     values[1] = ((PyObject *)Py_None);
     values[2] = ((PyObject *)Py_None);
     values[3] = ((PyObject *)Py_None);
     values[4] = ((PyObject *)Py_None);
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_alms)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__alms);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_alms2);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__alms2);
           if (value) { values[1] = value; kw_args--; }
         }
         case  2:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__lmax);
           if (value) { values[2] = value; kw_args--; }
         }
         case  3:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mmax);
           if (value) { values[3] = value; kw_args--; }
         }
         case  4:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax_out);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__lmax_out);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "alm2cl") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "alm2cl") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
@@ -4781,986 +3764,940 @@
     __pyx_v_alms2 = values[1];
     __pyx_v_lmax = values[2];
     __pyx_v_mmax = values[3];
     __pyx_v_lmax_out = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("alm2cl", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("alm2cl", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_AddTraceback("healpy._sphtools.alm2cl", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_8alm2cl(__pyx_self, __pyx_v_alms, __pyx_v_alms2, __pyx_v_lmax, __pyx_v_mmax, __pyx_v_lmax_out);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_8alm2cl(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alms, PyObject *__pyx_v_alms2, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax, PyObject *__pyx_v_lmax_out) {
-  int __pyx_v_Nspec;
-  int __pyx_v_Nspec2;
-  int __pyx_v_alms_lonely;
-  int __pyx_v_almsize;
-  int __pyx_v_i;
-  int __pyx_v_j;
-  int __pyx_v_l;
-  int __pyx_v_m;
-  int __pyx_v_limit;
-  int __pyx_v_lmax_;
-  CYTHON_UNUSED int __pyx_v_mmax_;
-  CYTHON_UNUSED int __pyx_v_lmax_out_;
-  PyArrayObject *__pyx_v_powspec_ = 0;
-  PyArrayObject *__pyx_v_alm1_ = 0;
-  PyArrayObject *__pyx_v_alm2_ = 0;
-  PyObject *__pyx_v_spectra = NULL;
-  PyObject *__pyx_v_n = NULL;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_alm1_;
-  __Pyx_Buffer __pyx_pybuffer_alm1_;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_alm2_;
-  __Pyx_Buffer __pyx_pybuffer_alm2_;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_powspec_;
-  __Pyx_Buffer __pyx_pybuffer_powspec_;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  Py_ssize_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  int __pyx_t_7;
-  PyObject *__pyx_t_8 = NULL;
-  int __pyx_t_9;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *(*__pyx_t_11)(PyObject *);
-  PyObject *(*__pyx_t_12)(PyObject *);
-  long __pyx_t_13;
-  PyArrayObject *__pyx_t_14 = NULL;
-  PyObject *__pyx_t_15 = NULL;
-  PyObject *__pyx_t_16 = NULL;
-  PyObject *__pyx_t_17 = NULL;
-  PyArrayObject *__pyx_t_18 = NULL;
-  PyArrayObject *__pyx_t_19 = NULL;
-  long __pyx_t_20;
-  int __pyx_t_21;
-  int __pyx_t_22;
-  int __pyx_t_23;
-  int __pyx_t_24;
-  int __pyx_t_25;
-  long __pyx_t_26;
-  int __pyx_t_27;
-  int __pyx_t_28;
-  int __pyx_t_29;
-  int __pyx_t_30;
-  int __pyx_t_31;
-  int __pyx_t_32;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("alm2cl", 0);
   __Pyx_INCREF(__pyx_v_alms);
   __Pyx_INCREF(__pyx_v_alms2);
   __Pyx_INCREF(__pyx_v_lmax);
   __Pyx_INCREF(__pyx_v_mmax);
   __Pyx_INCREF(__pyx_v_lmax_out);
-  __pyx_pybuffer_powspec_.pybuffer.buf = NULL;
-  __pyx_pybuffer_powspec_.refcount = 0;
-  __pyx_pybuffernd_powspec_.data = NULL;
-  __pyx_pybuffernd_powspec_.rcbuffer = &__pyx_pybuffer_powspec_;
-  __pyx_pybuffer_alm1_.pybuffer.buf = NULL;
-  __pyx_pybuffer_alm1_.refcount = 0;
-  __pyx_pybuffernd_alm1_.data = NULL;
-  __pyx_pybuffernd_alm1_.rcbuffer = &__pyx_pybuffer_alm1_;
-  __pyx_pybuffer_alm2_.pybuffer.buf = NULL;
-  __pyx_pybuffer_alm2_.refcount = 0;
-  __pyx_pybuffernd_alm2_.data = NULL;
-  __pyx_pybuffernd_alm2_.rcbuffer = &__pyx_pybuffer_alm2_;
+  __pyx_bstruct_powspec_.buf = NULL;
+  __pyx_bstruct_alm1_.buf = NULL;
+  __pyx_bstruct_alm2_.buf = NULL;
 
-  /* "healpy/src/_sphtools.pyx":347
+  /* "healpy/src/_sphtools.pyx":310
  *     #
  *     cdef int Nspec, Nspec2
  *     if not hasattr(alms, '__len__'):             # <<<<<<<<<<<<<<
  *         raise ValueError('alms must be an array or a sequence of arrays')
  *     if not hasattr(alms[0], '__len__'):
  */
-  __pyx_t_1 = PyObject_HasAttr(__pyx_v_alms, __pyx_n_s_len); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
-  if (__pyx_t_2) {
+  __pyx_t_1 = ((PyObject *)__pyx_n_s____len__);
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_HasAttr(__pyx_v_alms, __pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = (!__pyx_t_2);
+  if (__pyx_t_3) {
 
-    /* "healpy/src/_sphtools.pyx":348
+    /* "healpy/src/_sphtools.pyx":311
  *     cdef int Nspec, Nspec2
  *     if not hasattr(alms, '__len__'):
  *         raise ValueError('alms must be an array or a sequence of arrays')             # <<<<<<<<<<<<<<
  *     if not hasattr(alms[0], '__len__'):
  *         alms_lonely = True
  */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_15), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
   }
+  __pyx_L6:;
 
-  /* "healpy/src/_sphtools.pyx":349
+  /* "healpy/src/_sphtools.pyx":312
  *     if not hasattr(alms, '__len__'):
  *         raise ValueError('alms must be an array or a sequence of arrays')
  *     if not hasattr(alms[0], '__len__'):             # <<<<<<<<<<<<<<
  *         alms_lonely = True
  *         alms = [alms]
  */
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_alms, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = PyObject_HasAttr(__pyx_t_3, __pyx_n_s_len); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_1 = ((!(__pyx_t_2 != 0)) != 0);
-  if (__pyx_t_1) {
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_alms, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = ((PyObject *)__pyx_n_s____len__);
+  __Pyx_INCREF(__pyx_t_4);
+  __pyx_t_3 = PyObject_HasAttr(__pyx_t_1, __pyx_t_4); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_2 = (!__pyx_t_3);
+  if (__pyx_t_2) {
 
-    /* "healpy/src/_sphtools.pyx":350
+    /* "healpy/src/_sphtools.pyx":313
  *         raise ValueError('alms must be an array or a sequence of arrays')
  *     if not hasattr(alms[0], '__len__'):
  *         alms_lonely = True             # <<<<<<<<<<<<<<
  *         alms = [alms]
  *     else:
  */
     __pyx_v_alms_lonely = 1;
 
-    /* "healpy/src/_sphtools.pyx":351
+    /* "healpy/src/_sphtools.pyx":314
  *     if not hasattr(alms[0], '__len__'):
  *         alms_lonely = True
  *         alms = [alms]             # <<<<<<<<<<<<<<
  *     else:
  *         alms_lonely = False
  */
-    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 351; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
     __Pyx_INCREF(__pyx_v_alms);
-    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_alms);
+    PyList_SET_ITEM(__pyx_t_4, 0, __pyx_v_alms);
     __Pyx_GIVEREF(__pyx_v_alms);
-    __Pyx_DECREF_SET(__pyx_v_alms, __pyx_t_3);
-    __pyx_t_3 = 0;
-    goto __pyx_L4;
+    __Pyx_DECREF(__pyx_v_alms);
+    __pyx_v_alms = ((PyObject *)__pyx_t_4);
+    __pyx_t_4 = 0;
+    goto __pyx_L7;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":353
+    /* "healpy/src/_sphtools.pyx":316
  *         alms = [alms]
  *     else:
  *         alms_lonely = False             # <<<<<<<<<<<<<<
  * 
  *     Nspec = len(alms)
  */
     __pyx_v_alms_lonely = 0;
   }
-  __pyx_L4:;
+  __pyx_L7:;
 
-  /* "healpy/src/_sphtools.pyx":355
+  /* "healpy/src/_sphtools.pyx":318
  *         alms_lonely = False
  * 
  *     Nspec = len(alms)             # <<<<<<<<<<<<<<
  * 
  *     if alms2 is None:
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_alms); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_Nspec = __pyx_t_4;
+  __pyx_t_5 = PyObject_Length(__pyx_v_alms); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_Nspec = __pyx_t_5;
 
-  /* "healpy/src/_sphtools.pyx":357
+  /* "healpy/src/_sphtools.pyx":320
  *     Nspec = len(alms)
  * 
  *     if alms2 is None:             # <<<<<<<<<<<<<<
  *         alms2 = alms
  * 
  */
-  __pyx_t_1 = (__pyx_v_alms2 == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
+  __pyx_t_2 = (__pyx_v_alms2 == Py_None);
   if (__pyx_t_2) {
 
-    /* "healpy/src/_sphtools.pyx":358
+    /* "healpy/src/_sphtools.pyx":321
  * 
  *     if alms2 is None:
  *         alms2 = alms             # <<<<<<<<<<<<<<
  * 
  *     if not hasattr(alms2, '__len__'):
  */
     __Pyx_INCREF(__pyx_v_alms);
-    __Pyx_DECREF_SET(__pyx_v_alms2, __pyx_v_alms);
-    goto __pyx_L5;
+    __Pyx_DECREF(__pyx_v_alms2);
+    __pyx_v_alms2 = __pyx_v_alms;
+    goto __pyx_L8;
   }
-  __pyx_L5:;
+  __pyx_L8:;
 
-  /* "healpy/src/_sphtools.pyx":360
+  /* "healpy/src/_sphtools.pyx":323
  *         alms2 = alms
  * 
  *     if not hasattr(alms2, '__len__'):             # <<<<<<<<<<<<<<
  *         raise ValueError('alms2 must be an array or a sequence of arrays')
  *     if not hasattr(alms2[0], '__len__'):
  */
-  __pyx_t_2 = PyObject_HasAttr(__pyx_v_alms2, __pyx_n_s_len); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_1 = ((!(__pyx_t_2 != 0)) != 0);
-  if (__pyx_t_1) {
+  __pyx_t_4 = ((PyObject *)__pyx_n_s____len__);
+  __Pyx_INCREF(__pyx_t_4);
+  __pyx_t_2 = PyObject_HasAttr(__pyx_v_alms2, __pyx_t_4); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_3 = (!__pyx_t_2);
+  if (__pyx_t_3) {
 
-    /* "healpy/src/_sphtools.pyx":361
+    /* "healpy/src/_sphtools.pyx":324
  * 
  *     if not hasattr(alms2, '__len__'):
  *         raise ValueError('alms2 must be an array or a sequence of arrays')             # <<<<<<<<<<<<<<
  *     if not hasattr(alms2[0], '__len__'):
  *         alms2 = [alms2]
  */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_17), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L9;
   }
+  __pyx_L9:;
 
-  /* "healpy/src/_sphtools.pyx":362
+  /* "healpy/src/_sphtools.pyx":325
  *     if not hasattr(alms2, '__len__'):
  *         raise ValueError('alms2 must be an array or a sequence of arrays')
  *     if not hasattr(alms2[0], '__len__'):             # <<<<<<<<<<<<<<
  *         alms2 = [alms2]
  *     Nspec2 = len(alms2)
  */
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_alms2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 362; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = PyObject_HasAttr(__pyx_t_3, __pyx_n_s_len); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
+  __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_alms2, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = ((PyObject *)__pyx_n_s____len__);
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_3 = PyObject_HasAttr(__pyx_t_4, __pyx_t_1); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_2 = (!__pyx_t_3);
   if (__pyx_t_2) {
 
-    /* "healpy/src/_sphtools.pyx":363
+    /* "healpy/src/_sphtools.pyx":326
  *         raise ValueError('alms2 must be an array or a sequence of arrays')
  *     if not hasattr(alms2[0], '__len__'):
  *         alms2 = [alms2]             # <<<<<<<<<<<<<<
  *     Nspec2 = len(alms2)
  * 
  */
-    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
     __Pyx_INCREF(__pyx_v_alms2);
-    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_alms2);
+    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_alms2);
     __Pyx_GIVEREF(__pyx_v_alms2);
-    __Pyx_DECREF_SET(__pyx_v_alms2, __pyx_t_3);
-    __pyx_t_3 = 0;
-    goto __pyx_L7;
+    __Pyx_DECREF(__pyx_v_alms2);
+    __pyx_v_alms2 = ((PyObject *)__pyx_t_1);
+    __pyx_t_1 = 0;
+    goto __pyx_L10;
   }
-  __pyx_L7:;
+  __pyx_L10:;
 
-  /* "healpy/src/_sphtools.pyx":364
+  /* "healpy/src/_sphtools.pyx":327
  *     if not hasattr(alms2[0], '__len__'):
  *         alms2 = [alms2]
  *     Nspec2 = len(alms2)             # <<<<<<<<<<<<<<
  * 
  *     if Nspec != Nspec2:
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_alms2); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_Nspec2 = __pyx_t_4;
+  __pyx_t_5 = PyObject_Length(__pyx_v_alms2); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_Nspec2 = __pyx_t_5;
 
-  /* "healpy/src/_sphtools.pyx":366
+  /* "healpy/src/_sphtools.pyx":329
  *     Nspec2 = len(alms2)
  * 
  *     if Nspec != Nspec2:             # <<<<<<<<<<<<<<
  *         raise ValueError('alms and alms2 must have same number of spectra')
  * 
  */
-  __pyx_t_2 = ((__pyx_v_Nspec != __pyx_v_Nspec2) != 0);
+  __pyx_t_2 = (__pyx_v_Nspec != __pyx_v_Nspec2);
   if (__pyx_t_2) {
 
-    /* "healpy/src/_sphtools.pyx":367
+    /* "healpy/src/_sphtools.pyx":330
  * 
  *     if Nspec != Nspec2:
  *         raise ValueError('alms and alms2 must have same number of spectra')             # <<<<<<<<<<<<<<
  * 
  *     ##############################################
  */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_19), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L11;
   }
+  __pyx_L11:;
 
-  /* "healpy/src/_sphtools.pyx":373
+  /* "healpy/src/_sphtools.pyx":336
  *     #
  *     cdef int almsize
  *     almsize = alms[0].size             # <<<<<<<<<<<<<<
  *     for i in xrange(Nspec):
  *         if alms[i].size != almsize or alms2[i].size != almsize:
  */
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_alms, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_size); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_alms, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__size); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_t_4); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_almsize = __pyx_t_6;
 
-  /* "healpy/src/_sphtools.pyx":374
+  /* "healpy/src/_sphtools.pyx":337
  *     cdef int almsize
  *     almsize = alms[0].size
  *     for i in xrange(Nspec):             # <<<<<<<<<<<<<<
  *         if alms[i].size != almsize or alms2[i].size != almsize:
  *             raise ValueError('all alms must have same size')
  */
   __pyx_t_6 = __pyx_v_Nspec;
   for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
     __pyx_v_i = __pyx_t_7;
 
-    /* "healpy/src/_sphtools.pyx":375
+    /* "healpy/src/_sphtools.pyx":338
  *     almsize = alms[0].size
  *     for i in xrange(Nspec):
  *         if alms[i].size != almsize or alms2[i].size != almsize:             # <<<<<<<<<<<<<<
  *             raise ValueError('all alms must have same size')
  * 
  */
-    __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_alms, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_almsize); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_8 = PyObject_RichCompare(__pyx_t_3, __pyx_t_5, Py_NE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_alms, __pyx_v_i, sizeof(int), PyInt_FromLong); if (!__pyx_t_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_1 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = PyInt_FromLong(__pyx_v_almsize); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_8 = PyObject_RichCompare(__pyx_t_1, __pyx_t_4, Py_NE); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     if (!__pyx_t_2) {
-      __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_alms2, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_alms2, __pyx_v_i, sizeof(int), PyInt_FromLong); if (!__pyx_t_8) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_size); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_GetAttr(__pyx_t_8, __pyx_n_s__size); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_almsize); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_8 = PyInt_FromLong(__pyx_v_almsize); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_t_8, Py_NE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_9 = __pyx_t_1;
+      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_9 = __pyx_t_3;
     } else {
       __pyx_t_9 = __pyx_t_2;
     }
     if (__pyx_t_9) {
 
-      /* "healpy/src/_sphtools.pyx":376
+      /* "healpy/src/_sphtools.pyx":339
  *     for i in xrange(Nspec):
  *         if alms[i].size != almsize or alms2[i].size != almsize:
  *             raise ValueError('all alms must have same size')             # <<<<<<<<<<<<<<
  * 
- *     lmax, mmax = alm_getlmmax(alms[0], lmax, mmax)
+ *     if lmax is None:
  */
-      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_21), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L14;
     }
+    __pyx_L14:;
   }
 
-  /* "healpy/src/_sphtools.pyx":378
+  /* "healpy/src/_sphtools.pyx":341
  *             raise ValueError('all alms must have same size')
  * 
- *     lmax, mmax = alm_getlmmax(alms[0], lmax, mmax)             # <<<<<<<<<<<<<<
+ *     if lmax is None:             # <<<<<<<<<<<<<<
+ *         if mmax is None:
+ *             lmax = alm_getlmax(almsize)
+ */
+  __pyx_t_9 = (__pyx_v_lmax == Py_None);
+  if (__pyx_t_9) {
+
+    /* "healpy/src/_sphtools.pyx":342
  * 
- *     if lmax_out is None:
+ *     if lmax is None:
+ *         if mmax is None:             # <<<<<<<<<<<<<<
+ *             lmax = alm_getlmax(almsize)
+ *             mmax = lmax
  */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_alm_getlmmax); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_alms, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_8);
-  __Pyx_INCREF(__pyx_v_lmax);
-  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_lmax);
-  __Pyx_GIVEREF(__pyx_v_lmax);
-  __Pyx_INCREF(__pyx_v_mmax);
-  PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_mmax);
-  __Pyx_GIVEREF(__pyx_v_mmax);
-  __pyx_t_8 = 0;
-  __pyx_t_8 = PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if ((likely(PyTuple_CheckExact(__pyx_t_8))) || (PyList_CheckExact(__pyx_t_8))) {
-    PyObject* sequence = __pyx_t_8;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    Py_ssize_t size = Py_SIZE(sequence);
-    #else
-    Py_ssize_t size = PySequence_Size(sequence);
-    #endif
-    if (unlikely(size != 2)) {
-      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    #if CYTHON_COMPILING_IN_CPYTHON
-    if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_5 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    } else {
-      __pyx_t_5 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
+    __pyx_t_9 = (__pyx_v_mmax == Py_None);
+    if (__pyx_t_9) {
+
+      /* "healpy/src/_sphtools.pyx":343
+ *     if lmax is None:
+ *         if mmax is None:
+ *             lmax = alm_getlmax(almsize)             # <<<<<<<<<<<<<<
+ *             mmax = lmax
+ *         else:
+ */
+      __pyx_t_1 = PyInt_FromLong(__pyx_f_6healpy_9_sphtools_alm_getlmax(__pyx_v_almsize)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_v_lmax);
+      __pyx_v_lmax = __pyx_t_1;
+      __pyx_t_1 = 0;
+
+      /* "healpy/src/_sphtools.pyx":344
+ *         if mmax is None:
+ *             lmax = alm_getlmax(almsize)
+ *             mmax = lmax             # <<<<<<<<<<<<<<
+ *         else:
+ *             lmax = alm_getlmax2(almsize, mmax)
+ */
+      __Pyx_INCREF(__pyx_v_lmax);
+      __Pyx_DECREF(__pyx_v_mmax);
+      __pyx_v_mmax = __pyx_v_lmax;
+      goto __pyx_L16;
     }
-    __Pyx_INCREF(__pyx_t_5);
-    __Pyx_INCREF(__pyx_t_3);
-    #else
-    __pyx_t_5 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  } else {
-    Py_ssize_t index = -1;
-    __pyx_t_10 = PyObject_GetIter(__pyx_t_8); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_10);
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext;
-    index = 0; __pyx_t_5 = __pyx_t_11(__pyx_t_10); if (unlikely(!__pyx_t_5)) goto __pyx_L12_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_5);
-    index = 1; __pyx_t_3 = __pyx_t_11(__pyx_t_10); if (unlikely(!__pyx_t_3)) goto __pyx_L12_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_11 = NULL;
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    goto __pyx_L13_unpacking_done;
-    __pyx_L12_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __pyx_t_11 = NULL;
-    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_L13_unpacking_done:;
+    /*else*/ {
+
+      /* "healpy/src/_sphtools.pyx":346
+ *             mmax = lmax
+ *         else:
+ *             lmax = alm_getlmax2(almsize, mmax)             # <<<<<<<<<<<<<<
+ * 
+ *     if mmax is None:
+ */
+      __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_v_mmax); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = PyInt_FromLong(__pyx_f_6healpy_9_sphtools_alm_getlmax2(__pyx_v_almsize, __pyx_t_6)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_v_lmax);
+      __pyx_v_lmax = __pyx_t_1;
+      __pyx_t_1 = 0;
+    }
+    __pyx_L16:;
+    goto __pyx_L15;
   }
-  __Pyx_DECREF_SET(__pyx_v_lmax, __pyx_t_5);
-  __pyx_t_5 = 0;
-  __Pyx_DECREF_SET(__pyx_v_mmax, __pyx_t_3);
-  __pyx_t_3 = 0;
+  __pyx_L15:;
+
+  /* "healpy/src/_sphtools.pyx":348
+ *             lmax = alm_getlmax2(almsize, mmax)
+ * 
+ *     if mmax is None:             # <<<<<<<<<<<<<<
+ *         mmax = lmax
+ * 
+ */
+  __pyx_t_9 = (__pyx_v_mmax == Py_None);
+  if (__pyx_t_9) {
+
+    /* "healpy/src/_sphtools.pyx":349
+ * 
+ *     if mmax is None:
+ *         mmax = lmax             # <<<<<<<<<<<<<<
+ * 
+ *     if lmax_out is None:
+ */
+    __Pyx_INCREF(__pyx_v_lmax);
+    __Pyx_DECREF(__pyx_v_mmax);
+    __pyx_v_mmax = __pyx_v_lmax;
+    goto __pyx_L17;
+  }
+  __pyx_L17:;
 
-  /* "healpy/src/_sphtools.pyx":380
- *     lmax, mmax = alm_getlmmax(alms[0], lmax, mmax)
+  /* "healpy/src/_sphtools.pyx":351
+ *         mmax = lmax
  * 
  *     if lmax_out is None:             # <<<<<<<<<<<<<<
  *         lmax_out = lmax
  * 
  */
   __pyx_t_9 = (__pyx_v_lmax_out == Py_None);
-  __pyx_t_2 = (__pyx_t_9 != 0);
-  if (__pyx_t_2) {
+  if (__pyx_t_9) {
 
-    /* "healpy/src/_sphtools.pyx":381
+    /* "healpy/src/_sphtools.pyx":352
  * 
  *     if lmax_out is None:
  *         lmax_out = lmax             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_INCREF(__pyx_v_lmax);
-    __Pyx_DECREF_SET(__pyx_v_lmax_out, __pyx_v_lmax);
-    goto __pyx_L14;
+    __Pyx_DECREF(__pyx_v_lmax_out);
+    __pyx_v_lmax_out = __pyx_v_lmax;
+    goto __pyx_L18;
   }
-  __pyx_L14:;
+  __pyx_L18:;
 
-  /* "healpy/src/_sphtools.pyx":388
+  /* "healpy/src/_sphtools.pyx":359
  *     #
  *     cdef int j, l, m, limit
  *     cdef int lmax_ = lmax, mmax_ = mmax             # <<<<<<<<<<<<<<
  *     cdef int lmax_out_ = lmax_out
  * 
  */
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_v_lmax); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_v_lmax_ = __pyx_t_6;
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_v_mmax); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_v_mmax_ = __pyx_t_6;
 
-  /* "healpy/src/_sphtools.pyx":389
+  /* "healpy/src/_sphtools.pyx":360
  *     cdef int j, l, m, limit
  *     cdef int lmax_ = lmax, mmax_ = mmax
  *     cdef int lmax_out_ = lmax_out             # <<<<<<<<<<<<<<
  * 
  *     cdef np.ndarray[double, ndim=1] powspec_
  */
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_v_lmax_out); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 389; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_v_lmax_out); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_v_lmax_out_ = __pyx_t_6;
 
-  /* "healpy/src/_sphtools.pyx":395
+  /* "healpy/src/_sphtools.pyx":366
  *     cdef np.ndarray[np.complex128_t, ndim=1] alm2_
  * 
  *     spectra = []             # <<<<<<<<<<<<<<
  *     for n in xrange(Nspec): # diagonal rank
  *         for m in xrange(0, Nspec - n): # position in the diagonal
  */
-  __pyx_t_8 = PyList_New(0); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_v_spectra = __pyx_t_8;
-  __pyx_t_8 = 0;
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __pyx_v_spectra = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":396
+  /* "healpy/src/_sphtools.pyx":367
  * 
  *     spectra = []
  *     for n in xrange(Nspec): # diagonal rank             # <<<<<<<<<<<<<<
  *         for m in xrange(0, Nspec - n): # position in the diagonal
  *             powspec_ = np.zeros(lmax + 1)
  */
-  __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_Nspec); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_8);
-  __pyx_t_8 = 0;
-  __pyx_t_8 = PyObject_Call(__pyx_builtin_xrange, __pyx_t_3, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyList_CheckExact(__pyx_t_8) || PyTuple_CheckExact(__pyx_t_8)) {
-    __pyx_t_3 = __pyx_t_8; __Pyx_INCREF(__pyx_t_3); __pyx_t_4 = 0;
-    __pyx_t_12 = NULL;
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_Nspec); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_8));
+  PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_Call(__pyx_builtin_xrange, ((PyObject *)__pyx_t_8), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_8)); __pyx_t_8 = 0;
+  if (PyList_CheckExact(__pyx_t_1) || PyTuple_CheckExact(__pyx_t_1)) {
+    __pyx_t_8 = __pyx_t_1; __Pyx_INCREF(__pyx_t_8); __pyx_t_5 = 0;
+    __pyx_t_10 = NULL;
   } else {
-    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_8); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_12 = Py_TYPE(__pyx_t_3)->tp_iternext;
+    __pyx_t_5 = -1; __pyx_t_8 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_10 = Py_TYPE(__pyx_t_8)->tp_iternext;
   }
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   for (;;) {
-    if (!__pyx_t_12 && PyList_CheckExact(__pyx_t_3)) {
-      if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_8 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_8); __pyx_t_4++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_8 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
-    } else if (!__pyx_t_12 && PyTuple_CheckExact(__pyx_t_3)) {
-      if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_8); __pyx_t_4++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #else
-      __pyx_t_8 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      #endif
+    if (PyList_CheckExact(__pyx_t_8)) {
+      if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_8)) break;
+      __pyx_t_1 = PyList_GET_ITEM(__pyx_t_8, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
+    } else if (PyTuple_CheckExact(__pyx_t_8)) {
+      if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_8)) break;
+      __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_8, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
     } else {
-      __pyx_t_8 = __pyx_t_12(__pyx_t_3);
-      if (unlikely(!__pyx_t_8)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = __pyx_t_10(__pyx_t_8);
+      if (unlikely(!__pyx_t_1)) {
+        if (PyErr_Occurred()) {
+          if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) PyErr_Clear();
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
         break;
       }
-      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GOTREF(__pyx_t_1);
     }
-    __Pyx_XDECREF_SET(__pyx_v_n, __pyx_t_8);
-    __pyx_t_8 = 0;
+    __Pyx_XDECREF(__pyx_v_n);
+    __pyx_v_n = __pyx_t_1;
+    __pyx_t_1 = 0;
 
-    /* "healpy/src/_sphtools.pyx":397
+    /* "healpy/src/_sphtools.pyx":368
  *     spectra = []
  *     for n in xrange(Nspec): # diagonal rank
  *         for m in xrange(0, Nspec - n): # position in the diagonal             # <<<<<<<<<<<<<<
  *             powspec_ = np.zeros(lmax + 1)
  *             alm1_ = alms[m]
  */
-    __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_Nspec); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_5 = PyNumber_Subtract(__pyx_t_8, __pyx_v_n); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_13 = __Pyx_PyInt_As_long(__pyx_t_5); if (unlikely((__pyx_t_13 == (long)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_13; __pyx_t_6+=1) {
+    __pyx_t_1 = PyInt_FromLong(__pyx_v_Nspec); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_4 = PyNumber_Subtract(__pyx_t_1, __pyx_v_n); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_11 = __Pyx_PyInt_AsLong(__pyx_t_4); if (unlikely((__pyx_t_11 == (long)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_11; __pyx_t_6+=1) {
       __pyx_v_m = __pyx_t_6;
 
-      /* "healpy/src/_sphtools.pyx":398
+      /* "healpy/src/_sphtools.pyx":369
  *     for n in xrange(Nspec): # diagonal rank
  *         for m in xrange(0, Nspec - n): # position in the diagonal
  *             powspec_ = np.zeros(lmax + 1)             # <<<<<<<<<<<<<<
  *             alm1_ = alms[m]
  *             alm2_ = alms2[m + n]
  */
-      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_zeros); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PyNumber_Add(__pyx_v_lmax, __pyx_int_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_10 = PyTuple_New(1); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_10);
-      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_5);
-      __pyx_t_5 = 0;
-      __pyx_t_5 = PyObject_Call(__pyx_t_8, __pyx_t_10, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_14 = ((PyArrayObject *)__pyx_t_5);
+      __pyx_t_4 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_1 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__zeros); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = PyNumber_Add(__pyx_v_lmax, __pyx_int_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_12 = PyTuple_New(1); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_12));
+      PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_12), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_12)); __pyx_t_12 = 0;
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_13 = ((PyArrayObject *)__pyx_t_4);
       {
         __Pyx_BufFmt_StackElem __pyx_stack[1];
-        __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_powspec_.rcbuffer->pybuffer);
-        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_powspec_.rcbuffer->pybuffer, (PyObject*)__pyx_t_14, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
+        __Pyx_SafeReleaseBuffer(&__pyx_bstruct_powspec_);
+        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_powspec_, (PyObject*)__pyx_t_13, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
         if (unlikely(__pyx_t_7 < 0)) {
-          PyErr_Fetch(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
-          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_powspec_.rcbuffer->pybuffer, (PyObject*)__pyx_v_powspec_, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
-            Py_XDECREF(__pyx_t_15); Py_XDECREF(__pyx_t_16); Py_XDECREF(__pyx_t_17);
+          PyErr_Fetch(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
+          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_powspec_, (PyObject*)__pyx_v_powspec_, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+            Py_XDECREF(__pyx_t_14); Py_XDECREF(__pyx_t_15); Py_XDECREF(__pyx_t_16);
             __Pyx_RaiseBufferFallbackError();
           } else {
-            PyErr_Restore(__pyx_t_15, __pyx_t_16, __pyx_t_17);
+            PyErr_Restore(__pyx_t_14, __pyx_t_15, __pyx_t_16);
           }
         }
-        __pyx_pybuffernd_powspec_.diminfo[0].strides = __pyx_pybuffernd_powspec_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_powspec_.diminfo[0].shape = __pyx_pybuffernd_powspec_.rcbuffer->pybuffer.shape[0];
-        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      }
-      __pyx_t_14 = 0;
-      __Pyx_XDECREF_SET(__pyx_v_powspec_, ((PyArrayObject *)__pyx_t_5));
-      __pyx_t_5 = 0;
+        __pyx_bstride_0_powspec_ = __pyx_bstruct_powspec_.strides[0];
+        __pyx_bshape_0_powspec_ = __pyx_bstruct_powspec_.shape[0];
+        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      __pyx_t_13 = 0;
+      __Pyx_XDECREF(((PyObject *)__pyx_v_powspec_));
+      __pyx_v_powspec_ = ((PyArrayObject *)__pyx_t_4);
+      __pyx_t_4 = 0;
 
-      /* "healpy/src/_sphtools.pyx":399
+      /* "healpy/src/_sphtools.pyx":370
  *         for m in xrange(0, Nspec - n): # position in the diagonal
  *             powspec_ = np.zeros(lmax + 1)
  *             alm1_ = alms[m]             # <<<<<<<<<<<<<<
  *             alm2_ = alms2[m + n]
  *             # compute cross-spectrum alm1[n] x alm2[n+m]
  */
-      __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_alms, __pyx_v_m, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-      __Pyx_GOTREF(__pyx_t_5);
-      if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_18 = ((PyArrayObject *)__pyx_t_5);
+      __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_alms, __pyx_v_m, sizeof(int), PyInt_FromLong); if (!__pyx_t_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_17 = ((PyArrayObject *)__pyx_t_4);
       {
         __Pyx_BufFmt_StackElem __pyx_stack[1];
-        __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm1_.rcbuffer->pybuffer);
-        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm1_.rcbuffer->pybuffer, (PyObject*)__pyx_t_18, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+        __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm1_);
+        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_alm1_, (PyObject*)__pyx_t_17, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
         if (unlikely(__pyx_t_7 < 0)) {
-          PyErr_Fetch(&__pyx_t_17, &__pyx_t_16, &__pyx_t_15);
-          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm1_.rcbuffer->pybuffer, (PyObject*)__pyx_v_alm1_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-            Py_XDECREF(__pyx_t_17); Py_XDECREF(__pyx_t_16); Py_XDECREF(__pyx_t_15);
+          PyErr_Fetch(&__pyx_t_16, &__pyx_t_15, &__pyx_t_14);
+          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_alm1_, (PyObject*)__pyx_v_alm1_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+            Py_XDECREF(__pyx_t_16); Py_XDECREF(__pyx_t_15); Py_XDECREF(__pyx_t_14);
             __Pyx_RaiseBufferFallbackError();
           } else {
-            PyErr_Restore(__pyx_t_17, __pyx_t_16, __pyx_t_15);
+            PyErr_Restore(__pyx_t_16, __pyx_t_15, __pyx_t_14);
           }
         }
-        __pyx_pybuffernd_alm1_.diminfo[0].strides = __pyx_pybuffernd_alm1_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_alm1_.diminfo[0].shape = __pyx_pybuffernd_alm1_.rcbuffer->pybuffer.shape[0];
-        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      }
-      __pyx_t_18 = 0;
-      __Pyx_XDECREF_SET(__pyx_v_alm1_, ((PyArrayObject *)__pyx_t_5));
-      __pyx_t_5 = 0;
+        __pyx_bstride_0_alm1_ = __pyx_bstruct_alm1_.strides[0];
+        __pyx_bshape_0_alm1_ = __pyx_bstruct_alm1_.shape[0];
+        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      __pyx_t_17 = 0;
+      __Pyx_XDECREF(((PyObject *)__pyx_v_alm1_));
+      __pyx_v_alm1_ = ((PyArrayObject *)__pyx_t_4);
+      __pyx_t_4 = 0;
 
-      /* "healpy/src/_sphtools.pyx":400
+      /* "healpy/src/_sphtools.pyx":371
  *             powspec_ = np.zeros(lmax + 1)
  *             alm1_ = alms[m]
  *             alm2_ = alms2[m + n]             # <<<<<<<<<<<<<<
  *             # compute cross-spectrum alm1[n] x alm2[n+m]
  *             # and place result in result list
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_m); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_10 = PyNumber_Add(__pyx_t_5, __pyx_v_n); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PyObject_GetItem(__pyx_v_alms2, __pyx_t_10); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_19 = ((PyArrayObject *)__pyx_t_5);
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_m); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_12 = PyNumber_Add(__pyx_t_4, __pyx_v_n); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_12);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_GetItem(__pyx_v_alms2, __pyx_t_12); if (!__pyx_t_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_18 = ((PyArrayObject *)__pyx_t_4);
       {
         __Pyx_BufFmt_StackElem __pyx_stack[1];
-        __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm2_.rcbuffer->pybuffer);
-        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm2_.rcbuffer->pybuffer, (PyObject*)__pyx_t_19, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+        __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm2_);
+        __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_alm2_, (PyObject*)__pyx_t_18, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
         if (unlikely(__pyx_t_7 < 0)) {
-          PyErr_Fetch(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
-          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm2_.rcbuffer->pybuffer, (PyObject*)__pyx_v_alm2_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-            Py_XDECREF(__pyx_t_15); Py_XDECREF(__pyx_t_16); Py_XDECREF(__pyx_t_17);
+          PyErr_Fetch(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
+          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_alm2_, (PyObject*)__pyx_v_alm2_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+            Py_XDECREF(__pyx_t_14); Py_XDECREF(__pyx_t_15); Py_XDECREF(__pyx_t_16);
             __Pyx_RaiseBufferFallbackError();
           } else {
-            PyErr_Restore(__pyx_t_15, __pyx_t_16, __pyx_t_17);
+            PyErr_Restore(__pyx_t_14, __pyx_t_15, __pyx_t_16);
           }
         }
-        __pyx_pybuffernd_alm2_.diminfo[0].strides = __pyx_pybuffernd_alm2_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_alm2_.diminfo[0].shape = __pyx_pybuffernd_alm2_.rcbuffer->pybuffer.shape[0];
-        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_bstride_0_alm2_ = __pyx_bstruct_alm2_.strides[0];
+        __pyx_bshape_0_alm2_ = __pyx_bstruct_alm2_.shape[0];
+        if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
-      __pyx_t_19 = 0;
-      __Pyx_XDECREF_SET(__pyx_v_alm2_, ((PyArrayObject *)__pyx_t_5));
-      __pyx_t_5 = 0;
+      __pyx_t_18 = 0;
+      __Pyx_XDECREF(((PyObject *)__pyx_v_alm2_));
+      __pyx_v_alm2_ = ((PyArrayObject *)__pyx_t_4);
+      __pyx_t_4 = 0;
 
-      /* "healpy/src/_sphtools.pyx":403
+      /* "healpy/src/_sphtools.pyx":374
  *             # compute cross-spectrum alm1[n] x alm2[n+m]
  *             # and place result in result list
  *             for l in range(lmax_ + 1):             # <<<<<<<<<<<<<<
  *                 j = alm_getidx(lmax_, l, 0)
  *                 powspec_[l] = alm1_[j].real * alm2_[j].real
  */
-      __pyx_t_20 = (__pyx_v_lmax_ + 1);
-      for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_20; __pyx_t_7+=1) {
+      __pyx_t_19 = (__pyx_v_lmax_ + 1);
+      for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_19; __pyx_t_7+=1) {
         __pyx_v_l = __pyx_t_7;
 
-        /* "healpy/src/_sphtools.pyx":404
+        /* "healpy/src/_sphtools.pyx":375
  *             # and place result in result list
  *             for l in range(lmax_ + 1):
  *                 j = alm_getidx(lmax_, l, 0)             # <<<<<<<<<<<<<<
  *                 powspec_[l] = alm1_[j].real * alm2_[j].real
  *                 limit = l if l <= mmax else mmax
  */
         __pyx_v_j = __pyx_f_6healpy_9_sphtools_alm_getidx(__pyx_v_lmax_, __pyx_v_l, 0);
 
-        /* "healpy/src/_sphtools.pyx":405
+        /* "healpy/src/_sphtools.pyx":376
  *             for l in range(lmax_ + 1):
  *                 j = alm_getidx(lmax_, l, 0)
  *                 powspec_[l] = alm1_[j].real * alm2_[j].real             # <<<<<<<<<<<<<<
  *                 limit = l if l <= mmax else mmax
  *                 for m in range(1, limit + 1):
  */
+        __pyx_t_20 = __pyx_v_j;
+        __pyx_t_21 = -1;
+        if (__pyx_t_20 < 0) {
+          __pyx_t_20 += __pyx_bshape_0_alm1_;
+          if (unlikely(__pyx_t_20 < 0)) __pyx_t_21 = 0;
+        } else if (unlikely(__pyx_t_20 >= __pyx_bshape_0_alm1_)) __pyx_t_21 = 0;
+        if (unlikely(__pyx_t_21 != -1)) {
+          __Pyx_RaiseBufferIndexError(__pyx_t_21);
+          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        }
         __pyx_t_21 = __pyx_v_j;
         __pyx_t_22 = -1;
         if (__pyx_t_21 < 0) {
-          __pyx_t_21 += __pyx_pybuffernd_alm1_.diminfo[0].shape;
+          __pyx_t_21 += __pyx_bshape_0_alm2_;
           if (unlikely(__pyx_t_21 < 0)) __pyx_t_22 = 0;
-        } else if (unlikely(__pyx_t_21 >= __pyx_pybuffernd_alm1_.diminfo[0].shape)) __pyx_t_22 = 0;
+        } else if (unlikely(__pyx_t_21 >= __pyx_bshape_0_alm2_)) __pyx_t_22 = 0;
         if (unlikely(__pyx_t_22 != -1)) {
           __Pyx_RaiseBufferIndexError(__pyx_t_22);
-          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
-        __pyx_t_22 = __pyx_v_j;
+        __pyx_t_22 = __pyx_v_l;
         __pyx_t_23 = -1;
         if (__pyx_t_22 < 0) {
-          __pyx_t_22 += __pyx_pybuffernd_alm2_.diminfo[0].shape;
+          __pyx_t_22 += __pyx_bshape_0_powspec_;
           if (unlikely(__pyx_t_22 < 0)) __pyx_t_23 = 0;
-        } else if (unlikely(__pyx_t_22 >= __pyx_pybuffernd_alm2_.diminfo[0].shape)) __pyx_t_23 = 0;
+        } else if (unlikely(__pyx_t_22 >= __pyx_bshape_0_powspec_)) __pyx_t_23 = 0;
         if (unlikely(__pyx_t_23 != -1)) {
           __Pyx_RaiseBufferIndexError(__pyx_t_23);
-          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        }
-        __pyx_t_23 = __pyx_v_l;
-        __pyx_t_24 = -1;
-        if (__pyx_t_23 < 0) {
-          __pyx_t_23 += __pyx_pybuffernd_powspec_.diminfo[0].shape;
-          if (unlikely(__pyx_t_23 < 0)) __pyx_t_24 = 0;
-        } else if (unlikely(__pyx_t_23 >= __pyx_pybuffernd_powspec_.diminfo[0].shape)) __pyx_t_24 = 0;
-        if (unlikely(__pyx_t_24 != -1)) {
-          __Pyx_RaiseBufferIndexError(__pyx_t_24);
-          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
-        *__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_powspec_.rcbuffer->pybuffer.buf, __pyx_t_23, __pyx_pybuffernd_powspec_.diminfo[0].strides) = (__Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm1_.rcbuffer->pybuffer.buf, __pyx_t_21, __pyx_pybuffernd_alm1_.diminfo[0].strides))) * __Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm2_.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_alm2_.diminfo[0].strides))));
+        *__Pyx_BufPtrStrided1d(double *, __pyx_bstruct_powspec_.buf, __pyx_t_22, __pyx_bstride_0_powspec_) = (__Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm1_.buf, __pyx_t_20, __pyx_bstride_0_alm1_))) * __Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm2_.buf, __pyx_t_21, __pyx_bstride_0_alm2_))));
 
-        /* "healpy/src/_sphtools.pyx":406
+        /* "healpy/src/_sphtools.pyx":377
  *                 j = alm_getidx(lmax_, l, 0)
  *                 powspec_[l] = alm1_[j].real * alm2_[j].real
  *                 limit = l if l <= mmax else mmax             # <<<<<<<<<<<<<<
  *                 for m in range(1, limit + 1):
  *                     j = alm_getidx(lmax_, l, m)
  */
-        __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_l); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_10 = PyObject_RichCompare(__pyx_t_5, __pyx_v_mmax, Py_LE); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        if (__pyx_t_2) {
-          __pyx_t_24 = __pyx_v_l;
+        __pyx_t_12 = PyInt_FromLong(__pyx_v_l); if (unlikely(!__pyx_t_12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_12);
+        __pyx_t_1 = PyObject_RichCompare(__pyx_t_12, __pyx_v_mmax, Py_LE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+        __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_9 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (__pyx_t_9) {
+          __pyx_t_1 = PyInt_FromLong(__pyx_v_l); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __Pyx_GOTREF(__pyx_t_1);
+          __pyx_t_4 = __pyx_t_1;
+          __pyx_t_1 = 0;
         } else {
-          __pyx_t_25 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_25 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-          __pyx_t_24 = __pyx_t_25;
+          __Pyx_INCREF(__pyx_v_mmax);
+          __pyx_t_4 = __pyx_v_mmax;
         }
-        __pyx_v_limit = __pyx_t_24;
+        __pyx_t_23 = __Pyx_PyInt_AsInt(__pyx_t_4); if (unlikely((__pyx_t_23 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_v_limit = __pyx_t_23;
 
-        /* "healpy/src/_sphtools.pyx":407
+        /* "healpy/src/_sphtools.pyx":378
  *                 powspec_[l] = alm1_[j].real * alm2_[j].real
  *                 limit = l if l <= mmax else mmax
  *                 for m in range(1, limit + 1):             # <<<<<<<<<<<<<<
  *                     j = alm_getidx(lmax_, l, m)
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +
  */
-        __pyx_t_26 = (__pyx_v_limit + 1);
-        for (__pyx_t_24 = 1; __pyx_t_24 < __pyx_t_26; __pyx_t_24+=1) {
-          __pyx_v_m = __pyx_t_24;
+        __pyx_t_24 = (__pyx_v_limit + 1);
+        for (__pyx_t_23 = 1; __pyx_t_23 < __pyx_t_24; __pyx_t_23+=1) {
+          __pyx_v_m = __pyx_t_23;
 
-          /* "healpy/src/_sphtools.pyx":408
+          /* "healpy/src/_sphtools.pyx":379
  *                 limit = l if l <= mmax else mmax
  *                 for m in range(1, limit + 1):
  *                     j = alm_getidx(lmax_, l, m)             # <<<<<<<<<<<<<<
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +
  *                                         alm1_[j].imag * alm2_[j].imag)
  */
           __pyx_v_j = __pyx_f_6healpy_9_sphtools_alm_getidx(__pyx_v_lmax_, __pyx_v_l, __pyx_v_m);
 
-          /* "healpy/src/_sphtools.pyx":409
+          /* "healpy/src/_sphtools.pyx":380
  *                 for m in range(1, limit + 1):
  *                     j = alm_getidx(lmax_, l, m)
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +             # <<<<<<<<<<<<<<
  *                                         alm1_[j].imag * alm2_[j].imag)
  *                 powspec_[l] /= (2 * l + 1)
  */
           __pyx_t_25 = __pyx_v_j;
-          __pyx_t_27 = -1;
+          __pyx_t_26 = -1;
           if (__pyx_t_25 < 0) {
-            __pyx_t_25 += __pyx_pybuffernd_alm1_.diminfo[0].shape;
-            if (unlikely(__pyx_t_25 < 0)) __pyx_t_27 = 0;
-          } else if (unlikely(__pyx_t_25 >= __pyx_pybuffernd_alm1_.diminfo[0].shape)) __pyx_t_27 = 0;
+            __pyx_t_25 += __pyx_bshape_0_alm1_;
+            if (unlikely(__pyx_t_25 < 0)) __pyx_t_26 = 0;
+          } else if (unlikely(__pyx_t_25 >= __pyx_bshape_0_alm1_)) __pyx_t_26 = 0;
+          if (unlikely(__pyx_t_26 != -1)) {
+            __Pyx_RaiseBufferIndexError(__pyx_t_26);
+            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          }
+          __pyx_t_26 = __pyx_v_j;
+          __pyx_t_27 = -1;
+          if (__pyx_t_26 < 0) {
+            __pyx_t_26 += __pyx_bshape_0_alm2_;
+            if (unlikely(__pyx_t_26 < 0)) __pyx_t_27 = 0;
+          } else if (unlikely(__pyx_t_26 >= __pyx_bshape_0_alm2_)) __pyx_t_27 = 0;
           if (unlikely(__pyx_t_27 != -1)) {
             __Pyx_RaiseBufferIndexError(__pyx_t_27);
-            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-          }
-          __pyx_t_27 = __pyx_v_j;
-          __pyx_t_28 = -1;
-          if (__pyx_t_27 < 0) {
-            __pyx_t_27 += __pyx_pybuffernd_alm2_.diminfo[0].shape;
-            if (unlikely(__pyx_t_27 < 0)) __pyx_t_28 = 0;
-          } else if (unlikely(__pyx_t_27 >= __pyx_pybuffernd_alm2_.diminfo[0].shape)) __pyx_t_28 = 0;
-          if (unlikely(__pyx_t_28 != -1)) {
-            __Pyx_RaiseBufferIndexError(__pyx_t_28);
-            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
           }
 
-          /* "healpy/src/_sphtools.pyx":410
+          /* "healpy/src/_sphtools.pyx":381
  *                     j = alm_getidx(lmax_, l, m)
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +
  *                                         alm1_[j].imag * alm2_[j].imag)             # <<<<<<<<<<<<<<
  *                 powspec_[l] /= (2 * l + 1)
  *             spectra.append(powspec_)
  */
+          __pyx_t_27 = __pyx_v_j;
+          __pyx_t_28 = -1;
+          if (__pyx_t_27 < 0) {
+            __pyx_t_27 += __pyx_bshape_0_alm1_;
+            if (unlikely(__pyx_t_27 < 0)) __pyx_t_28 = 0;
+          } else if (unlikely(__pyx_t_27 >= __pyx_bshape_0_alm1_)) __pyx_t_28 = 0;
+          if (unlikely(__pyx_t_28 != -1)) {
+            __Pyx_RaiseBufferIndexError(__pyx_t_28);
+            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          }
           __pyx_t_28 = __pyx_v_j;
           __pyx_t_29 = -1;
           if (__pyx_t_28 < 0) {
-            __pyx_t_28 += __pyx_pybuffernd_alm1_.diminfo[0].shape;
+            __pyx_t_28 += __pyx_bshape_0_alm2_;
             if (unlikely(__pyx_t_28 < 0)) __pyx_t_29 = 0;
-          } else if (unlikely(__pyx_t_28 >= __pyx_pybuffernd_alm1_.diminfo[0].shape)) __pyx_t_29 = 0;
+          } else if (unlikely(__pyx_t_28 >= __pyx_bshape_0_alm2_)) __pyx_t_29 = 0;
           if (unlikely(__pyx_t_29 != -1)) {
             __Pyx_RaiseBufferIndexError(__pyx_t_29);
-            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-          }
-          __pyx_t_29 = __pyx_v_j;
-          __pyx_t_30 = -1;
-          if (__pyx_t_29 < 0) {
-            __pyx_t_29 += __pyx_pybuffernd_alm2_.diminfo[0].shape;
-            if (unlikely(__pyx_t_29 < 0)) __pyx_t_30 = 0;
-          } else if (unlikely(__pyx_t_29 >= __pyx_pybuffernd_alm2_.diminfo[0].shape)) __pyx_t_30 = 0;
-          if (unlikely(__pyx_t_30 != -1)) {
-            __Pyx_RaiseBufferIndexError(__pyx_t_30);
-            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
           }
 
-          /* "healpy/src/_sphtools.pyx":409
+          /* "healpy/src/_sphtools.pyx":380
  *                 for m in range(1, limit + 1):
  *                     j = alm_getidx(lmax_, l, m)
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +             # <<<<<<<<<<<<<<
  *                                         alm1_[j].imag * alm2_[j].imag)
  *                 powspec_[l] /= (2 * l + 1)
  */
-          __pyx_t_30 = __pyx_v_l;
-          __pyx_t_31 = -1;
-          if (__pyx_t_30 < 0) {
-            __pyx_t_30 += __pyx_pybuffernd_powspec_.diminfo[0].shape;
-            if (unlikely(__pyx_t_30 < 0)) __pyx_t_31 = 0;
-          } else if (unlikely(__pyx_t_30 >= __pyx_pybuffernd_powspec_.diminfo[0].shape)) __pyx_t_31 = 0;
-          if (unlikely(__pyx_t_31 != -1)) {
-            __Pyx_RaiseBufferIndexError(__pyx_t_31);
-            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __pyx_t_29 = __pyx_v_l;
+          __pyx_t_30 = -1;
+          if (__pyx_t_29 < 0) {
+            __pyx_t_29 += __pyx_bshape_0_powspec_;
+            if (unlikely(__pyx_t_29 < 0)) __pyx_t_30 = 0;
+          } else if (unlikely(__pyx_t_29 >= __pyx_bshape_0_powspec_)) __pyx_t_30 = 0;
+          if (unlikely(__pyx_t_30 != -1)) {
+            __Pyx_RaiseBufferIndexError(__pyx_t_30);
+            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
           }
-          *__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_powspec_.rcbuffer->pybuffer.buf, __pyx_t_30, __pyx_pybuffernd_powspec_.diminfo[0].strides) += (2.0 * ((__Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm1_.rcbuffer->pybuffer.buf, __pyx_t_25, __pyx_pybuffernd_alm1_.diminfo[0].strides))) * __Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm2_.rcbuffer->pybuffer.buf, __pyx_t_27, __pyx_pybuffernd_alm2_.diminfo[0].strides)))) + (__Pyx_CIMAG((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm1_.rcbuffer->pybuffer.buf, __pyx_t_28, __pyx_pybuffernd_alm1_.diminfo[0].strides))) * __Pyx_CIMAG((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm2_.rcbuffer->pybuffer.buf, __pyx_t_29, __pyx_pybuffernd_alm2_.diminfo[0].strides))))));
+          *__Pyx_BufPtrStrided1d(double *, __pyx_bstruct_powspec_.buf, __pyx_t_29, __pyx_bstride_0_powspec_) += (2.0 * ((__Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm1_.buf, __pyx_t_25, __pyx_bstride_0_alm1_))) * __Pyx_CREAL((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm2_.buf, __pyx_t_26, __pyx_bstride_0_alm2_)))) + (__Pyx_CIMAG((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm1_.buf, __pyx_t_27, __pyx_bstride_0_alm1_))) * __Pyx_CIMAG((*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm2_.buf, __pyx_t_28, __pyx_bstride_0_alm2_))))));
         }
 
-        /* "healpy/src/_sphtools.pyx":411
+        /* "healpy/src/_sphtools.pyx":382
  *                     powspec_[l] += 2 * (alm1_[j].real * alm2_[j].real +
  *                                         alm1_[j].imag * alm2_[j].imag)
  *                 powspec_[l] /= (2 * l + 1)             # <<<<<<<<<<<<<<
  *             spectra.append(powspec_)
  * 
  */
-        __pyx_t_24 = __pyx_v_l;
-        __pyx_t_31 = -1;
-        if (__pyx_t_24 < 0) {
-          __pyx_t_24 += __pyx_pybuffernd_powspec_.diminfo[0].shape;
-          if (unlikely(__pyx_t_24 < 0)) __pyx_t_31 = 0;
-        } else if (unlikely(__pyx_t_24 >= __pyx_pybuffernd_powspec_.diminfo[0].shape)) __pyx_t_31 = 0;
-        if (unlikely(__pyx_t_31 != -1)) {
-          __Pyx_RaiseBufferIndexError(__pyx_t_31);
-          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_23 = __pyx_v_l;
+        __pyx_t_30 = -1;
+        if (__pyx_t_23 < 0) {
+          __pyx_t_23 += __pyx_bshape_0_powspec_;
+          if (unlikely(__pyx_t_23 < 0)) __pyx_t_30 = 0;
+        } else if (unlikely(__pyx_t_23 >= __pyx_bshape_0_powspec_)) __pyx_t_30 = 0;
+        if (unlikely(__pyx_t_30 != -1)) {
+          __Pyx_RaiseBufferIndexError(__pyx_t_30);
+          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
-        *__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_powspec_.rcbuffer->pybuffer.buf, __pyx_t_24, __pyx_pybuffernd_powspec_.diminfo[0].strides) /= ((2 * __pyx_v_l) + 1);
+        *__Pyx_BufPtrStrided1d(double *, __pyx_bstruct_powspec_.buf, __pyx_t_23, __pyx_bstride_0_powspec_) /= ((2 * __pyx_v_l) + 1);
       }
 
-      /* "healpy/src/_sphtools.pyx":412
+      /* "healpy/src/_sphtools.pyx":383
  *                                         alm1_[j].imag * alm2_[j].imag)
  *                 powspec_[l] /= (2 * l + 1)
  *             spectra.append(powspec_)             # <<<<<<<<<<<<<<
  * 
  *     # if only one alm was given, returns only cl and not a list with one cl
  */
-      __pyx_t_32 = __Pyx_PyObject_Append(__pyx_v_spectra, ((PyObject *)__pyx_v_powspec_)); if (unlikely(__pyx_t_32 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_4 = __Pyx_PyObject_Append(__pyx_v_spectra, ((PyObject *)__pyx_v_powspec_)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     }
   }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "healpy/src/_sphtools.pyx":415
+  /* "healpy/src/_sphtools.pyx":386
  * 
  *     # if only one alm was given, returns only cl and not a list with one cl
  *     if alms_lonely:             # <<<<<<<<<<<<<<
  *         spectra = spectra[0]
  * 
  */
-  __pyx_t_2 = (__pyx_v_alms_lonely != 0);
-  if (__pyx_t_2) {
+  if (__pyx_v_alms_lonely) {
 
-    /* "healpy/src/_sphtools.pyx":416
+    /* "healpy/src/_sphtools.pyx":387
  *     # if only one alm was given, returns only cl and not a list with one cl
  *     if alms_lonely:
  *         spectra = spectra[0]             # <<<<<<<<<<<<<<
  * 
  *     return spectra
  */
-    __pyx_t_3 = __Pyx_GetItemInt_List(__pyx_v_spectra, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF_SET(__pyx_v_spectra, __pyx_t_3);
-    __pyx_t_3 = 0;
-    goto __pyx_L23;
+    __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_spectra, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_8) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_v_spectra);
+    __pyx_v_spectra = __pyx_t_8;
+    __pyx_t_8 = 0;
+    goto __pyx_L27;
   }
-  __pyx_L23:;
+  __pyx_L27:;
 
-  /* "healpy/src/_sphtools.pyx":418
+  /* "healpy/src/_sphtools.pyx":389
  *         spectra = spectra[0]
  * 
  *     return spectra             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_spectra);
   __pyx_r = __pyx_v_spectra;
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":311
- * 
- * 
- * def alm2cl(alms, alms2 = None, lmax = None, mmax = None, lmax_out = None):             # <<<<<<<<<<<<<<
- *     """Computes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between
- *     alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_12);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm1_.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm2_.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_powspec_.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm1_);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm2_);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_powspec_);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.alm2cl", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm1_.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm2_.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_powspec_.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm1_);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm2_);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_powspec_);
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_powspec_);
   __Pyx_XDECREF((PyObject *)__pyx_v_alm1_);
   __Pyx_XDECREF((PyObject *)__pyx_v_alm2_);
   __Pyx_XDECREF(__pyx_v_spectra);
   __Pyx_XDECREF(__pyx_v_n);
   __Pyx_XDECREF(__pyx_v_alms);
@@ -5769,76 +4706,111 @@
   __Pyx_XDECREF(__pyx_v_mmax);
   __Pyx_XDECREF(__pyx_v_lmax_out);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":423
+/* "healpy/src/_sphtools.pyx":394
  * @cython.wraparound(False)
  * @cython.boundscheck(False)
  * def almxfl(alm, fl, mmax = None, inplace = False):             # <<<<<<<<<<<<<<
  *     """Multiply an a_lm by a vector b_l.
  * 
  */
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_11almxfl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_10almxfl[] = "Multiply an a_lm by a vector b_l.\n\n    Parameters\n    ----------\n    alm : array, double\n      The array representing the spherical harmonics coefficients\n    fl : array, double\n      The array giving the factor f_l by which to multiply a_lm\n    mmax : None or int, optional\n      The maximum m of the input alm\n    inplace : bool, optional\n      If True, performs the computation in-place if possible (input alm\n      is modified if it is a 1d-array of type float64). Otherwise,\n      a copy of alm is done.\n\n    Returns\n    -------\n    alm : array, double\n      The result of a_lm * f_l. If *inplace* is True, returns the input\n      alm modified\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_11almxfl = {__Pyx_NAMESTR("almxfl"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_11almxfl, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_10almxfl)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_11almxfl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pf_6healpy_9_sphtools_3almxfl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_3almxfl[] = "almxfl(alm, fl, mmax=None, inplace=False)\nMultiply an a_lm by a vector b_l.\n\n    Parameters\n    ----------\n    alm : array, double\n      The array representing the spherical harmonics coefficients\n    fl : array, double\n      The array giving the factor f_l by which to multiply a_lm\n    mmax : None or int, optional\n      The maximum m of the input alm\n    inplace : bool, optional\n      If True, performs the computation in-place if possible (input alm\n      is modified if it is a 1d-array of type float64). Otherwise,\n      a copy of alm is done.\n\n    Returns\n    -------\n    alm : array, double\n      The result of a_lm * f_l. If *inplace* is True, returns the input\n      alm modified\n    ";
+static PyMethodDef __pyx_mdef_6healpy_9_sphtools_3almxfl = {__Pyx_NAMESTR("almxfl"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_3almxfl, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_3almxfl)};
+static PyObject *__pyx_pf_6healpy_9_sphtools_3almxfl(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_alm = 0;
   PyObject *__pyx_v_fl = 0;
   PyObject *__pyx_v_mmax = 0;
   PyObject *__pyx_v_inplace = 0;
+  PyArrayObject *__pyx_v_alm_ = 0;
+  PyArrayObject *__pyx_v_fl_ = 0;
+  int __pyx_v_lmax_;
+  int __pyx_v_mmax_;
+  int __pyx_v_l;
+  int __pyx_v_m;
+  __pyx_t_double_complex __pyx_v_f;
+  int __pyx_v_maxm;
+  int __pyx_v_i;
+  int __pyx_v_flsize;
+  Py_buffer __pyx_bstruct_fl_;
+  Py_ssize_t __pyx_bstride_0_fl_ = 0;
+  Py_ssize_t __pyx_bshape_0_fl_ = 0;
+  Py_buffer __pyx_bstruct_alm_;
+  Py_ssize_t __pyx_bstride_0_alm_ = 0;
+  Py_ssize_t __pyx_bshape_0_alm_ = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyArrayObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyArrayObject *__pyx_t_12 = NULL;
+  int __pyx_t_13;
+  long __pyx_t_14;
+  __pyx_t_double_complex __pyx_t_15;
+  int __pyx_t_16;
+  long __pyx_t_17;
+  int __pyx_t_18;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("almxfl (wrapper)", 0);
+  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__alm,&__pyx_n_s__fl,&__pyx_n_s__mmax,&__pyx_n_s__inplace,0};
+  __Pyx_RefNannySetupContext("almxfl");
+  __pyx_self = __pyx_self;
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alm,&__pyx_n_s_fl,&__pyx_n_s_mmax,&__pyx_n_s_inplace,0};
     PyObject* values[4] = {0,0,0,0};
     values[2] = ((PyObject *)Py_None);
-    values[3] = ((PyObject *)Py_False);
+    values[3] = __pyx_k_22;
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_alm)) != 0)) kw_args--;
+        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__alm);
+        if (likely(values[0])) kw_args--;
         else goto __pyx_L5_argtuple_error;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fl)) != 0)) kw_args--;
+        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fl);
+        if (likely(values[1])) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("almxfl", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+          __Pyx_RaiseArgtupleInvalid("almxfl", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
         }
         case  2:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mmax);
           if (value) { values[2] = value; kw_args--; }
         }
         case  3:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_inplace);
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__inplace);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "almxfl") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "almxfl") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
@@ -5849,1445 +4821,419 @@
     __pyx_v_alm = values[0];
     __pyx_v_fl = values[1];
     __pyx_v_mmax = values[2];
     __pyx_v_inplace = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("almxfl", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("almxfl", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_AddTraceback("healpy._sphtools.almxfl", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_10almxfl(__pyx_self, __pyx_v_alm, __pyx_v_fl, __pyx_v_mmax, __pyx_v_inplace);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_10almxfl(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alm, PyObject *__pyx_v_fl, PyObject *__pyx_v_mmax, PyObject *__pyx_v_inplace) {
-  PyArrayObject *__pyx_v_alm_ = 0;
-  PyArrayObject *__pyx_v_fl_ = 0;
-  int __pyx_v_lmax_;
-  int __pyx_v_mmax_;
-  int __pyx_v_l;
-  int __pyx_v_m;
-  __pyx_t_double_complex __pyx_v_f;
-  int __pyx_v_maxm;
-  int __pyx_v_i;
-  int __pyx_v_flsize;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_alm_;
-  __Pyx_Buffer __pyx_pybuffer_alm_;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_fl_;
-  __Pyx_Buffer __pyx_pybuffer_fl_;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyArrayObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
-  PyObject *__pyx_t_9 = NULL;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  PyArrayObject *__pyx_t_12 = NULL;
-  PyObject *(*__pyx_t_13)(PyObject *);
-  int __pyx_t_14;
-  long __pyx_t_15;
-  __pyx_t_double_complex __pyx_t_16;
-  int __pyx_t_17;
-  long __pyx_t_18;
-  int __pyx_t_19;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("almxfl", 0);
-  __pyx_pybuffer_alm_.pybuffer.buf = NULL;
-  __pyx_pybuffer_alm_.refcount = 0;
-  __pyx_pybuffernd_alm_.data = NULL;
-  __pyx_pybuffernd_alm_.rcbuffer = &__pyx_pybuffer_alm_;
-  __pyx_pybuffer_fl_.pybuffer.buf = NULL;
-  __pyx_pybuffer_fl_.refcount = 0;
-  __pyx_pybuffernd_fl_.data = NULL;
-  __pyx_pybuffernd_fl_.rcbuffer = &__pyx_pybuffer_fl_;
+  __pyx_bstruct_alm_.buf = NULL;
+  __pyx_bstruct_fl_.buf = NULL;
 
-  /* "healpy/src/_sphtools.pyx":448
+  /* "healpy/src/_sphtools.pyx":419
  *     cdef np.ndarray[np.complex128_t, ndim=1] fl_
  * 
  *     if inplace:             # <<<<<<<<<<<<<<
  *         alm_ = np.ascontiguousarray(alm, dtype = np.complex128)
  *     else:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_inplace); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_inplace); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   if (__pyx_t_1) {
 
-    /* "healpy/src/_sphtools.pyx":449
+    /* "healpy/src/_sphtools.pyx":420
  * 
  *     if inplace:
  *         alm_ = np.ascontiguousarray(alm, dtype = np.complex128)             # <<<<<<<<<<<<<<
  *     else:
  *         alm_ = np.array(alm, dtype = np.complex128, copy = True)
  */
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
     __Pyx_INCREF(__pyx_v_alm);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_alm);
     __Pyx_GIVEREF(__pyx_v_alm);
-    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+    __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_complex128); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__complex128); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_dtype, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (PyDict_SetItem(__pyx_t_4, ((PyObject *)__pyx_n_s__dtype), __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_2), ((PyObject *)__pyx_t_4)); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (!(likely(((__pyx_t_6) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_6, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+    if (!(likely(((__pyx_t_6) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_6, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __pyx_t_7 = ((PyArrayObject *)__pyx_t_6);
     {
       __Pyx_BufFmt_StackElem __pyx_stack[1];
-      __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer);
-      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
+      __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm_);
+      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_alm_, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
       if (unlikely(__pyx_t_8 < 0)) {
         PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
-        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer, (PyObject*)__pyx_v_alm_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_alm_, (PyObject*)__pyx_v_alm_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
           Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
           __Pyx_RaiseBufferFallbackError();
         } else {
           PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
         }
       }
-      __pyx_pybuffernd_alm_.diminfo[0].strides = __pyx_pybuffernd_alm_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_alm_.diminfo[0].shape = __pyx_pybuffernd_alm_.rcbuffer->pybuffer.shape[0];
-      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_bstride_0_alm_ = __pyx_bstruct_alm_.strides[0];
+      __pyx_bshape_0_alm_ = __pyx_bstruct_alm_.shape[0];
+      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
     __pyx_t_7 = 0;
     __pyx_v_alm_ = ((PyArrayObject *)__pyx_t_6);
     __pyx_t_6 = 0;
-    goto __pyx_L3;
+    goto __pyx_L6;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":451
+    /* "healpy/src/_sphtools.pyx":422
  *         alm_ = np.ascontiguousarray(alm, dtype = np.complex128)
  *     else:
  *         alm_ = np.array(alm, dtype = np.complex128, copy = True)             # <<<<<<<<<<<<<<
  * 
  *     fl_ = np.ascontiguousarray(fl, dtype = np.complex128)
  */
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_array); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_GetAttr(__pyx_t_6, __pyx_n_s__array); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
     __Pyx_INCREF(__pyx_v_alm);
     PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_alm);
     __Pyx_GIVEREF(__pyx_v_alm);
-    __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_complex128); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__complex128); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_n_s__dtype), __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_n_s__copy), __pyx_t_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_copy, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_5 = PyObject_Call(__pyx_t_4, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyEval_CallObjectWithKeywords(__pyx_t_4, ((PyObject *)__pyx_t_6), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __pyx_t_7 = ((PyArrayObject *)__pyx_t_5);
     {
       __Pyx_BufFmt_StackElem __pyx_stack[1];
-      __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer);
-      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
+      __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm_);
+      __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_alm_, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
       if (unlikely(__pyx_t_8 < 0)) {
         PyErr_Fetch(&__pyx_t_11, &__pyx_t_10, &__pyx_t_9);
-        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer, (PyObject*)__pyx_v_alm_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_alm_, (PyObject*)__pyx_v_alm_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
           Py_XDECREF(__pyx_t_11); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_9);
           __Pyx_RaiseBufferFallbackError();
         } else {
           PyErr_Restore(__pyx_t_11, __pyx_t_10, __pyx_t_9);
         }
       }
-      __pyx_pybuffernd_alm_.diminfo[0].strides = __pyx_pybuffernd_alm_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_alm_.diminfo[0].shape = __pyx_pybuffernd_alm_.rcbuffer->pybuffer.shape[0];
-      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_bstride_0_alm_ = __pyx_bstruct_alm_.strides[0];
+      __pyx_bshape_0_alm_ = __pyx_bstruct_alm_.shape[0];
+      if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
     __pyx_t_7 = 0;
     __pyx_v_alm_ = ((PyArrayObject *)__pyx_t_5);
     __pyx_t_5 = 0;
   }
-  __pyx_L3:;
+  __pyx_L6:;
 
-  /* "healpy/src/_sphtools.pyx":453
+  /* "healpy/src/_sphtools.pyx":424
  *         alm_ = np.array(alm, dtype = np.complex128, copy = True)
  * 
  *     fl_ = np.ascontiguousarray(fl, dtype = np.complex128)             # <<<<<<<<<<<<<<
  * 
  *     cdef int lmax_, mmax_
  */
-  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyObject_GetAttr(__pyx_t_5, __pyx_n_s__ascontiguousarray); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
   __Pyx_INCREF(__pyx_v_fl);
   PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_fl);
   __Pyx_GIVEREF(__pyx_v_fl);
-  __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+  __pyx_t_4 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_complex128); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__complex128); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem(__pyx_t_6, ((PyObject *)__pyx_n_s__dtype), __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyObject_Call(__pyx_t_2, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_2, ((PyObject *)__pyx_t_5), ((PyObject *)__pyx_t_6)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+  if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_t_12 = ((PyArrayObject *)__pyx_t_3);
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_fl_.rcbuffer->pybuffer);
-    __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_fl_.rcbuffer->pybuffer, (PyObject*)__pyx_t_12, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_fl_);
+    __pyx_t_8 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_fl_, (PyObject*)__pyx_t_12, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
     if (unlikely(__pyx_t_8 < 0)) {
       PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
-      if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_fl_.rcbuffer->pybuffer, (PyObject*)__pyx_v_fl_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_fl_, (PyObject*)__pyx_v_fl_, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
         Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
         __Pyx_RaiseBufferFallbackError();
       } else {
         PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
       }
     }
-    __pyx_pybuffernd_fl_.diminfo[0].strides = __pyx_pybuffernd_fl_.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_fl_.diminfo[0].shape = __pyx_pybuffernd_fl_.rcbuffer->pybuffer.shape[0];
-    if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_bstride_0_fl_ = __pyx_bstruct_fl_.strides[0];
+    __pyx_bshape_0_fl_ = __pyx_bstruct_fl_.shape[0];
+    if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   __pyx_t_12 = 0;
   __pyx_v_fl_ = ((PyArrayObject *)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "healpy/src/_sphtools.pyx":457
+  /* "healpy/src/_sphtools.pyx":428
  *     cdef int lmax_, mmax_
  *     cdef int l, m
- *     lmax_, mmax_ = alm_getlmmax(alm_, None, mmax)             # <<<<<<<<<<<<<<
- * 
- *     cdef np.complex128_t f
+ *     if mmax is None:             # <<<<<<<<<<<<<<
+ *         lmax_ = alm_getlmax(alm_.size)
+ *         mmax_ = lmax_
  */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_alm_getlmmax); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_INCREF(((PyObject *)__pyx_v_alm_));
-  PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_v_alm_));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_alm_));
-  __Pyx_INCREF(Py_None);
-  PyTuple_SET_ITEM(__pyx_t_6, 1, Py_None);
-  __Pyx_GIVEREF(Py_None);
-  __Pyx_INCREF(__pyx_v_mmax);
-  PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_v_mmax);
-  __Pyx_GIVEREF(__pyx_v_mmax);
-  __pyx_t_5 = PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
-    PyObject* sequence = __pyx_t_5;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    Py_ssize_t size = Py_SIZE(sequence);
-    #else
-    Py_ssize_t size = PySequence_Size(sequence);
-    #endif
-    if (unlikely(size != 2)) {
-      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    #if CYTHON_COMPILING_IN_CPYTHON
-    if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_6 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    } else {
-      __pyx_t_6 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
-    }
-    __Pyx_INCREF(__pyx_t_6);
-    __Pyx_INCREF(__pyx_t_3);
-    #else
-    __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = (__pyx_v_mmax == Py_None);
+  if (__pyx_t_1) {
+
+    /* "healpy/src/_sphtools.pyx":429
+ *     cdef int l, m
+ *     if mmax is None:
+ *         lmax_ = alm_getlmax(alm_.size)             # <<<<<<<<<<<<<<
+ *         mmax_ = lmax_
+ *     else:
+ */
+    __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_alm_), __pyx_n_s__size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  } else {
-    Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_13 = Py_TYPE(__pyx_t_2)->tp_iternext;
-    index = 0; __pyx_t_6 = __pyx_t_13(__pyx_t_2); if (unlikely(!__pyx_t_6)) goto __pyx_L4_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_6);
-    index = 1; __pyx_t_3 = __pyx_t_13(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L4_unpacking_failed;
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_v_lmax_ = __pyx_f_6healpy_9_sphtools_alm_getlmax(__pyx_t_8);
+
+    /* "healpy/src/_sphtools.pyx":430
+ *     if mmax is None:
+ *         lmax_ = alm_getlmax(alm_.size)
+ *         mmax_ = lmax_             # <<<<<<<<<<<<<<
+ *     else:
+ *         lmax_ = alm_getlmax2(alm_.size, mmax)
+ */
+    __pyx_v_mmax_ = __pyx_v_lmax_;
+    goto __pyx_L7;
+  }
+  /*else*/ {
+
+    /* "healpy/src/_sphtools.pyx":432
+ *         mmax_ = lmax_
+ *     else:
+ *         lmax_ = alm_getlmax2(alm_.size, mmax)             # <<<<<<<<<<<<<<
+ *         mmax_ = mmax
+ * 
+ */
+    __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_alm_), __pyx_n_s__size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_13(__pyx_t_2), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_13 = NULL;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    goto __pyx_L5_unpacking_done;
-    __pyx_L4_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_13 = NULL;
-    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_L5_unpacking_done:;
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_13 = __Pyx_PyInt_AsInt(__pyx_v_mmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_lmax_ = __pyx_f_6healpy_9_sphtools_alm_getlmax2(__pyx_t_8, __pyx_t_13);
+
+    /* "healpy/src/_sphtools.pyx":433
+ *     else:
+ *         lmax_ = alm_getlmax2(alm_.size, mmax)
+ *         mmax_ = mmax             # <<<<<<<<<<<<<<
+ * 
+ *     cdef np.complex128_t f
+ */
+    __pyx_t_13 = __Pyx_PyInt_AsInt(__pyx_v_mmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_mmax_ = __pyx_t_13;
   }
-  __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_t_6); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_lmax_ = __pyx_t_8;
-  __pyx_v_mmax_ = __pyx_t_14;
+  __pyx_L7:;
 
-  /* "healpy/src/_sphtools.pyx":461
+  /* "healpy/src/_sphtools.pyx":437
  *     cdef np.complex128_t f
  *     cdef int maxm, i
  *     cdef int flsize = fl_.size             # <<<<<<<<<<<<<<
  *     for l in xrange(lmax_ + 1):
  *         f = fl_[l] if l < flsize else 0.
  */
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_fl_), __pyx_n_s_size); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_v_flsize = __pyx_t_14;
+  __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_fl_), __pyx_n_s__size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_13 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_flsize = __pyx_t_13;
 
-  /* "healpy/src/_sphtools.pyx":462
+  /* "healpy/src/_sphtools.pyx":438
  *     cdef int maxm, i
  *     cdef int flsize = fl_.size
  *     for l in xrange(lmax_ + 1):             # <<<<<<<<<<<<<<
  *         f = fl_[l] if l < flsize else 0.
  *         maxm = l if l <= mmax_ else mmax_
  */
-  __pyx_t_15 = (__pyx_v_lmax_ + 1);
-  for (__pyx_t_14 = 0; __pyx_t_14 < __pyx_t_15; __pyx_t_14+=1) {
-    __pyx_v_l = __pyx_t_14;
+  __pyx_t_14 = (__pyx_v_lmax_ + 1);
+  for (__pyx_t_13 = 0; __pyx_t_13 < __pyx_t_14; __pyx_t_13+=1) {
+    __pyx_v_l = __pyx_t_13;
 
-    /* "healpy/src/_sphtools.pyx":463
+    /* "healpy/src/_sphtools.pyx":439
  *     cdef int flsize = fl_.size
  *     for l in xrange(lmax_ + 1):
  *         f = fl_[l] if l < flsize else 0.             # <<<<<<<<<<<<<<
  *         maxm = l if l <= mmax_ else mmax_
  *         for m in xrange(maxm + 1):
  */
-    if (((__pyx_v_l < __pyx_v_flsize) != 0)) {
+    if ((__pyx_v_l < __pyx_v_flsize)) {
       __pyx_t_8 = __pyx_v_l;
-      __pyx_t_16 = (*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_fl_.rcbuffer->pybuffer.buf, __pyx_t_8, __pyx_pybuffernd_fl_.diminfo[0].strides));
+      __pyx_t_15 = (*__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_fl_.buf, __pyx_t_8, __pyx_bstride_0_fl_));
     } else {
-      __pyx_t_16 = __pyx_t_double_complex_from_parts(0., 0);
+      __pyx_t_15 = 0.;
     }
-    __pyx_v_f = __pyx_t_16;
+    __pyx_v_f = __pyx_t_15;
 
-    /* "healpy/src/_sphtools.pyx":464
+    /* "healpy/src/_sphtools.pyx":440
  *     for l in xrange(lmax_ + 1):
  *         f = fl_[l] if l < flsize else 0.
  *         maxm = l if l <= mmax_ else mmax_             # <<<<<<<<<<<<<<
  *         for m in xrange(maxm + 1):
  *             i = alm_getidx(lmax_, l, m)
  */
-    if (((__pyx_v_l <= __pyx_v_mmax_) != 0)) {
-      __pyx_t_17 = __pyx_v_l;
+    if ((__pyx_v_l <= __pyx_v_mmax_)) {
+      __pyx_t_16 = __pyx_v_l;
     } else {
-      __pyx_t_17 = __pyx_v_mmax_;
+      __pyx_t_16 = __pyx_v_mmax_;
     }
-    __pyx_v_maxm = __pyx_t_17;
+    __pyx_v_maxm = __pyx_t_16;
 
-    /* "healpy/src/_sphtools.pyx":465
+    /* "healpy/src/_sphtools.pyx":441
  *         f = fl_[l] if l < flsize else 0.
  *         maxm = l if l <= mmax_ else mmax_
  *         for m in xrange(maxm + 1):             # <<<<<<<<<<<<<<
  *             i = alm_getidx(lmax_, l, m)
  *             alm_[i] *= f
  */
-    __pyx_t_18 = (__pyx_v_maxm + 1);
-    for (__pyx_t_17 = 0; __pyx_t_17 < __pyx_t_18; __pyx_t_17+=1) {
-      __pyx_v_m = __pyx_t_17;
+    __pyx_t_17 = (__pyx_v_maxm + 1);
+    for (__pyx_t_16 = 0; __pyx_t_16 < __pyx_t_17; __pyx_t_16+=1) {
+      __pyx_v_m = __pyx_t_16;
 
-      /* "healpy/src/_sphtools.pyx":466
+      /* "healpy/src/_sphtools.pyx":442
  *         maxm = l if l <= mmax_ else mmax_
  *         for m in xrange(maxm + 1):
  *             i = alm_getidx(lmax_, l, m)             # <<<<<<<<<<<<<<
  *             alm_[i] *= f
  * 
  */
       __pyx_v_i = __pyx_f_6healpy_9_sphtools_alm_getidx(__pyx_v_lmax_, __pyx_v_l, __pyx_v_m);
 
-      /* "healpy/src/_sphtools.pyx":467
+      /* "healpy/src/_sphtools.pyx":443
  *         for m in xrange(maxm + 1):
  *             i = alm_getidx(lmax_, l, m)
  *             alm_[i] *= f             # <<<<<<<<<<<<<<
  * 
  *     return alm_
  */
-      __pyx_t_19 = __pyx_v_i;
-      *__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_pybuffernd_alm_.rcbuffer->pybuffer.buf, __pyx_t_19, __pyx_pybuffernd_alm_.diminfo[0].strides) *= __pyx_v_f;
+      __pyx_t_18 = __pyx_v_i;
+      *__Pyx_BufPtrStrided1d(__pyx_t_double_complex *, __pyx_bstruct_alm_.buf, __pyx_t_18, __pyx_bstride_0_alm_) *= __pyx_v_f;
     }
   }
 
-  /* "healpy/src/_sphtools.pyx":469
+  /* "healpy/src/_sphtools.pyx":445
  *             alm_[i] *= f
  * 
  *     return alm_             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_alm_));
   __pyx_r = ((PyObject *)__pyx_v_alm_);
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":423
- * @cython.wraparound(False)
- * @cython.boundscheck(False)
- * def almxfl(alm, fl, mmax = None, inplace = False):             # <<<<<<<<<<<<<<
- *     """Multiply an a_lm by a vector b_l.
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_fl_.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_fl_);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm_);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.almxfl", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_alm_.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_fl_.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_fl_);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_alm_);
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_alm_);
   __Pyx_XDECREF((PyObject *)__pyx_v_fl_);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":472
- * 
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,             # <<<<<<<<<<<<<<
- *                mmax=None):
- *     """
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_13rotate_alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_6healpy_9_sphtools_12rotate_alm[] = "\n    This routine transforms the scalar (and tensor) a_lm coefficients\n    to emulate the effect of an arbitrary rotation of the underlying\n    map. The rotation is done directly on the a_lm using the Wigner\n    rotation matrices, computed by recursion. To rotate the a_lm for\n    l \342\211\244 l_max the number of operations scales like l_max^3.\n\n    Parameters\n    ----------\n    alm : array-like of shape (n,) or (k,n), or list of arrays\n        Complex a_lm values before and after rotation of the coordinate system.\n    psi : float\n        First rotation: angle \317\210 about the z-axis. All angles are in radians\n        and should lie in [-2pi,2pi], the rotations are active and the\n        referential system is assumed to be right handed. The routine\n        coordsys2euler zyz can be used to generate the Euler angles \317\210, \316\270, \317\206\n        for rotation between standard astronomical coordinate systems.\n    theta : float\n        Second rotation: angle \316\270 about the original (unrotated) y-axis\n    phi : float.\n        Third rotation: angle \317\206 about the original (unrotated) z-axis.\n    lmax : int\n        Maximum multipole order l of the data set.\n    mmax : int\n        Maximum degree m of data set.\n\n    ";
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_13rotate_alm = {__Pyx_NAMESTR("rotate_alm"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_13rotate_alm, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_12rotate_alm)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_13rotate_alm(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_alm = 0;
-  double __pyx_v_psi;
-  double __pyx_v_theta;
-  double __pyx_v_phi;
-  PyObject *__pyx_v_lmax = 0;
-  PyObject *__pyx_v_mmax = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("rotate_alm (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_alm,&__pyx_n_s_psi,&__pyx_n_s_theta,&__pyx_n_s_phi,&__pyx_n_s_lmax,&__pyx_n_s_mmax,0};
-    PyObject* values[6] = {0,0,0,0,0,0};
-    values[4] = ((PyObject *)Py_None);
-
-    /* "healpy/src/_sphtools.pyx":473
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,
- *                mmax=None):             # <<<<<<<<<<<<<<
- *     """
- *     This routine transforms the scalar (and tensor) a_lm coefficients
- */
-    values[5] = ((PyObject *)Py_None);
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
-        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_alm)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psi)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rotate_alm", 0, 4, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_theta)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rotate_alm", 0, 4, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  3:
-        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_phi)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("rotate_alm", 0, 4, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  4:
-        if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax);
-          if (value) { values[4] = value; kw_args--; }
-        }
-        case  5:
-        if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax);
-          if (value) { values[5] = value; kw_args--; }
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rotate_alm") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-      }
-    } else {
-      switch (PyTuple_GET_SIZE(__pyx_args)) {
-        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
-        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
-        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
-        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-    }
-    __pyx_v_alm = values[0];
-    __pyx_v_psi = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_psi == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-    __pyx_v_theta = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_theta == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-    __pyx_v_phi = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_phi == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-    __pyx_v_lmax = values[4];
-    __pyx_v_mmax = values[5];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("rotate_alm", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._sphtools.rotate_alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(((PyObject *)__pyx_v_alm) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "alm"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_12rotate_alm(__pyx_self, __pyx_v_alm, __pyx_v_psi, __pyx_v_theta, __pyx_v_phi, __pyx_v_lmax, __pyx_v_mmax);
-
-  /* "healpy/src/_sphtools.pyx":472
- * 
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,             # <<<<<<<<<<<<<<
- *                mmax=None):
- *     """
- */
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_12rotate_alm(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_alm, double __pyx_v_psi, double __pyx_v_theta, double __pyx_v_phi, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax) {
-  PyObject *__pyx_v_a = NULL;
-  PyObject *__pyx_v_ai = NULL;
-  Alm<xcomplex<double> > *__pyx_v_AI;
-  PyObject *__pyx_v_ag = NULL;
-  PyObject *__pyx_v_ac = NULL;
-  Alm<xcomplex<double> > *__pyx_v_AG;
-  Alm<xcomplex<double> > *__pyx_v_AC;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  PyObject *(*__pyx_t_7)(PyObject *);
-  PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *(*__pyx_t_12)(PyObject *);
-  int __pyx_t_13;
-  int __pyx_t_14;
-  Alm<xcomplex<double> > *__pyx_t_15;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("rotate_alm", 0);
-  __Pyx_INCREF(__pyx_v_alm);
-  __Pyx_INCREF(__pyx_v_lmax);
-  __Pyx_INCREF(__pyx_v_mmax);
-
-  /* "healpy/src/_sphtools.pyx":501
- * 
- *     """
- *     if isinstance(alm, np.ndarray) and alm.ndim == 1:             # <<<<<<<<<<<<<<
- *         alm = [alm]
- * 
- */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_alm, ((PyObject*)__pyx_ptype_5numpy_ndarray)); 
-  if (__pyx_t_1) {
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_alm, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_int_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __pyx_t_4;
-  } else {
-    __pyx_t_5 = __pyx_t_1;
-  }
-  if (__pyx_t_5) {
-
-    /* "healpy/src/_sphtools.pyx":502
- *     """
- *     if isinstance(alm, np.ndarray) and alm.ndim == 1:
- *         alm = [alm]             # <<<<<<<<<<<<<<
- * 
- *     if not isinstance(alm, (list, tuple, np.ndarray)) or len(alm) == 0:
- */
-    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_v_alm);
-    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_alm);
-    __Pyx_GIVEREF(__pyx_v_alm);
-    __Pyx_DECREF_SET(__pyx_v_alm, __pyx_t_3);
-    __pyx_t_3 = 0;
-    goto __pyx_L3;
-  }
-  __pyx_L3:;
-
-  /* "healpy/src/_sphtools.pyx":504
- *         alm = [alm]
- * 
- *     if not isinstance(alm, (list, tuple, np.ndarray)) or len(alm) == 0:             # <<<<<<<<<<<<<<
- *         raise ValueError('Invalid input.')
- * 
- */
-  __Pyx_INCREF(__pyx_v_alm);
-  __pyx_t_3 = __pyx_v_alm;
-  __pyx_t_5 = PyList_Check(__pyx_t_3); 
-  if (!__pyx_t_5) {
-    __pyx_t_1 = PyTuple_Check(__pyx_t_3); 
-    __pyx_t_4 = __pyx_t_1;
-  } else {
-    __pyx_t_4 = __pyx_t_5;
-  }
-  if (!__pyx_t_4) {
-    __pyx_t_5 = __Pyx_TypeCheck(__pyx_t_3, ((PyObject*)__pyx_ptype_5numpy_ndarray)); 
-    __pyx_t_1 = __pyx_t_5;
-  } else {
-    __pyx_t_1 = __pyx_t_4;
-  }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = ((!(__pyx_t_1 != 0)) != 0);
-  if (!__pyx_t_4) {
-    __pyx_t_6 = PyObject_Length(__pyx_v_alm); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_1 = ((__pyx_t_6 == 0) != 0);
-    __pyx_t_5 = __pyx_t_1;
-  } else {
-    __pyx_t_5 = __pyx_t_4;
-  }
-  if (__pyx_t_5) {
-
-    /* "healpy/src/_sphtools.pyx":505
- * 
- *     if not isinstance(alm, (list, tuple, np.ndarray)) or len(alm) == 0:
- *         raise ValueError('Invalid input.')             # <<<<<<<<<<<<<<
- * 
- *     # C++ rotate_alm only handles 1 or 3 maps. The function handling 3 maps
- */
-    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-
-  /* "healpy/src/_sphtools.pyx":510
- *     # is faster than running 3 times the 1-map function, but gives identical
- *     # results.
- *     if len(alm) not in (1, 3):             # <<<<<<<<<<<<<<
- *         for a in alm:
- *             rotate_alm(a, psi, theta, phi)
- */
-  __pyx_t_6 = PyObject_Length(__pyx_v_alm); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_5 = ((int)(__pyx_t_6 != 1));
-  if (__pyx_t_5) {
-    __pyx_t_4 = ((int)(__pyx_t_6 != 3));
-    __pyx_t_1 = __pyx_t_4;
-  } else {
-    __pyx_t_1 = __pyx_t_5;
-  }
-  __pyx_t_5 = (__pyx_t_1 != 0);
-  if (__pyx_t_5) {
-
-    /* "healpy/src/_sphtools.pyx":511
- *     # results.
- *     if len(alm) not in (1, 3):
- *         for a in alm:             # <<<<<<<<<<<<<<
- *             rotate_alm(a, psi, theta, phi)
- *         return
- */
-    if (PyList_CheckExact(__pyx_v_alm) || PyTuple_CheckExact(__pyx_v_alm)) {
-      __pyx_t_3 = __pyx_v_alm; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
-      __pyx_t_7 = NULL;
-    } else {
-      __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_alm); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext;
-    }
-    for (;;) {
-      if (!__pyx_t_7 && PyList_CheckExact(__pyx_t_3)) {
-        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
-        #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        #endif
-      } else if (!__pyx_t_7 && PyTuple_CheckExact(__pyx_t_3)) {
-        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
-        #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        #endif
-      } else {
-        __pyx_t_2 = __pyx_t_7(__pyx_t_3);
-        if (unlikely(!__pyx_t_2)) {
-          PyObject* exc_type = PyErr_Occurred();
-          if (exc_type) {
-            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-          }
-          break;
-        }
-        __Pyx_GOTREF(__pyx_t_2);
-      }
-      __Pyx_XDECREF_SET(__pyx_v_a, __pyx_t_2);
-      __pyx_t_2 = 0;
-
-      /* "healpy/src/_sphtools.pyx":512
- *     if len(alm) not in (1, 3):
- *         for a in alm:
- *             rotate_alm(a, psi, theta, phi)             # <<<<<<<<<<<<<<
- *         return
- * 
- */
-      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_rotate_alm); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_8 = PyFloat_FromDouble(__pyx_v_psi); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_9 = PyFloat_FromDouble(__pyx_v_theta); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_10 = PyFloat_FromDouble(__pyx_v_phi); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_10);
-      __pyx_t_11 = PyTuple_New(4); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_11);
-      __Pyx_INCREF(__pyx_v_a);
-      PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_v_a);
-      __Pyx_GIVEREF(__pyx_v_a);
-      PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_8);
-      __Pyx_GIVEREF(__pyx_t_8);
-      PyTuple_SET_ITEM(__pyx_t_11, 2, __pyx_t_9);
-      __Pyx_GIVEREF(__pyx_t_9);
-      PyTuple_SET_ITEM(__pyx_t_11, 3, __pyx_t_10);
-      __Pyx_GIVEREF(__pyx_t_10);
-      __pyx_t_8 = 0;
-      __pyx_t_9 = 0;
-      __pyx_t_10 = 0;
-      __pyx_t_10 = PyObject_Call(__pyx_t_2, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    }
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-    /* "healpy/src/_sphtools.pyx":513
- *         for a in alm:
- *             rotate_alm(a, psi, theta, phi)
- *         return             # <<<<<<<<<<<<<<
- * 
- *     lmax, mmax = alm_getlmmax(alm[0], lmax, mmax)
- */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-    goto __pyx_L0;
-  }
-
-  /* "healpy/src/_sphtools.pyx":515
- *         return
- * 
- *     lmax, mmax = alm_getlmmax(alm[0], lmax, mmax)             # <<<<<<<<<<<<<<
- *     ai = np.ascontiguousarray(alm[0], dtype=np.complex128)
- *     AI = ndarray2alm(ai, lmax, mmax)
- */
-  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_alm_getlmmax); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_10 = __Pyx_GetItemInt(__pyx_v_alm, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_10 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_10);
-  __pyx_t_11 = PyTuple_New(3); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_11);
-  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
-  __Pyx_GIVEREF(__pyx_t_10);
-  __Pyx_INCREF(__pyx_v_lmax);
-  PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_v_lmax);
-  __Pyx_GIVEREF(__pyx_v_lmax);
-  __Pyx_INCREF(__pyx_v_mmax);
-  PyTuple_SET_ITEM(__pyx_t_11, 2, __pyx_v_mmax);
-  __Pyx_GIVEREF(__pyx_v_mmax);
-  __pyx_t_10 = 0;
-  __pyx_t_10 = PyObject_Call(__pyx_t_3, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_10);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if ((likely(PyTuple_CheckExact(__pyx_t_10))) || (PyList_CheckExact(__pyx_t_10))) {
-    PyObject* sequence = __pyx_t_10;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    Py_ssize_t size = Py_SIZE(sequence);
-    #else
-    Py_ssize_t size = PySequence_Size(sequence);
-    #endif
-    if (unlikely(size != 2)) {
-      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
-    #if CYTHON_COMPILING_IN_CPYTHON
-    if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_11 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    } else {
-      __pyx_t_11 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
-    }
-    __Pyx_INCREF(__pyx_t_11);
-    __Pyx_INCREF(__pyx_t_3);
-    #else
-    __pyx_t_11 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_11);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  } else {
-    Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_10); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __pyx_t_12 = Py_TYPE(__pyx_t_2)->tp_iternext;
-    index = 0; __pyx_t_11 = __pyx_t_12(__pyx_t_2); if (unlikely(!__pyx_t_11)) goto __pyx_L8_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_11);
-    index = 1; __pyx_t_3 = __pyx_t_12(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L8_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_12(__pyx_t_2), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_12 = NULL;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    goto __pyx_L9_unpacking_done;
-    __pyx_L8_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_12 = NULL;
-    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_L9_unpacking_done:;
-  }
-  __Pyx_DECREF_SET(__pyx_v_lmax, __pyx_t_11);
-  __pyx_t_11 = 0;
-  __Pyx_DECREF_SET(__pyx_v_mmax, __pyx_t_3);
-  __pyx_t_3 = 0;
-
-  /* "healpy/src/_sphtools.pyx":516
- * 
- *     lmax, mmax = alm_getlmmax(alm[0], lmax, mmax)
- *     ai = np.ascontiguousarray(alm[0], dtype=np.complex128)             # <<<<<<<<<<<<<<
- *     AI = ndarray2alm(ai, lmax, mmax)
- *     if len(alm) == 1:
- */
-  __pyx_t_10 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_10);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __pyx_t_10 = __Pyx_GetItemInt(__pyx_v_alm, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_10 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __Pyx_GOTREF(__pyx_t_10);
-  __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_11);
-  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
-  __Pyx_GIVEREF(__pyx_t_10);
-  __pyx_t_10 = 0;
-  __pyx_t_10 = PyDict_New(); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_10);
-  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_complex128); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_10, __pyx_n_s_dtype, __pyx_t_9) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_t_9 = PyObject_Call(__pyx_t_3, __pyx_t_11, __pyx_t_10); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __pyx_v_ai = __pyx_t_9;
-  __pyx_t_9 = 0;
-
-  /* "healpy/src/_sphtools.pyx":517
- *     lmax, mmax = alm_getlmmax(alm[0], lmax, mmax)
- *     ai = np.ascontiguousarray(alm[0], dtype=np.complex128)
- *     AI = ndarray2alm(ai, lmax, mmax)             # <<<<<<<<<<<<<<
- *     if len(alm) == 1:
- *         c_rotate_alm(AI[0], psi, theta, phi)
- */
-  if (!(likely(((__pyx_v_ai) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_ai, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_ai), __pyx_t_13, __pyx_t_14); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_v_AI = __pyx_t_15;
-
-  /* "healpy/src/_sphtools.pyx":518
- *     ai = np.ascontiguousarray(alm[0], dtype=np.complex128)
- *     AI = ndarray2alm(ai, lmax, mmax)
- *     if len(alm) == 1:             # <<<<<<<<<<<<<<
- *         c_rotate_alm(AI[0], psi, theta, phi)
- *         del AI
- */
-  __pyx_t_6 = PyObject_Length(__pyx_v_alm); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_5 = ((__pyx_t_6 == 1) != 0);
-  if (__pyx_t_5) {
-
-    /* "healpy/src/_sphtools.pyx":519
- *     AI = ndarray2alm(ai, lmax, mmax)
- *     if len(alm) == 1:
- *         c_rotate_alm(AI[0], psi, theta, phi)             # <<<<<<<<<<<<<<
- *         del AI
- *     else:
- */
-    rotate_alm((__pyx_v_AI[0]), __pyx_v_psi, __pyx_v_theta, __pyx_v_phi);
-
-    /* "healpy/src/_sphtools.pyx":520
- *     if len(alm) == 1:
- *         c_rotate_alm(AI[0], psi, theta, phi)
- *         del AI             # <<<<<<<<<<<<<<
- *     else:
- *         ag = np.ascontiguousarray(alm[1], dtype=np.complex128)
- */
-    delete __pyx_v_AI;
-    goto __pyx_L10;
-  }
-  /*else*/ {
-
-    /* "healpy/src/_sphtools.pyx":522
- *         del AI
- *     else:
- *         ag = np.ascontiguousarray(alm[1], dtype=np.complex128)             # <<<<<<<<<<<<<<
- *         ac = np.ascontiguousarray(alm[2], dtype=np.complex128)
- *         AG = ndarray2alm(ag, lmax, mmax)
- */
-    __pyx_t_9 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_10);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __pyx_t_9 = __Pyx_GetItemInt(__pyx_v_alm, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_11);
-    PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_9);
-    __Pyx_GIVEREF(__pyx_t_9);
-    __pyx_t_9 = 0;
-    __pyx_t_9 = PyDict_New(); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_complex128); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (PyDict_SetItem(__pyx_t_9, __pyx_n_s_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyObject_Call(__pyx_t_10, __pyx_t_11, __pyx_t_9); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __pyx_v_ag = __pyx_t_2;
-    __pyx_t_2 = 0;
-
-    /* "healpy/src/_sphtools.pyx":523
- *     else:
- *         ag = np.ascontiguousarray(alm[1], dtype=np.complex128)
- *         ac = np.ascontiguousarray(alm[2], dtype=np.complex128)             # <<<<<<<<<<<<<<
- *         AG = ndarray2alm(ag, lmax, mmax)
- *         AC = ndarray2alm(ac, lmax, mmax)
- */
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_alm, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_11);
-    PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    __pyx_t_2 = 0;
-    __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_10 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_10);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_complex128); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_Call(__pyx_t_9, __pyx_t_11, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_ac = __pyx_t_3;
-    __pyx_t_3 = 0;
-
-    /* "healpy/src/_sphtools.pyx":524
- *         ag = np.ascontiguousarray(alm[1], dtype=np.complex128)
- *         ac = np.ascontiguousarray(alm[2], dtype=np.complex128)
- *         AG = ndarray2alm(ag, lmax, mmax)             # <<<<<<<<<<<<<<
- *         AC = ndarray2alm(ac, lmax, mmax)
- *         c_rotate_alm(AI[0], AG[0], AC[0], psi, theta, phi)
- */
-    if (!(likely(((__pyx_v_ag) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_ag, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_ag), __pyx_t_14, __pyx_t_13); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_AG = __pyx_t_15;
-
-    /* "healpy/src/_sphtools.pyx":525
- *         ac = np.ascontiguousarray(alm[2], dtype=np.complex128)
- *         AG = ndarray2alm(ag, lmax, mmax)
- *         AC = ndarray2alm(ac, lmax, mmax)             # <<<<<<<<<<<<<<
- *         c_rotate_alm(AI[0], AG[0], AC[0], psi, theta, phi)
- *         del AI, AG, AC
- */
-    if (!(likely(((__pyx_v_ac) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_ac, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_lmax); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_15 = __pyx_f_7_common_ndarray2alm(((PyArrayObject *)__pyx_v_ac), __pyx_t_13, __pyx_t_14); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_v_AC = __pyx_t_15;
-
-    /* "healpy/src/_sphtools.pyx":526
- *         AG = ndarray2alm(ag, lmax, mmax)
- *         AC = ndarray2alm(ac, lmax, mmax)
- *         c_rotate_alm(AI[0], AG[0], AC[0], psi, theta, phi)             # <<<<<<<<<<<<<<
- *         del AI, AG, AC
- * 
- */
-    rotate_alm((__pyx_v_AI[0]), (__pyx_v_AG[0]), (__pyx_v_AC[0]), __pyx_v_psi, __pyx_v_theta, __pyx_v_phi);
-
-    /* "healpy/src/_sphtools.pyx":527
- *         AC = ndarray2alm(ac, lmax, mmax)
- *         c_rotate_alm(AI[0], AG[0], AC[0], psi, theta, phi)
- *         del AI, AG, AC             # <<<<<<<<<<<<<<
- * 
- * 
- */
-    delete __pyx_v_AI;
-    delete __pyx_v_AG;
-    delete __pyx_v_AC;
-  }
-  __pyx_L10:;
-
-  /* "healpy/src/_sphtools.pyx":472
- * 
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,             # <<<<<<<<<<<<<<
- *                mmax=None):
- *     """
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_9);
-  __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_AddTraceback("healpy._sphtools.rotate_alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_a);
-  __Pyx_XDECREF(__pyx_v_ai);
-  __Pyx_XDECREF(__pyx_v_ag);
-  __Pyx_XDECREF(__pyx_v_ac);
-  __Pyx_XDECREF(__pyx_v_alm);
-  __Pyx_XDECREF(__pyx_v_lmax);
-  __Pyx_XDECREF(__pyx_v_mmax);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "healpy/src/_sphtools.pyx":530
+/* "healpy/src/_sphtools.pyx":449
  * 
+ * @cython.cdivision(True)
+ * cdef inline int alm_getidx(int lmax, int l, int m):             # <<<<<<<<<<<<<<
+ *     return m*(2*lmax+1-m)/2+l
  * 
- * cdef int alm_getn(int l, int m):             # <<<<<<<<<<<<<<
- *     if not m <= l:
- *         raise ValueError("mmax must be <= lmax")
  */
 
-static int __pyx_f_6healpy_9_sphtools_alm_getn(int __pyx_v_l, int __pyx_v_m) {
+static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getidx(int __pyx_v_lmax, int __pyx_v_l, int __pyx_v_m) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("alm_getn", 0);
+  __Pyx_RefNannySetupContext("alm_getidx");
 
-  /* "healpy/src/_sphtools.pyx":531
- * 
- * cdef int alm_getn(int l, int m):
- *     if not m <= l:             # <<<<<<<<<<<<<<
- *         raise ValueError("mmax must be <= lmax")
- *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
- */
-  __pyx_t_1 = ((!((__pyx_v_m <= __pyx_v_l) != 0)) != 0);
-  if (__pyx_t_1) {
-
-    /* "healpy/src/_sphtools.pyx":532
- * cdef int alm_getn(int l, int m):
- *     if not m <= l:
- *         raise ValueError("mmax must be <= lmax")             # <<<<<<<<<<<<<<
- *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
- * 
- */
-    __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-
-  /* "healpy/src/_sphtools.pyx":533
- *     if not m <= l:
- *         raise ValueError("mmax must be <= lmax")
- *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":450
+ * @cython.cdivision(True)
+ * cdef inline int alm_getidx(int lmax, int l, int m):
+ *     return m*(2*lmax+1-m)/2+l             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_r = (__Pyx_div_long(((__pyx_v_m + 1) * (__pyx_v_m + 2)), 2) + ((__pyx_v_m + 1) * (__pyx_v_l - __pyx_v_m)));
+  __pyx_r = (((__pyx_v_m * (((2 * __pyx_v_lmax) + 1) - __pyx_v_m)) / 2) + __pyx_v_l);
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":530
- * 
- * 
- * cdef int alm_getn(int l, int m):             # <<<<<<<<<<<<<<
- *     if not m <= l:
- *         raise ValueError("mmax must be <= lmax")
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_WriteUnraisable("healpy._sphtools.alm_getn", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":536
- * 
- * 
- * def alm_getlmmax(a, lmax, mmax):             # <<<<<<<<<<<<<<
- *     if lmax is None:
- *         if mmax is None:
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_15alm_getlmmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_6healpy_9_sphtools_15alm_getlmmax = {__Pyx_NAMESTR("alm_getlmmax"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_15alm_getlmmax, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)};
-static PyObject *__pyx_pw_6healpy_9_sphtools_15alm_getlmmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_a = 0;
-  PyObject *__pyx_v_lmax = 0;
-  PyObject *__pyx_v_mmax = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("alm_getlmmax (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_lmax,&__pyx_n_s_mmax,0};
-    PyObject* values[3] = {0,0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lmax)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("alm_getlmmax", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-        case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mmax)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("alm_getlmmax", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "alm_getlmmax") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-    }
-    __pyx_v_a = values[0];
-    __pyx_v_lmax = values[1];
-    __pyx_v_mmax = values[2];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("alm_getlmmax", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("healpy._sphtools.alm_getlmmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_14alm_getlmmax(__pyx_self, __pyx_v_a, __pyx_v_lmax, __pyx_v_mmax);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_6healpy_9_sphtools_14alm_getlmmax(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_a, PyObject *__pyx_v_lmax, PyObject *__pyx_v_mmax) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  int __pyx_t_5;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("alm_getlmmax", 0);
-  __Pyx_INCREF(__pyx_v_lmax);
-  __Pyx_INCREF(__pyx_v_mmax);
-
-  /* "healpy/src/_sphtools.pyx":537
- * 
- * def alm_getlmmax(a, lmax, mmax):
- *     if lmax is None:             # <<<<<<<<<<<<<<
- *         if mmax is None:
- *             lmax = alm_getlmax(a.size)
- */
-  __pyx_t_1 = (__pyx_v_lmax == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
-
-    /* "healpy/src/_sphtools.pyx":538
- * def alm_getlmmax(a, lmax, mmax):
- *     if lmax is None:
- *         if mmax is None:             # <<<<<<<<<<<<<<
- *             lmax = alm_getlmax(a.size)
- *             mmax = lmax
- */
-    __pyx_t_2 = (__pyx_v_mmax == Py_None);
-    __pyx_t_1 = (__pyx_t_2 != 0);
-    if (__pyx_t_1) {
-
-      /* "healpy/src/_sphtools.pyx":539
- *     if lmax is None:
- *         if mmax is None:
- *             lmax = alm_getlmax(a.size)             # <<<<<<<<<<<<<<
- *             mmax = lmax
- *         else:
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_a, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_f_6healpy_9_sphtools_alm_getlmax(__pyx_t_4)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF_SET(__pyx_v_lmax, __pyx_t_3);
-      __pyx_t_3 = 0;
-
-      /* "healpy/src/_sphtools.pyx":540
- *         if mmax is None:
- *             lmax = alm_getlmax(a.size)
- *             mmax = lmax             # <<<<<<<<<<<<<<
- *         else:
- *             lmax = alm_getlmax2(a.size, mmax)
- */
-      __Pyx_INCREF(__pyx_v_lmax);
-      __Pyx_DECREF_SET(__pyx_v_mmax, __pyx_v_lmax);
-      goto __pyx_L4;
-    }
-    /*else*/ {
-
-      /* "healpy/src/_sphtools.pyx":542
- *             mmax = lmax
- *         else:
- *             lmax = alm_getlmax2(a.size, mmax)             # <<<<<<<<<<<<<<
- *     elif mmax is None:
- *         mmax = lmax
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_a, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_mmax); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_f_6healpy_9_sphtools_alm_getlmax2(__pyx_t_4, __pyx_t_5)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF_SET(__pyx_v_lmax, __pyx_t_3);
-      __pyx_t_3 = 0;
-    }
-    __pyx_L4:;
-    goto __pyx_L3;
-  }
-
-  /* "healpy/src/_sphtools.pyx":543
- *         else:
- *             lmax = alm_getlmax2(a.size, mmax)
- *     elif mmax is None:             # <<<<<<<<<<<<<<
- *         mmax = lmax
- *     return lmax, mmax
- */
-  __pyx_t_1 = (__pyx_v_mmax == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
-
-    /* "healpy/src/_sphtools.pyx":544
- *             lmax = alm_getlmax2(a.size, mmax)
- *     elif mmax is None:
- *         mmax = lmax             # <<<<<<<<<<<<<<
- *     return lmax, mmax
- * 
- */
-    __Pyx_INCREF(__pyx_v_lmax);
-    __Pyx_DECREF_SET(__pyx_v_mmax, __pyx_v_lmax);
-    goto __pyx_L3;
-  }
-  __pyx_L3:;
-
-  /* "healpy/src/_sphtools.pyx":545
- *     elif mmax is None:
- *         mmax = lmax
- *     return lmax, mmax             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_INCREF(__pyx_v_lmax);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_lmax);
-  __Pyx_GIVEREF(__pyx_v_lmax);
-  __Pyx_INCREF(__pyx_v_mmax);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_mmax);
-  __Pyx_GIVEREF(__pyx_v_mmax);
-  __pyx_r = __pyx_t_3;
-  __pyx_t_3 = 0;
-  goto __pyx_L0;
-
-  /* "healpy/src/_sphtools.pyx":536
- * 
- * 
- * def alm_getlmmax(a, lmax, mmax):             # <<<<<<<<<<<<<<
- *     if lmax is None:
- *         if mmax is None:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("healpy._sphtools.alm_getlmmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_lmax);
-  __Pyx_XDECREF(__pyx_v_mmax);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "healpy/src/_sphtools.pyx":549
+/* "healpy/src/_sphtools.pyx":454
  * 
  * @cython.cdivision(True)
  * cdef inline int alm_getlmax(int s):             # <<<<<<<<<<<<<<
  *     cdef double x
  *     x=(-3+np.sqrt(1+8*s))/2
  */
 
@@ -7299,228 +5245,182 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   double __pyx_t_4;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("alm_getlmax", 0);
+  __Pyx_RefNannySetupContext("alm_getlmax");
 
-  /* "healpy/src/_sphtools.pyx":551
+  /* "healpy/src/_sphtools.pyx":456
  * cdef inline int alm_getlmax(int s):
  *     cdef double x
  *     x=(-3+np.sqrt(1+8*s))/2             # <<<<<<<<<<<<<<
  *     if x != floor(x):
  *         return -1
  */
-  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_sqrt); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__sqrt); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_long((1 + (8 * __pyx_v_s))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyInt_FromLong((1 + (8 * __pyx_v_s))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyNumber_Add(__pyx_int_neg_3, __pyx_t_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_t_3 = PyNumber_Add(__pyx_int_neg_3, __pyx_t_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyNumber_Divide(__pyx_t_3, __pyx_int_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyNumber_Divide(__pyx_t_3, __pyx_int_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_4 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_4 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_x = __pyx_t_4;
 
-  /* "healpy/src/_sphtools.pyx":552
+  /* "healpy/src/_sphtools.pyx":457
  *     cdef double x
  *     x=(-3+np.sqrt(1+8*s))/2
  *     if x != floor(x):             # <<<<<<<<<<<<<<
  *         return -1
  *     else:
  */
-  __pyx_t_5 = ((__pyx_v_x != floor(__pyx_v_x)) != 0);
+  __pyx_t_5 = (__pyx_v_x != floor(__pyx_v_x));
   if (__pyx_t_5) {
 
-    /* "healpy/src/_sphtools.pyx":553
+    /* "healpy/src/_sphtools.pyx":458
  *     x=(-3+np.sqrt(1+8*s))/2
  *     if x != floor(x):
  *         return -1             # <<<<<<<<<<<<<<
  *     else:
  *         return <int>floor(x)
  */
     __pyx_r = -1;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":555
+    /* "healpy/src/_sphtools.pyx":460
  *         return -1
  *     else:
  *         return <int>floor(x)             # <<<<<<<<<<<<<<
  * 
- * 
+ * @cython.cdivision(True)
  */
     __pyx_r = ((int)floor(__pyx_v_x));
     goto __pyx_L0;
   }
+  __pyx_L3:;
 
-  /* "healpy/src/_sphtools.pyx":549
- * 
- * @cython.cdivision(True)
- * cdef inline int alm_getlmax(int s):             # <<<<<<<<<<<<<<
- *     cdef double x
- *     x=(-3+np.sqrt(1+8*s))/2
- */
-
-  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_WriteUnraisable("healpy._sphtools.alm_getlmax", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
+  __Pyx_WriteUnraisable("healpy._sphtools.alm_getlmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":559
+/* "healpy/src/_sphtools.pyx":463
  * 
  * @cython.cdivision(True)
  * cdef inline int alm_getlmax2(int s, int mmax):             # <<<<<<<<<<<<<<
  *     cdef double x
  *     x = (2 * s + mmax ** 2 - mmax - 2.) / (2 * mmax + 2.)
  */
 
 static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getlmax2(int __pyx_v_s, int __pyx_v_mmax) {
   double __pyx_v_x;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("alm_getlmax2", 0);
+  __Pyx_RefNannySetupContext("alm_getlmax2");
 
-  /* "healpy/src/_sphtools.pyx":561
+  /* "healpy/src/_sphtools.pyx":465
  * cdef inline int alm_getlmax2(int s, int mmax):
  *     cdef double x
  *     x = (2 * s + mmax ** 2 - mmax - 2.) / (2 * mmax + 2.)             # <<<<<<<<<<<<<<
  *     if x != floor(x):
  *         return -1
  */
   __pyx_v_x = (((((2 * __pyx_v_s) + __Pyx_pow_long(((long)__pyx_v_mmax), 2)) - __pyx_v_mmax) - 2.) / ((2 * __pyx_v_mmax) + 2.));
 
-  /* "healpy/src/_sphtools.pyx":562
+  /* "healpy/src/_sphtools.pyx":466
  *     cdef double x
  *     x = (2 * s + mmax ** 2 - mmax - 2.) / (2 * mmax + 2.)
  *     if x != floor(x):             # <<<<<<<<<<<<<<
  *         return -1
  *     else:
  */
-  __pyx_t_1 = ((__pyx_v_x != floor(__pyx_v_x)) != 0);
+  __pyx_t_1 = (__pyx_v_x != floor(__pyx_v_x));
   if (__pyx_t_1) {
 
-    /* "healpy/src/_sphtools.pyx":563
+    /* "healpy/src/_sphtools.pyx":467
  *     x = (2 * s + mmax ** 2 - mmax - 2.) / (2 * mmax + 2.)
  *     if x != floor(x):
  *         return -1             # <<<<<<<<<<<<<<
  *     else:
  *         return <int>floor(x)
  */
     __pyx_r = -1;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":565
+    /* "healpy/src/_sphtools.pyx":469
  *         return -1
  *     else:
  *         return <int>floor(x)             # <<<<<<<<<<<<<<
  * 
- * 
+ * @cython.wraparound(False)
  */
     __pyx_r = ((int)floor(__pyx_v_x));
     goto __pyx_L0;
   }
+  __pyx_L3:;
 
-  /* "healpy/src/_sphtools.pyx":559
- * 
- * @cython.cdivision(True)
- * cdef inline int alm_getlmax2(int s, int mmax):             # <<<<<<<<<<<<<<
- *     cdef double x
- *     x = (2 * s + mmax ** 2 - mmax - 2.) / (2 * mmax + 2.)
- */
-
-  /* function exit code */
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "healpy/src/_sphtools.pyx":569
- * 
- * @cython.cdivision(True)
- * cdef inline int alm_getidx(int lmax, int l, int m):             # <<<<<<<<<<<<<<
- *     return m*(2*lmax+1-m)/2+l
- * 
- */
-
-static CYTHON_INLINE int __pyx_f_6healpy_9_sphtools_alm_getidx(int __pyx_v_lmax, int __pyx_v_l, int __pyx_v_m) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("alm_getidx", 0);
-
-  /* "healpy/src/_sphtools.pyx":570
- * @cython.cdivision(True)
- * cdef inline int alm_getidx(int lmax, int l, int m):
- *     return m*(2*lmax+1-m)/2+l             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = (((__pyx_v_m * (((2 * __pyx_v_lmax) + 1) - __pyx_v_m)) / 2) + __pyx_v_l);
-  goto __pyx_L0;
-
-  /* "healpy/src/_sphtools.pyx":569
- * 
- * @cython.cdivision(True)
- * cdef inline int alm_getidx(int lmax, int l, int m):             # <<<<<<<<<<<<<<
- *     return m*(2*lmax+1-m)/2+l
- * 
- */
-
-  /* function exit code */
+  __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":575
+/* "healpy/src/_sphtools.pyx":473
  * @cython.wraparound(False)
  * @cython.boundscheck(False)
  * cpdef mkmask(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
  *     cdef int nbad
  *     cdef int size = m.size
  */
 
-static PyObject *__pyx_pw_6healpy_9_sphtools_17mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
-static PyObject *__pyx_f_6healpy_9_sphtools_mkmask(PyArrayObject *__pyx_v_m, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pf_6healpy_9_sphtools_4mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
+static PyObject *__pyx_f_6healpy_9_sphtools_mkmask(PyArrayObject *__pyx_v_m, int __pyx_skip_dispatch) {
   int __pyx_v_nbad;
   int __pyx_v_size;
   int __pyx_v_i;
   PyArrayObject *__pyx_v_mask = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_m;
-  __Pyx_Buffer __pyx_pybuffer_m;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_mask;
-  __Pyx_Buffer __pyx_pybuffer_mask;
+  Py_buffer __pyx_bstruct_mask;
+  Py_ssize_t __pyx_bstride_0_mask = 0;
+  Py_ssize_t __pyx_bshape_0_mask = 0;
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
@@ -7532,734 +5432,458 @@
   PyObject *__pyx_t_11 = NULL;
   int __pyx_t_12;
   int __pyx_t_13;
   int __pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("mkmask", 0);
-  __pyx_pybuffer_mask.pybuffer.buf = NULL;
-  __pyx_pybuffer_mask.refcount = 0;
-  __pyx_pybuffernd_mask.data = NULL;
-  __pyx_pybuffernd_mask.rcbuffer = &__pyx_pybuffer_mask;
-  __pyx_pybuffer_m.pybuffer.buf = NULL;
-  __pyx_pybuffer_m.refcount = 0;
-  __pyx_pybuffernd_m.data = NULL;
-  __pyx_pybuffernd_m.rcbuffer = &__pyx_pybuffer_m;
+  __Pyx_RefNannySetupContext("mkmask");
+  __pyx_bstruct_mask.buf = NULL;
+  __pyx_bstruct_m.buf = NULL;
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_m.rcbuffer->pybuffer, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_pybuffernd_m.diminfo[0].strides = __pyx_pybuffernd_m.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_m.diminfo[0].shape = __pyx_pybuffernd_m.rcbuffer->pybuffer.shape[0];
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
 
-  /* "healpy/src/_sphtools.pyx":577
+  /* "healpy/src/_sphtools.pyx":475
  * cpdef mkmask(np.ndarray[double, ndim=1] m):
  *     cdef int nbad
  *     cdef int size = m.size             # <<<<<<<<<<<<<<
  *     cdef int i
  *     # first, count number of bad pixels, to see if allocating a mask is needed
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_m), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_m), __pyx_n_s__size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_size = __pyx_t_2;
 
-  /* "healpy/src/_sphtools.pyx":580
+  /* "healpy/src/_sphtools.pyx":478
  *     cdef int i
  *     # first, count number of bad pixels, to see if allocating a mask is needed
  *     nbad = count_bad(m)             # <<<<<<<<<<<<<<
  *     cdef np.ndarray[np.int8_t, ndim=1] mask
  *     #cdef np.ndarray[double, ndim=1] m_
  */
   __pyx_v_nbad = __pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_m), 0);
 
-  /* "healpy/src/_sphtools.pyx":583
+  /* "healpy/src/_sphtools.pyx":481
  *     cdef np.ndarray[np.int8_t, ndim=1] mask
  *     #cdef np.ndarray[double, ndim=1] m_
  *     if nbad == 0:             # <<<<<<<<<<<<<<
  *         return False
  *     else:
  */
-  __pyx_t_3 = ((__pyx_v_nbad == 0) != 0);
+  __pyx_t_3 = (__pyx_v_nbad == 0);
   if (__pyx_t_3) {
 
-    /* "healpy/src/_sphtools.pyx":584
+    /* "healpy/src/_sphtools.pyx":482
  *     #cdef np.ndarray[double, ndim=1] m_
  *     if nbad == 0:
  *         return False             # <<<<<<<<<<<<<<
  *     else:
  *         mask = np.zeros(size, dtype = np.int8)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(Py_False);
-    __pyx_r = Py_False;
+    __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "healpy/src/_sphtools.pyx":586
+    /* "healpy/src/_sphtools.pyx":484
  *         return False
  *     else:
  *         mask = np.zeros(size, dtype = np.int8)             # <<<<<<<<<<<<<<
  *         #m_ = m
  *         for i in range(size):
  */
-    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__zeros); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = PyInt_FromLong(__pyx_v_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_5));
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_1);
     __pyx_t_1 = 0;
-    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __pyx_t_6 = __Pyx_GetName(__pyx_m, __pyx_n_s__np); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_int8); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = PyObject_GetAttr(__pyx_t_6, __pyx_n_s__int8); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__dtype), __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = PyEval_CallObjectWithKeywords(__pyx_t_4, ((PyObject *)__pyx_t_5), ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (!(likely(((__pyx_t_7) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_7, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    if (!(likely(((__pyx_t_7) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_7, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __pyx_t_8 = ((PyArrayObject *)__pyx_t_7);
     {
       __Pyx_BufFmt_StackElem __pyx_stack[1];
-      __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_mask.rcbuffer->pybuffer);
-      __pyx_t_2 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_mask.rcbuffer->pybuffer, (PyObject*)__pyx_t_8, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
+      __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mask);
+      __pyx_t_2 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_mask, (PyObject*)__pyx_t_8, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
       if (unlikely(__pyx_t_2 < 0)) {
         PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
-        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_mask.rcbuffer->pybuffer, (PyObject*)__pyx_v_mask, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mask, (PyObject*)__pyx_v_mask, &__Pyx_TypeInfo_nn___pyx_t_5numpy_int8_t, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
           Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
           __Pyx_RaiseBufferFallbackError();
         } else {
           PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
         }
       }
-      __pyx_pybuffernd_mask.diminfo[0].strides = __pyx_pybuffernd_mask.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_mask.diminfo[0].shape = __pyx_pybuffernd_mask.rcbuffer->pybuffer.shape[0];
-      if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_bstride_0_mask = __pyx_bstruct_mask.strides[0];
+      __pyx_bshape_0_mask = __pyx_bstruct_mask.shape[0];
+      if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
     __pyx_t_8 = 0;
     __pyx_v_mask = ((PyArrayObject *)__pyx_t_7);
     __pyx_t_7 = 0;
 
-    /* "healpy/src/_sphtools.pyx":588
+    /* "healpy/src/_sphtools.pyx":486
  *         mask = np.zeros(size, dtype = np.int8)
  *         #m_ = m
  *         for i in range(size):             # <<<<<<<<<<<<<<
  *             if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *                 mask[i] = 1
  */
     __pyx_t_2 = __pyx_v_size;
     for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_2; __pyx_t_12+=1) {
       __pyx_v_i = __pyx_t_12;
 
-      /* "healpy/src/_sphtools.pyx":589
+      /* "healpy/src/_sphtools.pyx":487
  *         #m_ = m
  *         for i in range(size):
  *             if fabs(m[i] - UNSEEN) < rtol_UNSEEN:             # <<<<<<<<<<<<<<
  *                 mask[i] = 1
  *     mask.dtype = bool
  */
       __pyx_t_13 = __pyx_v_i;
-      __pyx_t_3 = ((fabs(((*__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_m.rcbuffer->pybuffer.buf, __pyx_t_13, __pyx_pybuffernd_m.diminfo[0].strides)) - __pyx_v_6healpy_9_sphtools_UNSEEN)) < __pyx_v_6healpy_9_sphtools_rtol_UNSEEN) != 0);
+      __pyx_t_3 = (fabs(((*__Pyx_BufPtrStrided1d(double *, __pyx_bstruct_m.buf, __pyx_t_13, __pyx_bstride_0_m)) - __pyx_v_6healpy_9_sphtools_UNSEEN)) < __pyx_v_6healpy_9_sphtools_rtol_UNSEEN);
       if (__pyx_t_3) {
 
-        /* "healpy/src/_sphtools.pyx":590
+        /* "healpy/src/_sphtools.pyx":488
  *         for i in range(size):
  *             if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *                 mask[i] = 1             # <<<<<<<<<<<<<<
  *     mask.dtype = bool
  *     return mask
  */
         __pyx_t_14 = __pyx_v_i;
-        *__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int8_t *, __pyx_pybuffernd_mask.rcbuffer->pybuffer.buf, __pyx_t_14, __pyx_pybuffernd_mask.diminfo[0].strides) = 1;
+        *__Pyx_BufPtrStrided1d(__pyx_t_5numpy_int8_t *, __pyx_bstruct_mask.buf, __pyx_t_14, __pyx_bstride_0_mask) = 1;
         goto __pyx_L6;
       }
       __pyx_L6:;
     }
   }
+  __pyx_L3:;
 
-  /* "healpy/src/_sphtools.pyx":591
+  /* "healpy/src/_sphtools.pyx":489
  *             if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *                 mask[i] = 1
  *     mask.dtype = bool             # <<<<<<<<<<<<<<
  *     return mask
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_mask), __pyx_n_s_dtype, ((PyObject*)&PyBool_Type)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(((PyObject *)__pyx_v_mask), __pyx_n_s__dtype, ((PyObject*)&PyBool_Type)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 489; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-  /* "healpy/src/_sphtools.pyx":592
+  /* "healpy/src/_sphtools.pyx":490
  *                 mask[i] = 1
  *     mask.dtype = bool
  *     return mask             # <<<<<<<<<<<<<<
  * 
  * @cython.wraparound(False)
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_mask));
   __pyx_r = ((PyObject *)__pyx_v_mask);
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":575
- * @cython.wraparound(False)
- * @cython.boundscheck(False)
- * cpdef mkmask(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
- *     cdef int nbad
- *     cdef int size = m.size
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_mask.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mask);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.mkmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_mask.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mask);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_mask);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_17mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
-static PyObject *__pyx_pw_6healpy_9_sphtools_17mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m) {
-  CYTHON_UNUSED int __pyx_lineno = 0;
-  CYTHON_UNUSED const char *__pyx_filename = NULL;
-  CYTHON_UNUSED int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("mkmask (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_16mkmask(__pyx_self, ((PyArrayObject *)__pyx_v_m));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
+/* "healpy/src/_sphtools.pyx":473
+ * @cython.wraparound(False)
+ * @cython.boundscheck(False)
+ * cpdef mkmask(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
+ *     cdef int nbad
+ *     cdef int size = m.size
+ */
 
-static PyObject *__pyx_pf_6healpy_9_sphtools_16mkmask(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_m) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_m;
-  __Pyx_Buffer __pyx_pybuffer_m;
+static PyObject *__pyx_pf_6healpy_9_sphtools_4mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_4mkmask[] = "mkmask(ndarray m)";
+static PyObject *__pyx_pf_6healpy_9_sphtools_4mkmask(PyObject *__pyx_self, PyObject *__pyx_v_m) {
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("mkmask", 0);
-  __pyx_pybuffer_m.pybuffer.buf = NULL;
-  __pyx_pybuffer_m.refcount = 0;
-  __pyx_pybuffernd_m.data = NULL;
-  __pyx_pybuffernd_m.rcbuffer = &__pyx_pybuffer_m;
+  __Pyx_RefNannySetupContext("mkmask");
+  __pyx_self = __pyx_self;
+  __pyx_bstruct_m.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_m.rcbuffer->pybuffer, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_pybuffernd_m.diminfo[0].strides = __pyx_pybuffernd_m.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_m.diminfo[0].shape = __pyx_pybuffernd_m.rcbuffer->pybuffer.shape[0];
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(__pyx_v_m, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_f_6healpy_9_sphtools_mkmask(((PyArrayObject *)__pyx_v_m), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.mkmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __pyx_L2:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "healpy/src/_sphtools.pyx":596
+/* "healpy/src/_sphtools.pyx":494
  * @cython.wraparound(False)
  * @cython.boundscheck(False)
  * cpdef int count_bad(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef int nbad = 0
  */
 
-static PyObject *__pyx_pw_6healpy_9_sphtools_19count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
-static int __pyx_f_6healpy_9_sphtools_count_bad(PyArrayObject *__pyx_v_m, CYTHON_UNUSED int __pyx_skip_dispatch) {
+static PyObject *__pyx_pf_6healpy_9_sphtools_5count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
+static int __pyx_f_6healpy_9_sphtools_count_bad(PyArrayObject *__pyx_v_m, int __pyx_skip_dispatch) {
   int __pyx_v_i;
   int __pyx_v_nbad;
-  CYTHON_UNUSED PyObject *__pyx_v_size = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_m;
-  __Pyx_Buffer __pyx_pybuffer_m;
+  PyObject *__pyx_v_size = 0;
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   long __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("count_bad", 0);
-  __pyx_pybuffer_m.pybuffer.buf = NULL;
-  __pyx_pybuffer_m.refcount = 0;
-  __pyx_pybuffernd_m.data = NULL;
-  __pyx_pybuffernd_m.rcbuffer = &__pyx_pybuffer_m;
+  __Pyx_RefNannySetupContext("count_bad");
+  __pyx_bstruct_m.buf = NULL;
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_m.rcbuffer->pybuffer, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_pybuffernd_m.diminfo[0].strides = __pyx_pybuffernd_m.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_m.diminfo[0].shape = __pyx_pybuffernd_m.rcbuffer->pybuffer.shape[0];
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
 
-  /* "healpy/src/_sphtools.pyx":598
+  /* "healpy/src/_sphtools.pyx":496
  * cpdef int count_bad(np.ndarray[double, ndim=1] m):
  *     cdef int i
  *     cdef int nbad = 0             # <<<<<<<<<<<<<<
  *     cdef size = m.size
  *     for i in xrange(m.size):
  */
   __pyx_v_nbad = 0;
 
-  /* "healpy/src/_sphtools.pyx":599
+  /* "healpy/src/_sphtools.pyx":497
  *     cdef int i
  *     cdef int nbad = 0
  *     cdef size = m.size             # <<<<<<<<<<<<<<
  *     for i in xrange(m.size):
  *         if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_m), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 599; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_m), __pyx_n_s__size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_size = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":600
+  /* "healpy/src/_sphtools.pyx":498
  *     cdef int nbad = 0
  *     cdef size = m.size
  *     for i in xrange(m.size):             # <<<<<<<<<<<<<<
  *         if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *             nbad += 1
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_m), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_m), __pyx_n_s__size); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 498; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyInt_As_long(__pyx_t_1); if (unlikely((__pyx_t_2 == (long)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyInt_AsLong(__pyx_t_1); if (unlikely((__pyx_t_2 == (long)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 498; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "healpy/src/_sphtools.pyx":601
+    /* "healpy/src/_sphtools.pyx":499
  *     cdef size = m.size
  *     for i in xrange(m.size):
  *         if fabs(m[i] - UNSEEN) < rtol_UNSEEN:             # <<<<<<<<<<<<<<
  *             nbad += 1
  *     return nbad
  */
     __pyx_t_4 = __pyx_v_i;
-    __pyx_t_5 = ((fabs(((*__Pyx_BufPtrStrided1d(double *, __pyx_pybuffernd_m.rcbuffer->pybuffer.buf, __pyx_t_4, __pyx_pybuffernd_m.diminfo[0].strides)) - __pyx_v_6healpy_9_sphtools_UNSEEN)) < __pyx_v_6healpy_9_sphtools_rtol_UNSEEN) != 0);
+    __pyx_t_5 = (fabs(((*__Pyx_BufPtrStrided1d(double *, __pyx_bstruct_m.buf, __pyx_t_4, __pyx_bstride_0_m)) - __pyx_v_6healpy_9_sphtools_UNSEEN)) < __pyx_v_6healpy_9_sphtools_rtol_UNSEEN);
     if (__pyx_t_5) {
 
-      /* "healpy/src/_sphtools.pyx":602
+      /* "healpy/src/_sphtools.pyx":500
  *     for i in xrange(m.size):
  *         if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *             nbad += 1             # <<<<<<<<<<<<<<
  *     return nbad
+ * 
  */
       __pyx_v_nbad = (__pyx_v_nbad + 1);
       goto __pyx_L5;
     }
     __pyx_L5:;
   }
 
-  /* "healpy/src/_sphtools.pyx":603
+  /* "healpy/src/_sphtools.pyx":501
  *         if fabs(m[i] - UNSEEN) < rtol_UNSEEN:
  *             nbad += 1
  *     return nbad             # <<<<<<<<<<<<<<
+ * 
  */
   __pyx_r = __pyx_v_nbad;
   goto __pyx_L0;
 
-  /* "healpy/src/_sphtools.pyx":596
- * @cython.wraparound(False)
- * @cython.boundscheck(False)
- * cpdef int count_bad(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
- *     cdef int i
- *     cdef int nbad = 0
- */
-
-  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_WriteUnraisable("healpy._sphtools.count_bad", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
+  __Pyx_WriteUnraisable("healpy._sphtools.count_bad", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __pyx_L2:;
   __Pyx_XDECREF(__pyx_v_size);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* Python wrapper */
-static PyObject *__pyx_pw_6healpy_9_sphtools_19count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
-static PyObject *__pyx_pw_6healpy_9_sphtools_19count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m) {
-  CYTHON_UNUSED int __pyx_lineno = 0;
-  CYTHON_UNUSED const char *__pyx_filename = NULL;
-  CYTHON_UNUSED int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("count_bad (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_r = __pyx_pf_6healpy_9_sphtools_18count_bad(__pyx_self, ((PyArrayObject *)__pyx_v_m));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
+/* "healpy/src/_sphtools.pyx":494
+ * @cython.wraparound(False)
+ * @cython.boundscheck(False)
+ * cpdef int count_bad(np.ndarray[double, ndim=1] m):             # <<<<<<<<<<<<<<
+ *     cdef int i
+ *     cdef int nbad = 0
+ */
 
-static PyObject *__pyx_pf_6healpy_9_sphtools_18count_bad(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_m) {
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_m;
-  __Pyx_Buffer __pyx_pybuffer_m;
+static PyObject *__pyx_pf_6healpy_9_sphtools_5count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
+static char __pyx_doc_6healpy_9_sphtools_5count_bad[] = "count_bad(ndarray m) -> int";
+static PyObject *__pyx_pf_6healpy_9_sphtools_5count_bad(PyObject *__pyx_self, PyObject *__pyx_v_m) {
+  Py_buffer __pyx_bstruct_m;
+  Py_ssize_t __pyx_bstride_0_m = 0;
+  Py_ssize_t __pyx_bshape_0_m = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("count_bad", 0);
-  __pyx_pybuffer_m.pybuffer.buf = NULL;
-  __pyx_pybuffer_m.refcount = 0;
-  __pyx_pybuffernd_m.data = NULL;
-  __pyx_pybuffernd_m.rcbuffer = &__pyx_pybuffer_m;
+  __Pyx_RefNannySetupContext("count_bad");
+  __pyx_self = __pyx_self;
+  __pyx_bstruct_m.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_m), __pyx_ptype_5numpy_ndarray, 1, "m", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_m.rcbuffer->pybuffer, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_m, (PyObject*)__pyx_v_m, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_pybuffernd_m.diminfo[0].strides = __pyx_pybuffernd_m.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_m.diminfo[0].shape = __pyx_pybuffernd_m.rcbuffer->pybuffer.shape[0];
+  __pyx_bstride_0_m = __pyx_bstruct_m.strides[0];
+  __pyx_bshape_0_m = __pyx_bstruct_m.shape[0];
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_6healpy_9_sphtools_count_bad(__pyx_v_m, 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyInt_FromLong(__pyx_f_6healpy_9_sphtools_count_bad(((PyArrayObject *)__pyx_v_m), 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
     __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("healpy._sphtools.count_bad", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_m.rcbuffer->pybuffer);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_m);
   __pyx_L2:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "_common.pxd":124
- *         tsize Num_Alms (int l, int m)
- * 
- * cdef inline Healpix_Map[double]* ndarray2map(np.ndarray[np.float64_t, ndim=1, mode='c'] array, Healpix_Ordering_Scheme scheme) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as a Healpix Map. """
- *     # To ensure that the output map is a view of the input array, the latter
- */
-
-static CYTHON_INLINE Healpix_Map<double> *__pyx_f_7_common_ndarray2map(PyArrayObject *__pyx_v_array, enum Healpix_Ordering_Scheme __pyx_v_scheme) {
-  arr<double> *__pyx_v_a;
-  Healpix_Map<double> *__pyx_v_map;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_array;
-  __Pyx_Buffer __pyx_pybuffer_array;
-  Healpix_Map<double> *__pyx_r;
-  __Pyx_RefNannyDeclarations
-  long __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  size_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ndarray2map", 0);
-  __pyx_pybuffer_array.pybuffer.buf = NULL;
-  __pyx_pybuffer_array.refcount = 0;
-  __pyx_pybuffernd_array.data = NULL;
-  __pyx_pybuffernd_array.rcbuffer = &__pyx_pybuffer_array;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_array.rcbuffer->pybuffer, (PyObject*)__pyx_v_array, &__Pyx_TypeInfo_nn___pyx_t_5numpy_float64_t, PyBUF_FORMAT| PyBUF_C_CONTIGUOUS, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_pybuffernd_array.diminfo[0].strides = __pyx_pybuffernd_array.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_array.diminfo[0].shape = __pyx_pybuffernd_array.rcbuffer->pybuffer.shape[0];
-
-  /* "_common.pxd":129
- *     # is forced to be contiguous, of correct type and dimensions (otherwise, an
- *     # exception is raised).
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)             # <<<<<<<<<<<<<<
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)
- */
-  __pyx_t_1 = 0;
-  __pyx_t_2 = -1;
-  if (__pyx_t_1 < 0) {
-    __pyx_t_1 += __pyx_pybuffernd_array.diminfo[0].shape;
-    if (unlikely(__pyx_t_1 < 0)) __pyx_t_2 = 0;
-  } else if (unlikely(__pyx_t_1 >= __pyx_pybuffernd_array.diminfo[0].shape)) __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_2 != -1)) {
-    __Pyx_RaiseBufferIndexError(__pyx_t_2);
-    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_array), __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_size_t(__pyx_t_3); if (unlikely((__pyx_t_4 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_a = new arr<double>((&(*__Pyx_BufPtrCContig1d(__pyx_t_5numpy_float64_t *, __pyx_pybuffernd_array.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_array.diminfo[0].strides))), __pyx_t_4);
-
-  /* "_common.pxd":130
- *     # exception is raised).
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()             # <<<<<<<<<<<<<<
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated
- */
-  __pyx_v_map = new Healpix_Map<double>();
-
-  /* "_common.pxd":131
- *     cdef arr[double] *a = new arr[double](&array[0], array.size)
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)             # <<<<<<<<<<<<<<
- *     del a # a does not own its buffer, so it won't be deallocated
- *     return map
- */
-  __pyx_v_map->Set((__pyx_v_a[0]), __pyx_v_scheme);
-
-  /* "_common.pxd":132
- *     cdef Healpix_Map[double] *map = new Healpix_Map[double]()
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated             # <<<<<<<<<<<<<<
- *     return map
- * 
- */
-  delete __pyx_v_a;
-
-  /* "_common.pxd":133
- *     map.Set(a[0], scheme)
- *     del a # a does not own its buffer, so it won't be deallocated
- *     return map             # <<<<<<<<<<<<<<
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:
- */
-  __pyx_r = __pyx_v_map;
-  goto __pyx_L0;
-
-  /* "_common.pxd":124
- *         tsize Num_Alms (int l, int m)
- * 
- * cdef inline Healpix_Map[double]* ndarray2map(np.ndarray[np.float64_t, ndim=1, mode='c'] array, Healpix_Ordering_Scheme scheme) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as a Healpix Map. """
- *     # To ensure that the output map is a view of the input array, the latter
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("_common.ndarray2map", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "_common.pxd":135
- *     return map
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- */
-
-static CYTHON_INLINE Alm<xcomplex<double> > *__pyx_f_7_common_ndarray2alm(PyArrayObject *__pyx_v_array, int __pyx_v_lmax, int __pyx_v_mmax) {
-  arr<xcomplex<double> > *__pyx_v_a;
-  Alm<xcomplex<double> > *__pyx_v_alm;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_array;
-  __Pyx_Buffer __pyx_pybuffer_array;
-  Alm<xcomplex<double> > *__pyx_r;
-  __Pyx_RefNannyDeclarations
-  long __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  size_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("ndarray2alm", 0);
-  __pyx_pybuffer_array.pybuffer.buf = NULL;
-  __pyx_pybuffer_array.refcount = 0;
-  __pyx_pybuffernd_array.data = NULL;
-  __pyx_pybuffernd_array.rcbuffer = &__pyx_pybuffer_array;
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_array.rcbuffer->pybuffer, (PyObject*)__pyx_v_array, &__Pyx_TypeInfo___pyx_t_double_complex, PyBUF_FORMAT| PyBUF_C_CONTIGUOUS, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_pybuffernd_array.diminfo[0].strides = __pyx_pybuffernd_array.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_array.diminfo[0].shape = __pyx_pybuffernd_array.rcbuffer->pybuffer.shape[0];
-
-  /* "_common.pxd":137
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)             # <<<<<<<<<<<<<<
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)
- */
-  __pyx_t_1 = 0;
-  __pyx_t_2 = -1;
-  if (__pyx_t_1 < 0) {
-    __pyx_t_1 += __pyx_pybuffernd_array.diminfo[0].shape;
-    if (unlikely(__pyx_t_1 < 0)) __pyx_t_2 = 0;
-  } else if (unlikely(__pyx_t_1 >= __pyx_pybuffernd_array.diminfo[0].shape)) __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_2 != -1)) {
-    __Pyx_RaiseBufferIndexError(__pyx_t_2);
-    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_array), __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_size_t(__pyx_t_3); if (unlikely((__pyx_t_4 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_a = new arr<xcomplex<double> >(((xcomplex<double> *)(&(*__Pyx_BufPtrCContig1d(__pyx_t_double_complex *, __pyx_pybuffernd_array.rcbuffer->pybuffer.buf, __pyx_t_1, __pyx_pybuffernd_array.diminfo[0].strides)))), __pyx_t_4);
-
-  /* "_common.pxd":138
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()             # <<<<<<<<<<<<<<
- *     alm.Set(a[0], lmax, mmax)
- *     del a
- */
-  __pyx_v_alm = new Alm<xcomplex<double> >();
-
-  /* "_common.pxd":139
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)             # <<<<<<<<<<<<<<
- *     del a
- *     return alm
- */
-  __pyx_v_alm->Set((__pyx_v_a[0]), __pyx_v_lmax, __pyx_v_mmax);
-
-  /* "_common.pxd":140
- *     cdef Alm[xcomplex[double]] *alm = new Alm[xcomplex[double]]()
- *     alm.Set(a[0], lmax, mmax)
- *     del a             # <<<<<<<<<<<<<<
- *     return alm
- */
-  delete __pyx_v_a;
-
-  /* "_common.pxd":141
- *     alm.Set(a[0], lmax, mmax)
- *     del a
- *     return alm             # <<<<<<<<<<<<<<
- */
-  __pyx_r = __pyx_v_alm;
-  goto __pyx_L0;
-
-  /* "_common.pxd":135
- *     return map
- * 
- * cdef inline Alm[xcomplex[double]]* ndarray2alm(np.ndarray[np.complex128_t, ndim=1, mode='c'] array, int lmax, int mmax) except *:             # <<<<<<<<<<<<<<
- *     """ View a contiguous ndarray as an Alm. """
- *     cdef arr[xcomplex[double]] *a = new arr[xcomplex[double]](<xcomplex[double]*>&array[0], array.size)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("_common.ndarray2alm", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_array.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":194
+/* "numpy.pxd":190
  *         # experimental exception made for __getbuffer__ and __releasebuffer__
  *         # -- the details of this may change.
  *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
  *             # This implementation of getbuffer is geared towards Cython
  *             # requirements, and does not yet fullfill the PEP.
  */
 
-/* Python wrapper */
-static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_5numpy_7ndarray___getbuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
+static CYTHON_UNUSED int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_v_copy_shape;
   int __pyx_v_i;
   int __pyx_v_ndim;
   int __pyx_v_endian_detector;
   int __pyx_v_little_endian;
   int __pyx_v_t;
   char *__pyx_v_f;
@@ -8276,741 +5900,763 @@
   int __pyx_t_6;
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   char *__pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__getbuffer__", 0);
+  __Pyx_RefNannySetupContext("__getbuffer__");
   if (__pyx_v_info != NULL) {
     __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(__pyx_v_info->obj);
   }
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":200
+  /* "numpy.pxd":196
  *             # of flags
  * 
  *             if info == NULL: return             # <<<<<<<<<<<<<<
  * 
  *             cdef int copy_shape, i, ndim
  */
-  __pyx_t_1 = ((__pyx_v_info == NULL) != 0);
+  __pyx_t_1 = (__pyx_v_info == NULL);
   if (__pyx_t_1) {
     __pyx_r = 0;
     goto __pyx_L0;
+    goto __pyx_L5;
   }
+  __pyx_L5:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":203
+  /* "numpy.pxd":199
  * 
  *             cdef int copy_shape, i, ndim
  *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  */
   __pyx_v_endian_detector = 1;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":204
+  /* "numpy.pxd":200
  *             cdef int copy_shape, i, ndim
  *             cdef int endian_detector = 1
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  * 
  *             ndim = PyArray_NDIM(self)
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":206
+  /* "numpy.pxd":202
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
-  __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);
+  __pyx_v_ndim = PyArray_NDIM(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":208
+  /* "numpy.pxd":204
  *             ndim = PyArray_NDIM(self)
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 copy_shape = 1
  *             else:
  */
-  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
+  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":209
+    /* "numpy.pxd":205
  * 
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 copy_shape = 1             # <<<<<<<<<<<<<<
  *             else:
  *                 copy_shape = 0
  */
     __pyx_v_copy_shape = 1;
-    goto __pyx_L4;
+    goto __pyx_L6;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":211
+    /* "numpy.pxd":207
  *                 copy_shape = 1
  *             else:
  *                 copy_shape = 0             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  */
     __pyx_v_copy_shape = 0;
   }
-  __pyx_L4:;
+  __pyx_L6:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":213
+  /* "numpy.pxd":209
  *                 copy_shape = 0
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")
  */
-  __pyx_t_1 = (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS) != 0);
+  __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":214
+    /* "numpy.pxd":210
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  */
-    __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_C_CONTIGUOUS) != 0)) != 0);
+    __pyx_t_2 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_C_CONTIGUOUS));
     __pyx_t_3 = __pyx_t_2;
   } else {
     __pyx_t_3 = __pyx_t_1;
   }
   if (__pyx_t_3) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":215
+    /* "numpy.pxd":211
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_24), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L7;
   }
+  __pyx_L7:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":217
+  /* "numpy.pxd":213
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  */
-  __pyx_t_3 = (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS) != 0);
+  __pyx_t_3 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);
   if (__pyx_t_3) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":218
+    /* "numpy.pxd":214
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  */
-    __pyx_t_1 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_F_CONTIGUOUS) != 0)) != 0);
+    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_F_CONTIGUOUS));
     __pyx_t_2 = __pyx_t_1;
   } else {
     __pyx_t_2 = __pyx_t_3;
   }
   if (__pyx_t_2) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":219
+    /* "numpy.pxd":215
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_26), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L8;
   }
+  __pyx_L8:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":221
+  /* "numpy.pxd":217
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
  *             info.ndim = ndim
  *             if copy_shape:
  */
-  __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);
+  __pyx_v_info->buf = PyArray_DATA(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":222
+  /* "numpy.pxd":218
  * 
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim             # <<<<<<<<<<<<<<
  *             if copy_shape:
  *                 # Allocate new buffer for strides and shape info.
  */
   __pyx_v_info->ndim = __pyx_v_ndim;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":223
+  /* "numpy.pxd":219
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim
  *             if copy_shape:             # <<<<<<<<<<<<<<
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  */
-  __pyx_t_2 = (__pyx_v_copy_shape != 0);
-  if (__pyx_t_2) {
+  if (__pyx_v_copy_shape) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":226
+    /* "numpy.pxd":222
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)             # <<<<<<<<<<<<<<
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  */
     __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * ((size_t)__pyx_v_ndim)) * 2)));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":227
+    /* "numpy.pxd":223
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
  *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  */
     __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":228
+    /* "numpy.pxd":224
  *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):             # <<<<<<<<<<<<<<
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  */
     __pyx_t_5 = __pyx_v_ndim;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_i = __pyx_t_6;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":229
+      /* "numpy.pxd":225
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  */
-      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);
+      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":230
+      /* "numpy.pxd":226
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  */
-      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
+      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
     }
-    goto __pyx_L7;
+    goto __pyx_L9;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":232
+    /* "numpy.pxd":228
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  */
-    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));
+    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(((PyArrayObject *)__pyx_v_self)));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":233
+    /* "numpy.pxd":229
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  */
-    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
+    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(((PyArrayObject *)__pyx_v_self)));
   }
-  __pyx_L7:;
+  __pyx_L9:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":234
+  /* "numpy.pxd":230
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":235
+  /* "numpy.pxd":231
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  * 
  */
-  __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);
+  __pyx_v_info->itemsize = PyArray_ITEMSIZE(((PyArrayObject *)__pyx_v_self));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":236
+  /* "numpy.pxd":232
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
  * 
  *             cdef int t
  */
-  __pyx_v_info->readonly = (!(PyArray_ISWRITEABLE(__pyx_v_self) != 0));
+  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(((PyArrayObject *)__pyx_v_self)));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":239
+  /* "numpy.pxd":235
  * 
  *             cdef int t
  *             cdef char* f = NULL             # <<<<<<<<<<<<<<
  *             cdef dtype descr = self.descr
  *             cdef list stack
  */
   __pyx_v_f = NULL;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":240
+  /* "numpy.pxd":236
  *             cdef int t
  *             cdef char* f = NULL
  *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
  *             cdef list stack
  *             cdef int offset
  */
-  __pyx_t_4 = ((PyObject *)__pyx_v_self->descr);
-  __Pyx_INCREF(__pyx_t_4);
-  __pyx_v_descr = ((PyArray_Descr *)__pyx_t_4);
-  __pyx_t_4 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_v_self)->descr));
+  __pyx_v_descr = ((PyArrayObject *)__pyx_v_self)->descr;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":244
+  /* "numpy.pxd":240
  *             cdef int offset
  * 
  *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
  * 
  *             if not hasfields and not copy_shape:
  */
   __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":246
+  /* "numpy.pxd":242
  *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
  * 
  *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
  *                 # do not call releasebuffer
  *                 info.obj = None
  */
-  __pyx_t_2 = ((!(__pyx_v_hasfields != 0)) != 0);
+  __pyx_t_2 = (!__pyx_v_hasfields);
   if (__pyx_t_2) {
-    __pyx_t_3 = ((!(__pyx_v_copy_shape != 0)) != 0);
+    __pyx_t_3 = (!__pyx_v_copy_shape);
     __pyx_t_1 = __pyx_t_3;
   } else {
     __pyx_t_1 = __pyx_t_2;
   }
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":248
+    /* "numpy.pxd":244
  *             if not hasfields and not copy_shape:
  *                 # do not call releasebuffer
  *                 info.obj = None             # <<<<<<<<<<<<<<
  *             else:
  *                 # need to call releasebuffer
  */
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj);
     __pyx_v_info->obj = Py_None;
-    goto __pyx_L10;
+    goto __pyx_L12;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":251
+    /* "numpy.pxd":247
  *             else:
  *                 # need to call releasebuffer
  *                 info.obj = self             # <<<<<<<<<<<<<<
  * 
  *             if not hasfields:
  */
-    __Pyx_INCREF(((PyObject *)__pyx_v_self));
-    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
+    __Pyx_INCREF(__pyx_v_self);
+    __Pyx_GIVEREF(__pyx_v_self);
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj);
-    __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
+    __pyx_v_info->obj = __pyx_v_self;
   }
-  __pyx_L10:;
+  __pyx_L12:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":253
+  /* "numpy.pxd":249
  *                 info.obj = self
  * 
  *             if not hasfields:             # <<<<<<<<<<<<<<
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or
+ *                 if ((descr.byteorder == '>' and little_endian) or
  */
-  __pyx_t_1 = ((!(__pyx_v_hasfields != 0)) != 0);
+  __pyx_t_1 = (!__pyx_v_hasfields);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":254
+    /* "numpy.pxd":250
  * 
  *             if not hasfields:
  *                 t = descr.type_num             # <<<<<<<<<<<<<<
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  */
-    __pyx_t_5 = __pyx_v_descr->type_num;
-    __pyx_v_t = __pyx_t_5;
+    __pyx_v_t = __pyx_v_descr->type_num;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":255
+    /* "numpy.pxd":251
  *             if not hasfields:
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
- *                     (descr.byteorder == c'<' and not little_endian)):
+ *                 if ((descr.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  */
-    __pyx_t_1 = ((__pyx_v_descr->byteorder == '>') != 0);
+    __pyx_t_1 = (__pyx_v_descr->byteorder == '>');
     if (__pyx_t_1) {
-      __pyx_t_2 = (__pyx_v_little_endian != 0);
+      __pyx_t_2 = __pyx_v_little_endian;
     } else {
       __pyx_t_2 = __pyx_t_1;
     }
     if (!__pyx_t_2) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":256
+      /* "numpy.pxd":252
  *                 t = descr.type_num
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  */
-      __pyx_t_1 = ((__pyx_v_descr->byteorder == '<') != 0);
+      __pyx_t_1 = (__pyx_v_descr->byteorder == '<');
       if (__pyx_t_1) {
-        __pyx_t_3 = ((!(__pyx_v_little_endian != 0)) != 0);
+        __pyx_t_3 = (!__pyx_v_little_endian);
         __pyx_t_7 = __pyx_t_3;
       } else {
         __pyx_t_7 = __pyx_t_1;
       }
       __pyx_t_1 = __pyx_t_7;
     } else {
       __pyx_t_1 = __pyx_t_2;
     }
     if (__pyx_t_1) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":257
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+      /* "numpy.pxd":253
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_28), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L14;
     }
+    __pyx_L14:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
- *                 elif t == NPY_CDOUBLE:     f = "Zd"
- *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
- *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
- *                 else:
- *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
- */
-    switch (__pyx_v_t) {
-
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":258
- *                     (descr.byteorder == c'<' and not little_endian)):
+    /* "numpy.pxd":254
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  */
-      case NPY_BYTE:
-      __pyx_v_f = __pyx_k_b;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_BYTE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__b;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":259
+    /* "numpy.pxd":255
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  */
-      case NPY_UBYTE:
-      __pyx_v_f = __pyx_k_B;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_UBYTE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__B;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":260
+    /* "numpy.pxd":256
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  */
-      case NPY_SHORT:
-      __pyx_v_f = __pyx_k_h;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_SHORT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__h;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":261
+    /* "numpy.pxd":257
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  */
-      case NPY_USHORT:
-      __pyx_v_f = __pyx_k_H;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_USHORT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__H;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":262
+    /* "numpy.pxd":258
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  */
-      case NPY_INT:
-      __pyx_v_f = __pyx_k_i;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_INT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__i;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":263
+    /* "numpy.pxd":259
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  */
-      case NPY_UINT:
-      __pyx_v_f = __pyx_k_I;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_UINT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__I;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":264
+    /* "numpy.pxd":260
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  */
-      case NPY_LONG:
-      __pyx_v_f = __pyx_k_l;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__l;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":265
+    /* "numpy.pxd":261
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  */
-      case NPY_ULONG:
-      __pyx_v_f = __pyx_k_L;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_ULONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__L;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":266
+    /* "numpy.pxd":262
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  */
-      case NPY_LONGLONG:
-      __pyx_v_f = __pyx_k_q;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONGLONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__q;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":267
+    /* "numpy.pxd":263
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  */
-      case NPY_ULONGLONG:
-      __pyx_v_f = __pyx_k_Q;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_ULONGLONG);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Q;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":268
+    /* "numpy.pxd":264
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  */
-      case NPY_FLOAT:
-      __pyx_v_f = __pyx_k_f;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_FLOAT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__f;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":269
+    /* "numpy.pxd":265
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  */
-      case NPY_DOUBLE:
-      __pyx_v_f = __pyx_k_d;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_DOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__d;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":270
+    /* "numpy.pxd":266
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  */
-      case NPY_LONGDOUBLE:
-      __pyx_v_f = __pyx_k_g;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_LONGDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__g;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":271
+    /* "numpy.pxd":267
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  */
-      case NPY_CFLOAT:
-      __pyx_v_f = __pyx_k_Zf;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CFLOAT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zf;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":272
+    /* "numpy.pxd":268
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"
  */
-      case NPY_CDOUBLE:
-      __pyx_v_f = __pyx_k_Zd;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zd;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":273
+    /* "numpy.pxd":269
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  */
-      case NPY_CLONGDOUBLE:
-      __pyx_v_f = __pyx_k_Zg;
-      break;
+    __pyx_t_1 = (__pyx_v_t == NPY_CLONGDOUBLE);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__Zg;
+      goto __pyx_L15;
+    }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
+    /* "numpy.pxd":270
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      case NPY_OBJECT:
-      __pyx_v_f = __pyx_k_O;
-      break;
-      default:
+    __pyx_t_1 = (__pyx_v_t == NPY_OBJECT);
+    if (__pyx_t_1) {
+      __pyx_v_f = __pyx_k__O;
+      goto __pyx_L15;
+    }
+    /*else*/ {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":276
+      /* "numpy.pxd":272
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *                 info.format = f
  *                 return
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_8 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_t_8 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_29), __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_8));
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_8);
-      __Pyx_GIVEREF(__pyx_t_8);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_8));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_8));
       __pyx_t_8 = 0;
-      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_8);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      break;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
+    __pyx_L15:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":277
+    /* "numpy.pxd":273
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f             # <<<<<<<<<<<<<<
  *                 return
  *             else:
  */
     __pyx_v_info->format = __pyx_v_f;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":278
+    /* "numpy.pxd":274
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f
  *                 return             # <<<<<<<<<<<<<<
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
  */
     __pyx_r = 0;
     goto __pyx_L0;
+    goto __pyx_L13;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":280
+    /* "numpy.pxd":276
  *                 return
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
- *                 info.format[0] = c'^' # Native data types, manual alignment
+ *                 info.format[0] = '^' # Native data types, manual alignment
  *                 offset = 0
  */
     __pyx_v_info->format = ((char *)malloc(255));
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":281
+    /* "numpy.pxd":277
  *             else:
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
- *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
+ *                 info.format[0] = '^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
  *                 offset = 0
  *                 f = _util_dtypestring(descr, info.format + 1,
  */
     (__pyx_v_info->format[0]) = '^';
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":282
+    /* "numpy.pxd":278
  *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
- *                 info.format[0] = c'^' # Native data types, manual alignment
+ *                 info.format[0] = '^' # Native data types, manual alignment
  *                 offset = 0             # <<<<<<<<<<<<<<
  *                 f = _util_dtypestring(descr, info.format + 1,
  *                                       info.format + _buffer_format_string_len,
  */
     __pyx_v_offset = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":283
- *                 info.format[0] = c'^' # Native data types, manual alignment
- *                 offset = 0
- *                 f = _util_dtypestring(descr, info.format + 1,             # <<<<<<<<<<<<<<
+    /* "numpy.pxd":281
+ *                 f = _util_dtypestring(descr, info.format + 1,
  *                                       info.format + _buffer_format_string_len,
- *                                       &offset)
+ *                                       &offset)             # <<<<<<<<<<<<<<
+ *                 f[0] = 0 # Terminate format string
+ * 
  */
-    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __pyx_v_f = __pyx_t_9;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":286
+    /* "numpy.pxd":282
  *                                       info.format + _buffer_format_string_len,
  *                                       &offset)
- *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
+ *                 f[0] = 0 # Terminate format string             # <<<<<<<<<<<<<<
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  */
-    (__pyx_v_f[0]) = '\x00';
+    (__pyx_v_f[0]) = 0;
   }
+  __pyx_L13:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":194
- *         # experimental exception made for __getbuffer__ and __releasebuffer__
- *         # -- the details of this may change.
- *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
- *             # This implementation of getbuffer is geared towards Cython
- *             # requirements, and does not yet fullfill the PEP.
- */
-
-  /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
@@ -9026,345 +6672,291 @@
   }
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_descr);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":288
- *                 f[0] = c'\0' # Terminate format string
+/* "numpy.pxd":284
+ *                 f[0] = 0 # Terminate format string
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)
  */
 
-/* Python wrapper */
-static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
-static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
-  __pyx_pf_5numpy_7ndarray_2__releasebuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-}
-
-static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
+static CYTHON_UNUSED void __pyx_pf_5numpy_7ndarray_1__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
+static CYTHON_UNUSED void __pyx_pf_5numpy_7ndarray_1__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("__releasebuffer__", 0);
+  __Pyx_RefNannySetupContext("__releasebuffer__");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":289
+  /* "numpy.pxd":285
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
-  __pyx_t_1 = (PyArray_HASFIELDS(__pyx_v_self) != 0);
+  __pyx_t_1 = PyArray_HASFIELDS(((PyArrayObject *)__pyx_v_self));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":290
+    /* "numpy.pxd":286
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 stdlib.free(info.strides)
  */
     free(__pyx_v_info->format);
-    goto __pyx_L3;
+    goto __pyx_L5;
   }
-  __pyx_L3:;
+  __pyx_L5:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":291
+  /* "numpy.pxd":287
  *             if PyArray_HASFIELDS(self):
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 stdlib.free(info.strides)
  *                 # info.shape was stored after info.strides in the same block
  */
-  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
+  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":292
+    /* "numpy.pxd":288
  *                 stdlib.free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
  *                 # info.shape was stored after info.strides in the same block
  * 
  */
     free(__pyx_v_info->strides);
-    goto __pyx_L4;
+    goto __pyx_L6;
   }
-  __pyx_L4:;
-
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":288
- *                 f[0] = c'\0' # Terminate format string
- * 
- *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
- *             if PyArray_HASFIELDS(self):
- *                 stdlib.free(info.format)
- */
+  __pyx_L6:;
 
-  /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":768
+/* "numpy.pxd":764
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":769
+  /* "numpy.pxd":765
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":768
- * ctypedef npy_cdouble     complex_t
- * 
- * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(1, <void*>a)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":771
+/* "numpy.pxd":767
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":772
+  /* "numpy.pxd":768
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 768; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":771
- *     return PyArray_MultiIterNew(1, <void*>a)
- * 
- * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":774
+/* "numpy.pxd":770
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":775
+  /* "numpy.pxd":771
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":774
- *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
- * 
- * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":777
+/* "numpy.pxd":773
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":778
+  /* "numpy.pxd":774
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":777
- *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
- * 
- * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":780
+/* "numpy.pxd":776
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
+  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":781
+  /* "numpy.pxd":777
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":780
- *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
- * 
- * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
- *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- * 
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":783
+/* "numpy.pxd":779
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
  *     # Recursive utility function used in __getbuffer__ to get format
  *     # string. The new location in the format string is returned.
  */
 
@@ -9378,1307 +6970,1584 @@
   PyObject *__pyx_v_t = NULL;
   char *__pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   long __pyx_t_10;
   char *__pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_util_dtypestring", 0);
+  __Pyx_RefNannySetupContext("_util_dtypestring");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":790
+  /* "numpy.pxd":786
  *     cdef int delta_offset
  *     cdef tuple i
  *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  *     cdef tuple fields
  */
   __pyx_v_endian_detector = 1;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":791
+  /* "numpy.pxd":787
  *     cdef tuple i
  *     cdef int endian_detector = 1
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  *     cdef tuple fields
  * 
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":794
+  /* "numpy.pxd":790
  *     cdef tuple fields
  * 
  *     for childname in descr.names:             # <<<<<<<<<<<<<<
  *         fields = descr.fields[childname]
  *         child, new_offset = fields
  */
-  if (unlikely(__pyx_v_descr->names == Py_None)) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(((PyObject *)__pyx_v_descr->names) == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable"); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;} 
   }
-  __pyx_t_1 = __pyx_v_descr->names; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
+  __pyx_t_1 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-    #if CYTHON_COMPILING_IN_CPYTHON
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    #endif
-    __Pyx_XDECREF_SET(__pyx_v_childname, __pyx_t_3);
+    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++;
+    __Pyx_XDECREF(__pyx_v_childname);
+    __pyx_v_childname = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":795
+    /* "numpy.pxd":791
  * 
  *     for childname in descr.names:
  *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
  *         child, new_offset = fields
  * 
  */
-    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (unlikely(__pyx_t_3 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_XDECREF_SET(__pyx_v_fields, ((PyObject*)__pyx_t_3));
+    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected tuple, got %.200s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_XDECREF(((PyObject *)__pyx_v_fields));
+    __pyx_v_fields = ((PyObject*)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":796
+    /* "numpy.pxd":792
  *     for childname in descr.names:
  *         fields = descr.fields[childname]
  *         child, new_offset = fields             # <<<<<<<<<<<<<<
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  */
-    if (likely(__pyx_v_fields != Py_None)) {
-      PyObject* sequence = __pyx_v_fields;
-      #if CYTHON_COMPILING_IN_CPYTHON
-      Py_ssize_t size = Py_SIZE(sequence);
-      #else
-      Py_ssize_t size = PySequence_Size(sequence);
-      #endif
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (likely(PyTuple_CheckExact(((PyObject *)__pyx_v_fields)))) {
+      PyObject* sequence = ((PyObject *)__pyx_v_fields);
+      if (unlikely(PyTuple_GET_SIZE(sequence) != 2)) {
+        if (PyTuple_GET_SIZE(sequence) > 2) __Pyx_RaiseTooManyValuesError(2);
+        else __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(sequence));
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
-      #if CYTHON_COMPILING_IN_CPYTHON
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
-      #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      #endif
     } else {
-      __Pyx_RaiseNoneNotIterableError(); {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_UnpackTupleError(((PyObject *)__pyx_v_fields), 2);
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __Pyx_XDECREF_SET(__pyx_v_child, ((PyArray_Descr *)__pyx_t_3));
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_XDECREF(((PyObject *)__pyx_v_child));
+    __pyx_v_child = ((PyArray_Descr *)__pyx_t_3);
     __pyx_t_3 = 0;
-    __Pyx_XDECREF_SET(__pyx_v_new_offset, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_v_new_offset);
+    __pyx_v_new_offset = __pyx_t_4;
     __pyx_t_4 = 0;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":798
+    /* "numpy.pxd":794
  *         child, new_offset = fields
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
+ *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  */
-    __pyx_t_4 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_6 = ((((__pyx_v_end - __pyx_v_f) - ((int)__pyx_t_5)) < 15) != 0);
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":799
+      /* "numpy.pxd":795
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
+ *         if ((child.byteorder == '>' and little_endian) or
  */
-      __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_31), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L5;
     }
+    __pyx_L5:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":801
+    /* "numpy.pxd":797
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
- *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
- *             (child.byteorder == c'<' and not little_endian)):
+ *         if ((child.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")
  */
-    __pyx_t_6 = ((__pyx_v_child->byteorder == '>') != 0);
+    __pyx_t_6 = (__pyx_v_child->byteorder == '>');
     if (__pyx_t_6) {
-      __pyx_t_7 = (__pyx_v_little_endian != 0);
+      __pyx_t_7 = __pyx_v_little_endian;
     } else {
       __pyx_t_7 = __pyx_t_6;
     }
     if (!__pyx_t_7) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":802
+      /* "numpy.pxd":798
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
  *             raise ValueError(u"Non-native byte order not supported")
  *             # One could encode it in the format string and have Cython
  */
-      __pyx_t_6 = ((__pyx_v_child->byteorder == '<') != 0);
+      __pyx_t_6 = (__pyx_v_child->byteorder == '<');
       if (__pyx_t_6) {
-        __pyx_t_8 = ((!(__pyx_v_little_endian != 0)) != 0);
+        __pyx_t_8 = (!__pyx_v_little_endian);
         __pyx_t_9 = __pyx_t_8;
       } else {
         __pyx_t_9 = __pyx_t_6;
       }
       __pyx_t_6 = __pyx_t_9;
     } else {
       __pyx_t_6 = __pyx_t_7;
     }
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":803
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):
+      /* "numpy.pxd":799
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_32), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L6;
     }
+    __pyx_L6:;
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":813
+    /* "numpy.pxd":809
  * 
  *         # Output padding bytes
  *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  */
     while (1) {
-      __pyx_t_3 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (!__pyx_t_6) break;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":814
+      /* "numpy.pxd":810
  *         # Output padding bytes
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
  *             f += 1
  *             offset[0] += 1
  */
       (__pyx_v_f[0]) = 120;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":815
+      /* "numpy.pxd":811
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte
  *             f += 1             # <<<<<<<<<<<<<<
  *             offset[0] += 1
  * 
  */
       __pyx_v_f = (__pyx_v_f + 1);
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":816
+      /* "numpy.pxd":812
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  *             offset[0] += 1             # <<<<<<<<<<<<<<
  * 
  *         offset[0] += child.itemsize
  */
       __pyx_t_10 = 0;
       (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + 1);
     }
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":818
+    /* "numpy.pxd":814
  *             offset[0] += 1
  * 
  *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not PyDataType_HASFIELDS(child):
  */
     __pyx_t_10 = 0;
     (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + __pyx_v_child->elsize);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":820
+    /* "numpy.pxd":816
  *         offset[0] += child.itemsize
  * 
  *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
  *             t = child.type_num
  *             if end - f < 5:
  */
-    __pyx_t_6 = ((!(PyDataType_HASFIELDS(__pyx_v_child) != 0)) != 0);
+    __pyx_t_6 = (!PyDataType_HASFIELDS(__pyx_v_child));
     if (__pyx_t_6) {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":821
+      /* "numpy.pxd":817
  * 
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num             # <<<<<<<<<<<<<<
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_XDECREF_SET(__pyx_v_t, __pyx_t_4);
-      __pyx_t_4 = 0;
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_v_t);
+      __pyx_v_t = __pyx_t_3;
+      __pyx_t_3 = 0;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":822
+      /* "numpy.pxd":818
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num
  *             if end - f < 5:             # <<<<<<<<<<<<<<
  *                 raise RuntimeError(u"Format string allocated too short.")
  * 
  */
-      __pyx_t_6 = (((__pyx_v_end - __pyx_v_f) < 5) != 0);
+      __pyx_t_6 = ((__pyx_v_end - __pyx_v_f) < 5);
       if (__pyx_t_6) {
 
-        /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":823
+        /* "numpy.pxd":819
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-        __pyx_t_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_34), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L10;
       }
+      __pyx_L10:;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":826
+      /* "numpy.pxd":822
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 98;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":827
+      /* "numpy.pxd":823
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 66;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":828
+      /* "numpy.pxd":824
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 104;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":829
+      /* "numpy.pxd":825
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 72;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":830
+      /* "numpy.pxd":826
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 105;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":831
+      /* "numpy.pxd":827
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 73;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":832
+      /* "numpy.pxd":828
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 108;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":833
+      /* "numpy.pxd":829
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 76;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":834
+      /* "numpy.pxd":830
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 113;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":835
+      /* "numpy.pxd":831
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 81;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":836
+      /* "numpy.pxd":832
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 102;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":837
+      /* "numpy.pxd":833
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 100;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":838
+      /* "numpy.pxd":834
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 103;
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":839
+      /* "numpy.pxd":835
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 102;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":840
+      /* "numpy.pxd":836
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 100;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":841
+      /* "numpy.pxd":837
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  */
-      __pyx_t_3 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_5 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 103;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L11;
       }
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":842
+      /* "numpy.pxd":838
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      __pyx_t_4 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 79;
         goto __pyx_L11;
       }
       /*else*/ {
 
-        /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":844
+        /* "numpy.pxd":840
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *             f += 1
  *         else:
  */
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_v_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_4);
-        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-        __Pyx_GIVEREF(__pyx_t_3);
-        __pyx_t_3 = 0;
-        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        {__pyx_filename = __pyx_f[2]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_29), __pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));
+        __Pyx_GIVEREF(((PyObject *)__pyx_t_5));
+        __pyx_t_5 = 0;
+        __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+        __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
       __pyx_L11:;
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":845
+      /* "numpy.pxd":841
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *             f += 1             # <<<<<<<<<<<<<<
  *         else:
  *             # Cython ignores struct boundary information ("T{...}"),
  */
       __pyx_v_f = (__pyx_v_f + 1);
       goto __pyx_L9;
     }
     /*else*/ {
 
-      /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":849
+      /* "numpy.pxd":845
  *             # Cython ignores struct boundary information ("T{...}"),
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
  *     return f
  * 
  */
-      __pyx_t_11 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_11 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __pyx_v_f = __pyx_t_11;
     }
     __pyx_L9:;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":850
+  /* "numpy.pxd":846
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)
  *     return f             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_f;
   goto __pyx_L0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":783
- *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
- * 
- * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
- *     # Recursive utility function used in __getbuffer__ to get format
- *     # string. The new location in the format string is returned.
- */
-
-  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("numpy._util_dtypestring", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_child);
   __Pyx_XDECREF(__pyx_v_fields);
   __Pyx_XDECREF(__pyx_v_childname);
   __Pyx_XDECREF(__pyx_v_new_offset);
   __Pyx_XDECREF(__pyx_v_t);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":966
+/* "numpy.pxd":961
  * 
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *      cdef PyObject* baseptr
  *      if base is None:
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   PyObject *__pyx_v_baseptr;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  int __pyx_t_2;
-  __Pyx_RefNannySetupContext("set_array_base", 0);
+  __Pyx_RefNannySetupContext("set_array_base");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":968
+  /* "numpy.pxd":963
  * cdef inline void set_array_base(ndarray arr, object base):
  *      cdef PyObject* baseptr
  *      if base is None:             # <<<<<<<<<<<<<<
  *          baseptr = NULL
  *      else:
  */
   __pyx_t_1 = (__pyx_v_base == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
+  if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":969
+    /* "numpy.pxd":964
  *      cdef PyObject* baseptr
  *      if base is None:
  *          baseptr = NULL             # <<<<<<<<<<<<<<
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!
  */
     __pyx_v_baseptr = NULL;
     goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":971
+    /* "numpy.pxd":966
  *          baseptr = NULL
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)
  */
     Py_INCREF(__pyx_v_base);
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":972
+    /* "numpy.pxd":967
  *      else:
  *          Py_INCREF(base) # important to do this before decref below!
  *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
  *      Py_XDECREF(arr.base)
  *      arr.base = baseptr
  */
     __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
   }
   __pyx_L3:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":973
+  /* "numpy.pxd":968
  *          Py_INCREF(base) # important to do this before decref below!
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
  *      arr.base = baseptr
  * 
  */
   Py_XDECREF(__pyx_v_arr->base);
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":974
+  /* "numpy.pxd":969
  *          baseptr = <PyObject*>base
  *      Py_XDECREF(arr.base)
  *      arr.base = baseptr             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   __pyx_v_arr->base = __pyx_v_baseptr;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":966
- * 
- * 
- * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
- *      cdef PyObject* baseptr
- *      if base is None:
- */
-
-  /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
+/* "numpy.pxd":971
  *      arr.base = baseptr
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     if arr.base is NULL:
  *         return None
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  __Pyx_RefNannySetupContext("get_array_base", 0);
+  __Pyx_RefNannySetupContext("get_array_base");
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":977
+  /* "numpy.pxd":972
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     if arr.base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     else:
  */
-  __pyx_t_1 = ((__pyx_v_arr->base == NULL) != 0);
+  __pyx_t_1 = (__pyx_v_arr->base == NULL);
   if (__pyx_t_1) {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":978
+    /* "numpy.pxd":973
  * cdef inline object get_array_base(ndarray arr):
  *     if arr.base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     else:
  *         return <object>arr.base
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(Py_None);
     __pyx_r = Py_None;
     goto __pyx_L0;
+    goto __pyx_L3;
   }
   /*else*/ {
 
-    /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":980
+    /* "numpy.pxd":975
  *         return None
  *     else:
  *         return <object>arr.base             # <<<<<<<<<<<<<<
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
     __pyx_r = ((PyObject *)__pyx_v_arr->base);
     goto __pyx_L0;
   }
+  __pyx_L3:;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
- *      arr.base = baseptr
- * 
- * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
- *     if arr.base is NULL:
- *         return None
- */
-
-  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+static PyObject *__pyx_tp_new_6healpy_9_sphtools_WrapMap(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *p;
+  PyObject *o = (*t->tp_alloc)(t, 0);
+  if (!o) return 0;
+  p = ((struct __pyx_obj_6healpy_9_sphtools_WrapMap *)o);
+  p->m = Py_None; Py_INCREF(Py_None);
+  return o;
+}
+
+static void __pyx_tp_dealloc_6healpy_9_sphtools_WrapMap(PyObject *o) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *p = (struct __pyx_obj_6healpy_9_sphtools_WrapMap *)o;
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pf_6healpy_9_sphtools_7WrapMap_1__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  Py_XDECREF(p->m);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_6healpy_9_sphtools_WrapMap(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *p = (struct __pyx_obj_6healpy_9_sphtools_WrapMap *)o;
+  if (p->m) {
+    e = (*v)(p->m, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_6healpy_9_sphtools_WrapMap(PyObject *o) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapMap *p = (struct __pyx_obj_6healpy_9_sphtools_WrapMap *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->m);
+  p->m = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyMethodDef __pyx_methods_6healpy_9_sphtools_WrapMap[] = {
+  {0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_WrapMap = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_WrapMap = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_WrapMap = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_WrapMap = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_6healpy_9_sphtools_WrapMap = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("healpy._sphtools.WrapMap"), /*tp_name*/
+  sizeof(struct __pyx_obj_6healpy_9_sphtools_WrapMap), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_6healpy_9_sphtools_WrapMap, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_WrapMap, /*tp_as_number*/
+  &__pyx_tp_as_sequence_WrapMap, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_WrapMap, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_WrapMap, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("WrapMap(ndarray m)\nThis class provides a wrapper to a ndarray so it can be sent as Map to healpix_cxx functions.\n    "), /*tp_doc*/
+  __pyx_tp_traverse_6healpy_9_sphtools_WrapMap, /*tp_traverse*/
+  __pyx_tp_clear_6healpy_9_sphtools_WrapMap, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_6healpy_9_sphtools_WrapMap, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pf_6healpy_9_sphtools_7WrapMap___init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_6healpy_9_sphtools_WrapMap, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
+static PyObject *__pyx_tp_new_6healpy_9_sphtools_WrapAlm(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *p;
+  PyObject *o = (*t->tp_alloc)(t, 0);
+  if (!o) return 0;
+  p = ((struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)o);
+  p->m = Py_None; Py_INCREF(Py_None);
+  return o;
+}
+
+static void __pyx_tp_dealloc_6healpy_9_sphtools_WrapAlm(PyObject *o) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *p = (struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)o;
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pf_6healpy_9_sphtools_7WrapAlm_1__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  Py_XDECREF(p->m);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_6healpy_9_sphtools_WrapAlm(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *p = (struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)o;
+  if (p->m) {
+    e = (*v)(p->m, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_6healpy_9_sphtools_WrapAlm(PyObject *o) {
+  struct __pyx_obj_6healpy_9_sphtools_WrapAlm *p = (struct __pyx_obj_6healpy_9_sphtools_WrapAlm *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->m);
+  p->m = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyMethodDef __pyx_methods_6healpy_9_sphtools_WrapAlm[] = {
+  {0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_WrapAlm = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_WrapAlm = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_WrapAlm = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_WrapAlm = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_6healpy_9_sphtools_WrapAlm = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("healpy._sphtools.WrapAlm"), /*tp_name*/
+  sizeof(struct __pyx_obj_6healpy_9_sphtools_WrapAlm), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_6healpy_9_sphtools_WrapAlm, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_WrapAlm, /*tp_as_number*/
+  &__pyx_tp_as_sequence_WrapAlm, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_WrapAlm, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_WrapAlm, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("WrapAlm(ndarray m, int lmax, int mmax)\nThis class provides a wrapper to a ndarray so it can be sent as Alm to healpix_cxx functions.\n    "), /*tp_doc*/
+  __pyx_tp_traverse_6healpy_9_sphtools_WrapAlm, /*tp_traverse*/
+  __pyx_tp_clear_6healpy_9_sphtools_WrapAlm, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_6healpy_9_sphtools_WrapAlm, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pf_6healpy_9_sphtools_7WrapAlm___init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_6healpy_9_sphtools_WrapAlm, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
 static PyMethodDef __pyx_methods[] = {
-  {__Pyx_NAMESTR("mkmask"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_17mkmask, METH_O, __Pyx_DOCSTR(0)},
-  {__Pyx_NAMESTR("count_bad"), (PyCFunction)__pyx_pw_6healpy_9_sphtools_19count_bad, METH_O, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("mkmask"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_4mkmask, METH_O, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_4mkmask)},
+  {__Pyx_NAMESTR("count_bad"), (PyCFunction)__pyx_pf_6healpy_9_sphtools_5count_bad, METH_O, __Pyx_DOCSTR(__pyx_doc_6healpy_9_sphtools_5count_bad)},
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 static struct PyModuleDef __pyx_moduledef = {
-  #if PY_VERSION_HEX < 0x03020000
-    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
-  #else
     PyModuleDef_HEAD_INIT,
-  #endif
     __Pyx_NAMESTR("_sphtools"),
     0, /* m_doc */
     -1, /* m_size */
     __pyx_methods /* m_methods */,
     NULL, /* m_reload */
     NULL, /* m_traverse */
     NULL, /* m_clear */
     NULL /* m_free */
 };
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_n_s_A1, __pyx_k_A1, sizeof(__pyx_k_A1), 0, 0, 1, 1},
-  {&__pyx_n_s_A2, __pyx_k_A2, sizeof(__pyx_k_A2), 0, 0, 1, 1},
-  {&__pyx_n_s_AC, __pyx_k_AC, sizeof(__pyx_k_AC), 0, 0, 1, 1},
-  {&__pyx_n_s_AG, __pyx_k_AG, sizeof(__pyx_k_AG), 0, 0, 1, 1},
-  {&__pyx_n_s_AI, __pyx_k_AI, sizeof(__pyx_k_AI), 0, 0, 1, 1},
-  {&__pyx_n_s_DATAPATH, __pyx_k_DATAPATH, sizeof(__pyx_k_DATAPATH), 0, 0, 1, 1},
-  {&__pyx_kp_u_Format_string_allocated_too_shor, __pyx_k_Format_string_allocated_too_shor, sizeof(__pyx_k_Format_string_allocated_too_shor), 0, 1, 0, 0},
-  {&__pyx_kp_u_Format_string_allocated_too_shor_2, __pyx_k_Format_string_allocated_too_shor_2, sizeof(__pyx_k_Format_string_allocated_too_shor_2), 0, 1, 0, 0},
-  {&__pyx_n_s_IOError, __pyx_k_IOError, sizeof(__pyx_k_IOError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Input_maps_must_have_same_size, __pyx_k_Input_maps_must_have_same_size, sizeof(__pyx_k_Input_maps_must_have_same_size), 0, 0, 1, 0},
-  {&__pyx_kp_s_Invalid_input, __pyx_k_Invalid_input, sizeof(__pyx_k_Invalid_input), 0, 0, 1, 0},
-  {&__pyx_n_s_M1, __pyx_k_M1, sizeof(__pyx_k_M1), 0, 0, 1, 1},
-  {&__pyx_n_s_M2, __pyx_k_M2, sizeof(__pyx_k_M2), 0, 0, 1, 1},
-  {&__pyx_n_s_MI, __pyx_k_MI, sizeof(__pyx_k_MI), 0, 0, 1, 1},
-  {&__pyx_n_s_MQ, __pyx_k_MQ, sizeof(__pyx_k_MQ), 0, 0, 1, 1},
-  {&__pyx_n_s_MU, __pyx_k_MU, sizeof(__pyx_k_MU), 0, 0, 1, 1},
-  {&__pyx_kp_u_Non_native_byte_order_not_suppor, __pyx_k_Non_native_byte_order_not_suppor, sizeof(__pyx_k_Non_native_byte_order_not_suppor), 0, 1, 0, 0},
-  {&__pyx_n_s_Nspec, __pyx_k_Nspec, sizeof(__pyx_k_Nspec), 0, 0, 1, 1},
-  {&__pyx_n_s_Nspec2, __pyx_k_Nspec2, sizeof(__pyx_k_Nspec2), 0, 0, 1, 1},
-  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
-  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Weight_file_not_found_in_s, __pyx_k_Weight_file_not_found_in_s, sizeof(__pyx_k_Weight_file_not_found_in_s), 0, 0, 1, 0},
-  {&__pyx_kp_s_Wrong_input_map_must_be_a_valid, __pyx_k_Wrong_input_map_must_be_a_valid, sizeof(__pyx_k_Wrong_input_map_must_be_a_valid), 0, 0, 1, 0},
-  {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
-  {&__pyx_n_s_abspath, __pyx_k_abspath, sizeof(__pyx_k_abspath), 0, 0, 1, 1},
-  {&__pyx_n_s_ac, __pyx_k_ac, sizeof(__pyx_k_ac), 0, 0, 1, 1},
-  {&__pyx_n_s_ag, __pyx_k_ag, sizeof(__pyx_k_ag), 0, 0, 1, 1},
-  {&__pyx_n_s_ai, __pyx_k_ai, sizeof(__pyx_k_ai), 0, 0, 1, 1},
-  {&__pyx_kp_s_all_alms_must_have_same_size, __pyx_k_all_alms_must_have_same_size, sizeof(__pyx_k_all_alms_must_have_same_size), 0, 0, 1, 0},
-  {&__pyx_n_s_alm, __pyx_k_alm, sizeof(__pyx_k_alm), 0, 0, 1, 1},
-  {&__pyx_n_s_alm1, __pyx_k_alm1, sizeof(__pyx_k_alm1), 0, 0, 1, 1},
-  {&__pyx_n_s_alm2, __pyx_k_alm2, sizeof(__pyx_k_alm2), 0, 0, 1, 1},
-  {&__pyx_n_s_alm2cl, __pyx_k_alm2cl, sizeof(__pyx_k_alm2cl), 0, 0, 1, 1},
-  {&__pyx_n_s_alm2map_spin_healpy, __pyx_k_alm2map_spin_healpy, sizeof(__pyx_k_alm2map_spin_healpy), 0, 0, 1, 1},
-  {&__pyx_n_s_almC, __pyx_k_almC, sizeof(__pyx_k_almC), 0, 0, 1, 1},
-  {&__pyx_n_s_almG, __pyx_k_almG, sizeof(__pyx_k_almG), 0, 0, 1, 1},
-  {&__pyx_n_s_almI, __pyx_k_almI, sizeof(__pyx_k_almI), 0, 0, 1, 1},
-  {&__pyx_n_s_alm_2, __pyx_k_alm_2, sizeof(__pyx_k_alm_2), 0, 0, 1, 1},
-  {&__pyx_n_s_alm_getlmmax, __pyx_k_alm_getlmmax, sizeof(__pyx_k_alm_getlmmax), 0, 0, 1, 1},
-  {&__pyx_n_s_alms, __pyx_k_alms, sizeof(__pyx_k_alms), 0, 0, 1, 1},
-  {&__pyx_n_s_alms2, __pyx_k_alms2, sizeof(__pyx_k_alms2), 0, 0, 1, 1},
-  {&__pyx_kp_s_alms2_must_be_an_array_or_a_sequ, __pyx_k_alms2_must_be_an_array_or_a_sequ, sizeof(__pyx_k_alms2_must_be_an_array_or_a_sequ), 0, 0, 1, 0},
-  {&__pyx_kp_s_alms_and_alms2_must_have_same_nu, __pyx_k_alms_and_alms2_must_have_same_nu, sizeof(__pyx_k_alms_and_alms2_must_have_same_nu), 0, 0, 1, 0},
-  {&__pyx_n_s_alms_c, __pyx_k_alms_c, sizeof(__pyx_k_alms_c), 0, 0, 1, 1},
-  {&__pyx_n_s_alms_lonely, __pyx_k_alms_lonely, sizeof(__pyx_k_alms_lonely), 0, 0, 1, 1},
-  {&__pyx_kp_s_alms_must_be_an_array_or_a_seque, __pyx_k_alms_must_be_an_array_or_a_seque, sizeof(__pyx_k_alms_must_be_an_array_or_a_seque), 0, 0, 1, 0},
-  {&__pyx_n_s_almsize, __pyx_k_almsize, sizeof(__pyx_k_almsize), 0, 0, 1, 1},
-  {&__pyx_n_s_almxfl, __pyx_k_almxfl, sizeof(__pyx_k_almxfl), 0, 0, 1, 1},
-  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
-  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
-  {&__pyx_n_s_ascontiguousarray, __pyx_k_ascontiguousarray, sizeof(__pyx_k_ascontiguousarray), 0, 0, 1, 1},
-  {&__pyx_n_s_c_datapath, __pyx_k_c_datapath, sizeof(__pyx_k_c_datapath), 0, 0, 1, 1},
-  {&__pyx_n_s_complex128, __pyx_k_complex128, sizeof(__pyx_k_complex128), 0, 0, 1, 1},
-  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
-  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
-  {&__pyx_n_s_datapath, __pyx_k_datapath, sizeof(__pyx_k_datapath), 0, 0, 1, 1},
-  {&__pyx_n_s_dirname, __pyx_k_dirname, sizeof(__pyx_k_dirname), 0, 0, 1, 1},
-  {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
-  {&__pyx_n_s_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 0, 0, 1, 1},
-  {&__pyx_n_s_f, __pyx_k_f, sizeof(__pyx_k_f), 0, 0, 1, 1},
-  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
-  {&__pyx_n_s_fl, __pyx_k_fl, sizeof(__pyx_k_fl), 0, 0, 1, 1},
-  {&__pyx_n_s_fl_2, __pyx_k_fl_2, sizeof(__pyx_k_fl_2), 0, 0, 1, 1},
-  {&__pyx_n_s_float64, __pyx_k_float64, sizeof(__pyx_k_float64), 0, 0, 1, 1},
-  {&__pyx_n_s_flsize, __pyx_k_flsize, sizeof(__pyx_k_flsize), 0, 0, 1, 1},
-  {&__pyx_n_s_get_datapath, __pyx_k_get_datapath, sizeof(__pyx_k_get_datapath), 0, 0, 1, 1},
-  {&__pyx_n_s_healpy, __pyx_k_healpy, sizeof(__pyx_k_healpy), 0, 0, 1, 1},
-  {&__pyx_n_s_healpy__sphtools, __pyx_k_healpy__sphtools, sizeof(__pyx_k_healpy__sphtools), 0, 0, 1, 1},
-  {&__pyx_n_s_healpy_pixelfunc, __pyx_k_healpy_pixelfunc, sizeof(__pyx_k_healpy_pixelfunc), 0, 0, 1, 1},
-  {&__pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_k_home_zonca_healpy_healpy_src__s, sizeof(__pyx_k_home_zonca_healpy_healpy_src__s), 0, 0, 1, 0},
-  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
-  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-  {&__pyx_n_s_info, __pyx_k_info, sizeof(__pyx_k_info), 0, 0, 1, 1},
-  {&__pyx_n_s_inplace, __pyx_k_inplace, sizeof(__pyx_k_inplace), 0, 0, 1, 1},
-  {&__pyx_n_s_int8, __pyx_k_int8, sizeof(__pyx_k_int8), 0, 0, 1, 1},
-  {&__pyx_n_s_isfile, __pyx_k_isfile, sizeof(__pyx_k_isfile), 0, 0, 1, 1},
-  {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
-  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
-  {&__pyx_n_s_l, __pyx_k_l, sizeof(__pyx_k_l), 0, 0, 1, 1},
-  {&__pyx_n_s_len, __pyx_k_len, sizeof(__pyx_k_len), 0, 0, 1, 1},
-  {&__pyx_n_s_limit, __pyx_k_limit, sizeof(__pyx_k_limit), 0, 0, 1, 1},
-  {&__pyx_n_s_lmax, __pyx_k_lmax, sizeof(__pyx_k_lmax), 0, 0, 1, 1},
-  {&__pyx_n_s_lmax_2, __pyx_k_lmax_2, sizeof(__pyx_k_lmax_2), 0, 0, 1, 1},
-  {&__pyx_n_s_lmax_out, __pyx_k_lmax_out, sizeof(__pyx_k_lmax_out), 0, 0, 1, 1},
-  {&__pyx_n_s_lmax_out_2, __pyx_k_lmax_out_2, sizeof(__pyx_k_lmax_out_2), 0, 0, 1, 1},
-  {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
-  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-  {&__pyx_n_s_map2alm, __pyx_k_map2alm, sizeof(__pyx_k_map2alm), 0, 0, 1, 1},
-  {&__pyx_n_s_map2alm_spin_healpy, __pyx_k_map2alm_spin_healpy, sizeof(__pyx_k_map2alm_spin_healpy), 0, 0, 1, 1},
-  {&__pyx_n_s_maps, __pyx_k_maps, sizeof(__pyx_k_maps), 0, 0, 1, 1},
-  {&__pyx_n_s_maps_c, __pyx_k_maps_c, sizeof(__pyx_k_maps_c), 0, 0, 1, 1},
-  {&__pyx_n_s_maptype, __pyx_k_maptype, sizeof(__pyx_k_maptype), 0, 0, 1, 1},
-  {&__pyx_n_s_mask, __pyx_k_mask, sizeof(__pyx_k_mask), 0, 0, 1, 1},
-  {&__pyx_n_s_mask_mi, __pyx_k_mask_mi, sizeof(__pyx_k_mask_mi), 0, 0, 1, 1},
-  {&__pyx_n_s_mask_mq, __pyx_k_mask_mq, sizeof(__pyx_k_mask_mq), 0, 0, 1, 1},
-  {&__pyx_n_s_mask_mu, __pyx_k_mask_mu, sizeof(__pyx_k_mask_mu), 0, 0, 1, 1},
-  {&__pyx_n_s_masks, __pyx_k_masks, sizeof(__pyx_k_masks), 0, 0, 1, 1},
-  {&__pyx_n_s_maxm, __pyx_k_maxm, sizeof(__pyx_k_maxm), 0, 0, 1, 1},
-  {&__pyx_n_s_mi, __pyx_k_mi, sizeof(__pyx_k_mi), 0, 0, 1, 1},
-  {&__pyx_n_s_mmax, __pyx_k_mmax, sizeof(__pyx_k_mmax), 0, 0, 1, 1},
-  {&__pyx_n_s_mmax_2, __pyx_k_mmax_2, sizeof(__pyx_k_mmax_2), 0, 0, 1, 1},
-  {&__pyx_kp_s_mmax_must_be_lmax, __pyx_k_mmax_must_be_lmax, sizeof(__pyx_k_mmax_must_be_lmax), 0, 0, 1, 0},
-  {&__pyx_n_s_mq, __pyx_k_mq, sizeof(__pyx_k_mq), 0, 0, 1, 1},
-  {&__pyx_n_s_mu, __pyx_k_mu, sizeof(__pyx_k_mu), 0, 0, 1, 1},
-  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
-  {&__pyx_n_s_n_alm, __pyx_k_n_alm, sizeof(__pyx_k_n_alm), 0, 0, 1, 1},
-  {&__pyx_kp_u_ndarray_is_not_C_contiguous, __pyx_k_ndarray_is_not_C_contiguous, sizeof(__pyx_k_ndarray_is_not_C_contiguous), 0, 1, 0, 0},
-  {&__pyx_kp_u_ndarray_is_not_Fortran_contiguou, __pyx_k_ndarray_is_not_Fortran_contiguou, sizeof(__pyx_k_ndarray_is_not_Fortran_contiguou), 0, 1, 0, 0},
-  {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
-  {&__pyx_n_s_niter, __pyx_k_niter, sizeof(__pyx_k_niter), 0, 0, 1, 1},
-  {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
-  {&__pyx_n_s_npix, __pyx_k_npix, sizeof(__pyx_k_npix), 0, 0, 1, 1},
-  {&__pyx_n_s_npix2nside, __pyx_k_npix2nside, sizeof(__pyx_k_npix2nside), 0, 0, 1, 1},
-  {&__pyx_n_s_nside, __pyx_k_nside, sizeof(__pyx_k_nside), 0, 0, 1, 1},
-  {&__pyx_n_s_nside2npix, __pyx_k_nside2npix, sizeof(__pyx_k_nside2npix), 0, 0, 1, 1},
-  {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
-  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
-  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
-  {&__pyx_n_s_phi, __pyx_k_phi, sizeof(__pyx_k_phi), 0, 0, 1, 1},
-  {&__pyx_n_s_polarization, __pyx_k_polarization, sizeof(__pyx_k_polarization), 0, 0, 1, 1},
-  {&__pyx_n_s_powspec, __pyx_k_powspec, sizeof(__pyx_k_powspec), 0, 0, 1, 1},
-  {&__pyx_n_s_psi, __pyx_k_psi, sizeof(__pyx_k_psi), 0, 0, 1, 1},
-  {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
-  {&__pyx_n_s_pyx_releasebuffer, __pyx_k_pyx_releasebuffer, sizeof(__pyx_k_pyx_releasebuffer), 0, 0, 1, 1},
-  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-  {&__pyx_n_s_rotate_alm, __pyx_k_rotate_alm, sizeof(__pyx_k_rotate_alm), 0, 0, 1, 1},
-  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
-  {&__pyx_n_s_spectra, __pyx_k_spectra, sizeof(__pyx_k_spectra), 0, 0, 1, 1},
-  {&__pyx_n_s_spin, __pyx_k_spin, sizeof(__pyx_k_spin), 0, 0, 1, 1},
-  {&__pyx_n_s_sqrt, __pyx_k_sqrt, sizeof(__pyx_k_sqrt), 0, 0, 1, 1},
-  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-  {&__pyx_n_s_theta, __pyx_k_theta, sizeof(__pyx_k_theta), 0, 0, 1, 1},
-  {&__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_k_unknown_dtype_code_in_numpy_pxd, sizeof(__pyx_k_unknown_dtype_code_in_numpy_pxd), 0, 1, 0, 0},
-  {&__pyx_n_s_use_weights, __pyx_k_use_weights, sizeof(__pyx_k_use_weights), 0, 0, 1, 1},
-  {&__pyx_n_s_w_arr, __pyx_k_w_arr, sizeof(__pyx_k_w_arr), 0, 0, 1, 1},
-  {&__pyx_kp_s_weight_ring_n_05d_fits, __pyx_k_weight_ring_n_05d_fits, sizeof(__pyx_k_weight_ring_n_05d_fits), 0, 0, 1, 0},
-  {&__pyx_n_s_weightfile, __pyx_k_weightfile, sizeof(__pyx_k_weightfile), 0, 0, 1, 1},
-  {&__pyx_n_s_xrange, __pyx_k_xrange, sizeof(__pyx_k_xrange), 0, 0, 1, 1},
-  {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
-  {&__pyx_n_s_zip, __pyx_k_zip, sizeof(__pyx_k_zip), 0, 0, 1, 1},
+  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
+  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
+  {&__pyx_kp_s_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 0, 1, 0},
+  {&__pyx_kp_s_13, __pyx_k_13, sizeof(__pyx_k_13), 0, 0, 1, 0},
+  {&__pyx_kp_s_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 1, 0},
+  {&__pyx_kp_s_16, __pyx_k_16, sizeof(__pyx_k_16), 0, 0, 1, 0},
+  {&__pyx_kp_s_18, __pyx_k_18, sizeof(__pyx_k_18), 0, 0, 1, 0},
+  {&__pyx_kp_s_20, __pyx_k_20, sizeof(__pyx_k_20), 0, 0, 1, 0},
+  {&__pyx_kp_u_23, __pyx_k_23, sizeof(__pyx_k_23), 0, 1, 0, 0},
+  {&__pyx_kp_u_25, __pyx_k_25, sizeof(__pyx_k_25), 0, 1, 0, 0},
+  {&__pyx_kp_u_27, __pyx_k_27, sizeof(__pyx_k_27), 0, 1, 0, 0},
+  {&__pyx_kp_u_29, __pyx_k_29, sizeof(__pyx_k_29), 0, 1, 0, 0},
+  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
+  {&__pyx_kp_u_30, __pyx_k_30, sizeof(__pyx_k_30), 0, 1, 0, 0},
+  {&__pyx_kp_u_33, __pyx_k_33, sizeof(__pyx_k_33), 0, 1, 0, 0},
+  {&__pyx_n_s_35, __pyx_k_35, sizeof(__pyx_k_35), 0, 0, 1, 1},
+  {&__pyx_n_s_36, __pyx_k_36, sizeof(__pyx_k_36), 0, 0, 1, 1},
+  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
+  {&__pyx_n_s__DATAPATH, __pyx_k__DATAPATH, sizeof(__pyx_k__DATAPATH), 0, 0, 1, 1},
+  {&__pyx_n_s__Exception, __pyx_k__Exception, sizeof(__pyx_k__Exception), 0, 0, 1, 1},
+  {&__pyx_n_s__IOError, __pyx_k__IOError, sizeof(__pyx_k__IOError), 0, 0, 1, 1},
+  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s____file__, __pyx_k____file__, sizeof(__pyx_k____file__), 0, 0, 1, 1},
+  {&__pyx_n_s____len__, __pyx_k____len__, sizeof(__pyx_k____len__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__abspath, __pyx_k__abspath, sizeof(__pyx_k__abspath), 0, 0, 1, 1},
+  {&__pyx_n_s__alm, __pyx_k__alm, sizeof(__pyx_k__alm), 0, 0, 1, 1},
+  {&__pyx_n_s__alm2cl, __pyx_k__alm2cl, sizeof(__pyx_k__alm2cl), 0, 0, 1, 1},
+  {&__pyx_n_s__alms, __pyx_k__alms, sizeof(__pyx_k__alms), 0, 0, 1, 1},
+  {&__pyx_n_s__alms2, __pyx_k__alms2, sizeof(__pyx_k__alms2), 0, 0, 1, 1},
+  {&__pyx_n_s__almxfl, __pyx_k__almxfl, sizeof(__pyx_k__almxfl), 0, 0, 1, 1},
+  {&__pyx_n_s__array, __pyx_k__array, sizeof(__pyx_k__array), 0, 0, 1, 1},
+  {&__pyx_n_s__ascontiguousarray, __pyx_k__ascontiguousarray, sizeof(__pyx_k__ascontiguousarray), 0, 0, 1, 1},
+  {&__pyx_n_s__complex128, __pyx_k__complex128, sizeof(__pyx_k__complex128), 0, 0, 1, 1},
+  {&__pyx_n_s__copy, __pyx_k__copy, sizeof(__pyx_k__copy), 0, 0, 1, 1},
+  {&__pyx_n_s__data, __pyx_k__data, sizeof(__pyx_k__data), 0, 0, 1, 1},
+  {&__pyx_n_s__datapath, __pyx_k__datapath, sizeof(__pyx_k__datapath), 0, 0, 1, 1},
+  {&__pyx_n_s__dirname, __pyx_k__dirname, sizeof(__pyx_k__dirname), 0, 0, 1, 1},
+  {&__pyx_n_s__dtype, __pyx_k__dtype, sizeof(__pyx_k__dtype), 0, 0, 1, 1},
+  {&__pyx_n_s__empty, __pyx_k__empty, sizeof(__pyx_k__empty), 0, 0, 1, 1},
+  {&__pyx_n_s__fl, __pyx_k__fl, sizeof(__pyx_k__fl), 0, 0, 1, 1},
+  {&__pyx_n_s__float64, __pyx_k__float64, sizeof(__pyx_k__float64), 0, 0, 1, 1},
+  {&__pyx_n_s__get_datapath, __pyx_k__get_datapath, sizeof(__pyx_k__get_datapath), 0, 0, 1, 1},
+  {&__pyx_n_s__healpy, __pyx_k__healpy, sizeof(__pyx_k__healpy), 0, 0, 1, 1},
+  {&__pyx_n_s__inplace, __pyx_k__inplace, sizeof(__pyx_k__inplace), 0, 0, 1, 1},
+  {&__pyx_n_s__int8, __pyx_k__int8, sizeof(__pyx_k__int8), 0, 0, 1, 1},
+  {&__pyx_n_s__isfile, __pyx_k__isfile, sizeof(__pyx_k__isfile), 0, 0, 1, 1},
+  {&__pyx_n_s__join, __pyx_k__join, sizeof(__pyx_k__join), 0, 0, 1, 1},
+  {&__pyx_n_s__lmax, __pyx_k__lmax, sizeof(__pyx_k__lmax), 0, 0, 1, 1},
+  {&__pyx_n_s__lmax_out, __pyx_k__lmax_out, sizeof(__pyx_k__lmax_out), 0, 0, 1, 1},
+  {&__pyx_n_s__m, __pyx_k__m, sizeof(__pyx_k__m), 0, 0, 1, 1},
+  {&__pyx_n_s__map2alm, __pyx_k__map2alm, sizeof(__pyx_k__map2alm), 0, 0, 1, 1},
+  {&__pyx_n_s__maptype, __pyx_k__maptype, sizeof(__pyx_k__maptype), 0, 0, 1, 1},
+  {&__pyx_n_s__mmax, __pyx_k__mmax, sizeof(__pyx_k__mmax), 0, 0, 1, 1},
+  {&__pyx_n_s__niter, __pyx_k__niter, sizeof(__pyx_k__niter), 0, 0, 1, 1},
+  {&__pyx_n_s__np, __pyx_k__np, sizeof(__pyx_k__np), 0, 0, 1, 1},
+  {&__pyx_n_s__npix2nside, __pyx_k__npix2nside, sizeof(__pyx_k__npix2nside), 0, 0, 1, 1},
+  {&__pyx_n_s__numpy, __pyx_k__numpy, sizeof(__pyx_k__numpy), 0, 0, 1, 1},
+  {&__pyx_n_s__os, __pyx_k__os, sizeof(__pyx_k__os), 0, 0, 1, 1},
+  {&__pyx_n_s__path, __pyx_k__path, sizeof(__pyx_k__path), 0, 0, 1, 1},
+  {&__pyx_n_s__pi, __pyx_k__pi, sizeof(__pyx_k__pi), 0, 0, 1, 1},
+  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
+  {&__pyx_n_s__regression, __pyx_k__regression, sizeof(__pyx_k__regression), 0, 0, 1, 1},
+  {&__pyx_n_s__size, __pyx_k__size, sizeof(__pyx_k__size), 0, 0, 1, 1},
+  {&__pyx_n_s__sqrt, __pyx_k__sqrt, sizeof(__pyx_k__sqrt), 0, 0, 1, 1},
+  {&__pyx_n_s__use_weights, __pyx_k__use_weights, sizeof(__pyx_k__use_weights), 0, 0, 1, 1},
+  {&__pyx_n_s__xrange, __pyx_k__xrange, sizeof(__pyx_k__xrange), 0, 0, 1, 1},
+  {&__pyx_n_s__zeros, __pyx_k__zeros, sizeof(__pyx_k__zeros), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_zip = __Pyx_GetBuiltinName(__pyx_n_s_zip); if (!__pyx_builtin_zip) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_IOError = __Pyx_GetBuiltinName(__pyx_n_s_IOError); if (!__pyx_builtin_IOError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_n_s__Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_IOError = __Pyx_GetName(__pyx_b, __pyx_n_s__IOError); if (!__pyx_builtin_IOError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_range = __Pyx_GetName(__pyx_b, __pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   #if PY_MAJOR_VERSION >= 3
-  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_xrange = __Pyx_GetName(__pyx_b, __pyx_n_s__range); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   #else
-  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_xrange); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_xrange = __Pyx_GetName(__pyx_b, __pyx_n_s__xrange); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   #endif
-  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants");
 
-  /* "healpy/src/_sphtools.pyx":99
- *     # Check all maps have same npix
- *     if maps_c[1].size != npix:
- *         raise ValueError("Input maps must have same size")             # <<<<<<<<<<<<<<
+  /* "healpy/src/_sphtools.pyx":69
+ * cdef Num_Alms(int l, int m):
+ *     if not m <= l:
+ *         raise ValueError("mmax must be <= lmax")             # <<<<<<<<<<<<<<
+ *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
  * 
- *     # View the ndarray as a Healpix_Map
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Input_maps_must_have_same_size); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
+  __pyx_k_tuple_2 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_2));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_1));
+  PyTuple_SET_ITEM(__pyx_k_tuple_2, 0, ((PyObject *)__pyx_kp_s_1));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_1));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_2));
 
-  /* "healpy/src/_sphtools.pyx":214
- *         mu = np.ascontiguousarray(m[2], dtype=np.float64)
+  /* "healpy/src/_sphtools.pyx":82
+ *     def __init__(self, np.ndarray[double] m):
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')             # <<<<<<<<<<<<<<
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
+ */
+  __pyx_k_tuple_4 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_4));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
+  PyTuple_SET_ITEM(__pyx_k_tuple_4, 0, ((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));
+
+  /* "healpy/src/_sphtools.pyx":104
+ *     def __init__(self, np.ndarray[np.complex128_t] m, int lmax, int mmax):
+ *         if self.is_init == 1:
+ *             raise Exception('Already init...')             # <<<<<<<<<<<<<<
+ *         self.is_init = 1
+ *         self.m = np.ascontiguousarray(m)
+ */
+  __pyx_k_tuple_5 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_5));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
+  PyTuple_SET_ITEM(__pyx_k_tuple_5, 0, ((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_5));
+
+  /* "healpy/src/_sphtools.pyx":163
+ *         mmu = m[2]
  *     else:
  *         raise ValueError("Wrong input map (must be a valid healpix map "             # <<<<<<<<<<<<<<
  *                          "or a sequence of 1 or 3 maps)")
  * 
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Wrong_input_map_must_be_a_valid); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_k_tuple_9 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_9));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_8));
+  PyTuple_SET_ITEM(__pyx_k_tuple_9, 0, ((PyObject *)__pyx_kp_s_8));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_8));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_9));
 
-  /* "healpy/src/_sphtools.pyx":240
+  /* "healpy/src/_sphtools.pyx":203
  *     if polarization:
  *         if mq.size != npix or mu.size != npix:
  *             raise ValueError("Input maps must have same size")             # <<<<<<<<<<<<<<
  * 
- *     # View the ndarray as a Healpix_Map
+ *     # Wrap the map into an Healpix_Map
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_Input_maps_must_have_same_size); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
+  __pyx_k_tuple_11 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_11));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_10));
+  PyTuple_SET_ITEM(__pyx_k_tuple_11, 0, ((PyObject *)__pyx_kp_s_10));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_10));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_11));
 
-  /* "healpy/src/_sphtools.pyx":348
+  /* "healpy/src/_sphtools.pyx":311
  *     cdef int Nspec, Nspec2
  *     if not hasattr(alms, '__len__'):
  *         raise ValueError('alms must be an array or a sequence of arrays')             # <<<<<<<<<<<<<<
  *     if not hasattr(alms[0], '__len__'):
  *         alms_lonely = True
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_alms_must_be_an_array_or_a_seque); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_k_tuple_15 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_15));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_14));
+  PyTuple_SET_ITEM(__pyx_k_tuple_15, 0, ((PyObject *)__pyx_kp_s_14));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_14));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_15));
 
-  /* "healpy/src/_sphtools.pyx":361
+  /* "healpy/src/_sphtools.pyx":324
  * 
  *     if not hasattr(alms2, '__len__'):
  *         raise ValueError('alms2 must be an array or a sequence of arrays')             # <<<<<<<<<<<<<<
  *     if not hasattr(alms2[0], '__len__'):
  *         alms2 = [alms2]
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_alms2_must_be_an_array_or_a_sequ); if (unlikely(!__pyx_tuple__5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_k_tuple_17 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_17)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_17));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_16));
+  PyTuple_SET_ITEM(__pyx_k_tuple_17, 0, ((PyObject *)__pyx_kp_s_16));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_16));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_17));
 
-  /* "healpy/src/_sphtools.pyx":367
+  /* "healpy/src/_sphtools.pyx":330
  * 
  *     if Nspec != Nspec2:
  *         raise ValueError('alms and alms2 must have same number of spectra')             # <<<<<<<<<<<<<<
  * 
  *     ##############################################
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_alms_and_alms2_must_have_same_nu); if (unlikely(!__pyx_tuple__6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_k_tuple_19 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_19)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_19));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_18));
+  PyTuple_SET_ITEM(__pyx_k_tuple_19, 0, ((PyObject *)__pyx_kp_s_18));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_18));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_19));
 
-  /* "healpy/src/_sphtools.pyx":376
+  /* "healpy/src/_sphtools.pyx":339
  *     for i in xrange(Nspec):
  *         if alms[i].size != almsize or alms2[i].size != almsize:
  *             raise ValueError('all alms must have same size')             # <<<<<<<<<<<<<<
  * 
- *     lmax, mmax = alm_getlmmax(alms[0], lmax, mmax)
- */
-  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_all_alms_must_have_same_size); if (unlikely(!__pyx_tuple__7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
-
-  /* "healpy/src/_sphtools.pyx":505
- * 
- *     if not isinstance(alm, (list, tuple, np.ndarray)) or len(alm) == 0:
- *         raise ValueError('Invalid input.')             # <<<<<<<<<<<<<<
- * 
- *     # C++ rotate_alm only handles 1 or 3 maps. The function handling 3 maps
- */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_Invalid_input); if (unlikely(!__pyx_tuple__8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
-
-  /* "healpy/src/_sphtools.pyx":532
- * cdef int alm_getn(int l, int m):
- *     if not m <= l:
- *         raise ValueError("mmax must be <= lmax")             # <<<<<<<<<<<<<<
- *     return ((m+1)*(m+2))/2 + (m+1)*(l-m)
- * 
+ *     if lmax is None:
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_mmax_must_be_lmax); if (unlikely(!__pyx_tuple__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
+  __pyx_k_tuple_21 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_21));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_20));
+  PyTuple_SET_ITEM(__pyx_k_tuple_21, 0, ((PyObject *)__pyx_kp_s_20));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_20));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_21));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":215
+  /* "numpy.pxd":211
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_C_contiguous); if (unlikely(!__pyx_tuple__10)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_k_tuple_24 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_24)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_24));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_23));
+  PyTuple_SET_ITEM(__pyx_k_tuple_24, 0, ((PyObject *)__pyx_kp_u_23));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_23));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_24));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":219
+  /* "numpy.pxd":215
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_Fortran_contiguou); if (unlikely(!__pyx_tuple__11)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
-
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":257
- *                 if ((descr.byteorder == c'>' and little_endian) or
- *                     (descr.byteorder == c'<' and not little_endian)):
+  __pyx_k_tuple_26 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_26)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_26));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_25));
+  PyTuple_SET_ITEM(__pyx_k_tuple_26, 0, ((PyObject *)__pyx_kp_u_25));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_25));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_26));
+
+  /* "numpy.pxd":253
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__12)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_k_tuple_28 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_28)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_28));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_27));
+  PyTuple_SET_ITEM(__pyx_k_tuple_28, 0, ((PyObject *)__pyx_kp_u_27));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_27));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_28));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":799
+  /* "numpy.pxd":795
  * 
- *         if (end - f) - <int>(new_offset - offset[0]) < 15:
+ *         if (end - f) - (new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
- *         if ((child.byteorder == c'>' and little_endian) or
+ *         if ((child.byteorder == '>' and little_endian) or
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor); if (unlikely(!__pyx_tuple__13)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
-
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":803
- *         if ((child.byteorder == c'>' and little_endian) or
- *             (child.byteorder == c'<' and not little_endian)):
+  __pyx_k_tuple_31 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_31)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_31));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_30));
+  PyTuple_SET_ITEM(__pyx_k_tuple_31, 0, ((PyObject *)__pyx_kp_u_30));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_30));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_31));
+
+  /* "numpy.pxd":799
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__14)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_k_tuple_32 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_32)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_32));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_27));
+  PyTuple_SET_ITEM(__pyx_k_tuple_32, 0, ((PyObject *)__pyx_kp_u_27));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_27));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_32));
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":823
+  /* "numpy.pxd":819
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor_2); if (unlikely(!__pyx_tuple__15)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
-
-  /* "healpy/src/_sphtools.pyx":54
- * DATAPATH = None
- * 
- * def get_datapath():             # <<<<<<<<<<<<<<
- *     global DATAPATH
- *     if DATAPATH is None:
- */
-  __pyx_codeobj__16 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_get_datapath, 54, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__16)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":60
- *     return DATAPATH
- * 
- * def map2alm_spin_healpy(maps, spin, lmax = None, mmax = None):             # <<<<<<<<<<<<<<
- *     """Computes the spinned alm of a 2 Healpix maps.
- * 
- */
-  __pyx_tuple__17 = PyTuple_Pack(21, __pyx_n_s_maps, __pyx_n_s_spin, __pyx_n_s_lmax, __pyx_n_s_mmax, __pyx_n_s_maps_c, __pyx_n_s_masks, __pyx_n_s_lmax_2, __pyx_n_s_mmax_2, __pyx_n_s_nside, __pyx_n_s_npix, __pyx_n_s_M1, __pyx_n_s_M2, __pyx_n_s_m, __pyx_n_s_mask, __pyx_n_s_n_alm, __pyx_n_s_alms, __pyx_n_s_A1, __pyx_n_s_A2, __pyx_n_s_w_arr, __pyx_n_s_i, __pyx_n_s_c_datapath); if (unlikely(!__pyx_tuple__17)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
-  __pyx_codeobj__18 = (PyObject*)__Pyx_PyCode_New(4, 0, 21, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__17, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_map2alm_spin_healpy, 60, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__18)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":136
- *     return alms
- * 
- * def alm2map_spin_healpy(alms, nside, spin, lmax, mmax=None):             # <<<<<<<<<<<<<<
- *     """Computes maps from a set of 2 spinned alm
- * 
- */
-  __pyx_tuple__19 = PyTuple_Pack(13, __pyx_n_s_alms, __pyx_n_s_nside, __pyx_n_s_spin, __pyx_n_s_lmax, __pyx_n_s_mmax, __pyx_n_s_alms_c, __pyx_n_s_npix, __pyx_n_s_maps, __pyx_n_s_M1, __pyx_n_s_M2, __pyx_n_s_A1, __pyx_n_s_A2, __pyx_n_s_alm); if (unlikely(!__pyx_tuple__19)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(5, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_alm2map_spin_healpy, 136, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":178
- *     return maps
- * 
- * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
- *             datapath = None):
- *     """Computes the alm of a Healpix map.
- */
-  __pyx_tuple__21 = PyTuple_Pack(32, __pyx_n_s_m, __pyx_n_s_lmax, __pyx_n_s_mmax, __pyx_n_s_niter, __pyx_n_s_use_weights, __pyx_n_s_datapath, __pyx_n_s_info, __pyx_n_s_polarization, __pyx_n_s_mi, __pyx_n_s_mq, __pyx_n_s_mu, __pyx_n_s_mask_mi, __pyx_n_s_mask_mq, __pyx_n_s_mask_mu, __pyx_n_s_lmax_2, __pyx_n_s_mmax_2, __pyx_n_s_nside, __pyx_n_s_npix, __pyx_n_s_MI, __pyx_n_s_MQ, __pyx_n_s_MU, __pyx_n_s_n_alm, __pyx_n_s_almI, __pyx_n_s_almG, __pyx_n_s_almC, __pyx_n_s_AI, __pyx_n_s_AG, __pyx_n_s_AC, __pyx_n_s_w_arr, __pyx_n_s_i, __pyx_n_s_c_datapath, __pyx_n_s_weightfile); if (unlikely(!__pyx_tuple__21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(6, 0, 32, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_map2alm, 178, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":311
- * 
- * 
- * def alm2cl(alms, alms2 = None, lmax = None, mmax = None, lmax_out = None):             # <<<<<<<<<<<<<<
- *     """Computes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between
- *     alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,
- */
-  __pyx_tuple__23 = PyTuple_Pack(22, __pyx_n_s_alms, __pyx_n_s_alms2, __pyx_n_s_lmax, __pyx_n_s_mmax, __pyx_n_s_lmax_out, __pyx_n_s_Nspec, __pyx_n_s_Nspec2, __pyx_n_s_alms_lonely, __pyx_n_s_almsize, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_l, __pyx_n_s_m, __pyx_n_s_limit, __pyx_n_s_lmax_2, __pyx_n_s_mmax_2, __pyx_n_s_lmax_out_2, __pyx_n_s_powspec, __pyx_n_s_alm1, __pyx_n_s_alm2, __pyx_n_s_spectra, __pyx_n_s_n); if (unlikely(!__pyx_tuple__23)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__23);
-  __Pyx_GIVEREF(__pyx_tuple__23);
-  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(5, 0, 22, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_alm2cl, 311, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":423
- * @cython.wraparound(False)
- * @cython.boundscheck(False)
- * def almxfl(alm, fl, mmax = None, inplace = False):             # <<<<<<<<<<<<<<
- *     """Multiply an a_lm by a vector b_l.
- * 
- */
-  __pyx_tuple__25 = PyTuple_Pack(14, __pyx_n_s_alm, __pyx_n_s_fl, __pyx_n_s_mmax, __pyx_n_s_inplace, __pyx_n_s_alm_2, __pyx_n_s_fl_2, __pyx_n_s_lmax_2, __pyx_n_s_mmax_2, __pyx_n_s_l, __pyx_n_s_m, __pyx_n_s_f, __pyx_n_s_maxm, __pyx_n_s_i, __pyx_n_s_flsize); if (unlikely(!__pyx_tuple__25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
-  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(4, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_almxfl, 423, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":472
- * 
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,             # <<<<<<<<<<<<<<
- *                mmax=None):
- *     """
- */
-  __pyx_tuple__27 = PyTuple_Pack(13, __pyx_n_s_alm, __pyx_n_s_psi, __pyx_n_s_theta, __pyx_n_s_phi, __pyx_n_s_lmax, __pyx_n_s_mmax, __pyx_n_s_a, __pyx_n_s_ai, __pyx_n_s_AI, __pyx_n_s_ag, __pyx_n_s_ac, __pyx_n_s_AG, __pyx_n_s_AC); if (unlikely(!__pyx_tuple__27)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
-  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(6, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_rotate_alm, 472, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-
-  /* "healpy/src/_sphtools.pyx":536
- * 
- * 
- * def alm_getlmmax(a, lmax, mmax):             # <<<<<<<<<<<<<<
- *     if lmax is None:
- *         if mmax is None:
- */
-  __pyx_tuple__29 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_lmax, __pyx_n_s_mmax); if (unlikely(!__pyx_tuple__29)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_tuple__29);
-  __Pyx_GIVEREF(__pyx_tuple__29);
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_zonca_healpy_healpy_src__s, __pyx_n_s_alm_getlmmax, 536, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_k_tuple_34 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_34)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_34));
+  __Pyx_INCREF(((PyObject *)__pyx_kp_u_33));
+  PyTuple_SET_ITEM(__pyx_k_tuple_34, 0, ((PyObject *)__pyx_kp_u_33));
+  __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_33));
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_34));
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  __pyx_float_0_0 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_float_0_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_int_neg_3 = PyInt_FromLong(-3); if (unlikely(!__pyx_int_neg_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_neg_3 = PyInt_FromLong(-3); if (unlikely(!__pyx_int_neg_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 #if PY_MAJOR_VERSION < 3
 PyMODINIT_FUNC init_sphtools(void); /*proto*/
@@ -10686,309 +8555,263 @@
 #else
 PyMODINIT_FUNC PyInit__sphtools(void); /*proto*/
 PyMODINIT_FUNC PyInit__sphtools(void)
 #endif
 {
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_REFNANNY
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
   if (!__Pyx_RefNanny) {
       PyErr_Clear();
       __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
       if (!__Pyx_RefNanny)
           Py_FatalError("failed to import 'refnanny' module");
   }
   #endif
-  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__sphtools(void)", 0);
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__sphtools(void)");
   if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #ifdef __Pyx_CyFunction_USED
-  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
-  #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __pyx_binding_PyCFunctionType_USED
+  if (__pyx_binding_PyCFunctionType_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   #ifdef WITH_THREAD /* Python build with threading support? */
   PyEval_InitThreads();
   #endif
   #endif
   /*--- Module creation code ---*/
   #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_sphtools"), __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_sphtools"), __pyx_methods, 0, 0, PYTHON_API_VERSION);
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   #endif
-  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #if CYTHON_COMPILING_IN_PYPY
-  Py_INCREF(__pyx_b);
+  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  #if PY_MAJOR_VERSION < 3
+  Py_INCREF(__pyx_m);
   #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
+  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   /*--- Initialize various global constants etc. ---*/
   if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
-  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  #endif
   if (__pyx_module_is_main_healpy___sphtools) {
-    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-  }
-  #if PY_MAJOR_VERSION >= 3
-  {
-    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    if (!PyDict_GetItemString(modules, "healpy._sphtools")) {
-      if (unlikely(PyDict_SetItemString(modules, "healpy._sphtools", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    }
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   }
-  #endif
   /*--- Builtin init code ---*/
   if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Constants init code ---*/
   if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Global init code ---*/
   /*--- Variable export code ---*/
   /*--- Function export code ---*/
   /*--- Type init code ---*/
+  if (PyType_Ready(&__pyx_type_6healpy_9_sphtools_WrapMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "WrapMap", (PyObject *)&__pyx_type_6healpy_9_sphtools_WrapMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_6healpy_9_sphtools_WrapMap = &__pyx_type_6healpy_9_sphtools_WrapMap;
+  if (PyType_Ready(&__pyx_type_6healpy_9_sphtools_WrapAlm) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "WrapAlm", (PyObject *)&__pyx_type_6healpy_9_sphtools_WrapAlm) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_6healpy_9_sphtools_WrapAlm = &__pyx_type_6healpy_9_sphtools_WrapAlm;
   /*--- Type import code ---*/
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
-  #if CYTHON_COMPILING_IN_PYPY
-  sizeof(PyTypeObject),
-  #else
-  sizeof(PyHeapTypeObject),
-  #endif
-  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   /*--- Variable import code ---*/
   /*--- Function import code ---*/
   /*--- Execution code ---*/
 
-  /* "healpy/src/_sphtools.pyx":4
+  /* "healpy/src/_sphtools.pyx":3
  * # Wrapper around the query_disc method of Healpix_base class
  * 
  * import numpy as np             # <<<<<<<<<<<<<<
  * cimport numpy as np
- * from libcpp.string cimport string
+ * #from libcpp cimport bool
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__numpy), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__np, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":9
+  /* "healpy/src/_sphtools.pyx":10
  * from libc.math cimport sqrt, floor, fabs
  * cimport libc
- * from healpy import npix2nside, nside2npix             # <<<<<<<<<<<<<<
+ * from healpy import npix2nside             # <<<<<<<<<<<<<<
  * from healpy.pixelfunc import maptype
- * import os
+ * ctypedef unsigned size_t
  */
-  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(__pyx_n_s_npix2nside);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_npix2nside);
-  __Pyx_GIVEREF(__pyx_n_s_npix2nside);
-  __Pyx_INCREF(__pyx_n_s_nside2npix);
-  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_nside2npix);
-  __Pyx_GIVEREF(__pyx_n_s_nside2npix);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_healpy, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__npix2nside));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__npix2nside));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__npix2nside));
+  __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s__healpy), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_npix2nside); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_npix2nside, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_nside2npix); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_GetAttr(__pyx_t_2, __pyx_n_s__npix2nside); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nside2npix, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__npix2nside, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "healpy/src/_sphtools.pyx":10
+  /* "healpy/src/_sphtools.pyx":11
  * cimport libc
- * from healpy import npix2nside, nside2npix
+ * from healpy import npix2nside
  * from healpy.pixelfunc import maptype             # <<<<<<<<<<<<<<
- * import os
- * import cython
+ * ctypedef unsigned size_t
+ * ctypedef size_t tsize
  */
-  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_n_s_maptype);
-  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_maptype);
-  __Pyx_GIVEREF(__pyx_n_s_maptype);
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_healpy_pixelfunc, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__maptype));
+  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__maptype));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__maptype));
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s_35), ((PyObject *)__pyx_t_2), -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_maptype); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__maptype); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_maptype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__maptype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":11
- * from healpy import npix2nside, nside2npix
- * from healpy.pixelfunc import maptype
+  /* "healpy/src/_sphtools.pyx":14
+ * ctypedef unsigned size_t
+ * ctypedef size_t tsize
  * import os             # <<<<<<<<<<<<<<
  * import cython
- * from libcpp cimport bool as cbool
+ * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__os), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__os, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "healpy/src/_sphtools.pyx":17
- * from _common cimport tsize, arr, xcomplex, Healpix_Ordering_Scheme, RING, NEST, Healpix_Map, Alm, ndarray2map, ndarray2alm
+ * import cython
  * 
  * cdef double UNSEEN = -1.6375e30             # <<<<<<<<<<<<<<
  * cdef double rtol_UNSEEN = 1.e-7 * 1.6375e30
  * 
  */
   __pyx_v_6healpy_9_sphtools_UNSEEN = -1.6375e30;
 
   /* "healpy/src/_sphtools.pyx":18
  * 
  * cdef double UNSEEN = -1.6375e30
  * cdef double rtol_UNSEEN = 1.e-7 * 1.6375e30             # <<<<<<<<<<<<<<
  * 
- * cdef extern from "alm_healpix_tools.h":
+ * cdef extern from "arr.h":
  */
   __pyx_v_6healpy_9_sphtools_rtol_UNSEEN = (1.e-7 * 1.6375e30);
 
-  /* "healpy/src/_sphtools.pyx":52
- *     cdef void read_weight_ring (string &dir, int nside, arr[double] &weight)
+  /* "healpy/src/_sphtools.pyx":117
+ *             del self.a, self.h
  * 
  * DATAPATH = None             # <<<<<<<<<<<<<<
  * 
  * def get_datapath():
  */
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DATAPATH, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__DATAPATH, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
-  /* "healpy/src/_sphtools.pyx":54
+  /* "healpy/src/_sphtools.pyx":119
  * DATAPATH = None
  * 
  * def get_datapath():             # <<<<<<<<<<<<<<
  *     global DATAPATH
  *     if DATAPATH is None:
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_1get_datapath, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_get_datapath, NULL, __pyx_n_s_36); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_datapath, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__get_datapath, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":60
+  /* "healpy/src/_sphtools.pyx":125
  *     return DATAPATH
  * 
- * def map2alm_spin_healpy(maps, spin, lmax = None, mmax = None):             # <<<<<<<<<<<<<<
- *     """Computes the spinned alm of a 2 Healpix maps.
- * 
+ * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
+ *             regression = True, datapath = None):
+ *     """Computes the alm of an Healpix map.
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_3map2alm_spin_healpy, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_map2alm_spin_healpy, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_k_6 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":136
- *     return alms
+  /* "healpy/src/_sphtools.pyx":126
  * 
- * def alm2map_spin_healpy(alms, nside, spin, lmax, mmax=None):             # <<<<<<<<<<<<<<
- *     """Computes maps from a set of 2 spinned alm
+ * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,
+ *             regression = True, datapath = None):             # <<<<<<<<<<<<<<
+ *     """Computes the alm of an Healpix map.
  * 
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_5alm2map_spin_healpy, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_alm2map_spin_healpy, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_k_7 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":178
- *     return maps
+  /* "healpy/src/_sphtools.pyx":125
+ *     return DATAPATH
  * 
  * def map2alm(m, lmax = None, mmax = None, niter = 3, use_weights = False,             # <<<<<<<<<<<<<<
- *             datapath = None):
- *     """Computes the alm of a Healpix map.
+ *             regression = True, datapath = None):
+ *     """Computes the alm of an Healpix map.
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_7map2alm, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_1map2alm, NULL, __pyx_n_s_36); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_map2alm, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__map2alm, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":311
+  /* "healpy/src/_sphtools.pyx":274
  * 
  * 
  * def alm2cl(alms, alms2 = None, lmax = None, mmax = None, lmax_out = None):             # <<<<<<<<<<<<<<
  *     """Computes (cross-)spectra from alm(s). If alm2 is given, cross-spectra between
  *     alm and alm2 are computed. If alm (and alm2 if provided) contains n alm,
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_9alm2cl, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_2alm2cl, NULL, __pyx_n_s_36); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_alm2cl, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__alm2cl, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "healpy/src/_sphtools.pyx":423
+  /* "healpy/src/_sphtools.pyx":394
  * @cython.wraparound(False)
  * @cython.boundscheck(False)
  * def almxfl(alm, fl, mmax = None, inplace = False):             # <<<<<<<<<<<<<<
  *     """Multiply an a_lm by a vector b_l.
  * 
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_11almxfl, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_almxfl, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "healpy/src/_sphtools.pyx":472
- * 
- * 
- * def rotate_alm(alm not None, double psi, double theta, double phi, lmax=None,             # <<<<<<<<<<<<<<
- *                mmax=None):
- *     """
- */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_13rotate_alm, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rotate_alm, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "healpy/src/_sphtools.pyx":536
- * 
- * 
- * def alm_getlmmax(a, lmax, mmax):             # <<<<<<<<<<<<<<
- *     if lmax is None:
- *         if mmax is None:
- */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_15alm_getlmmax, NULL, __pyx_n_s_healpy__sphtools); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_k_22 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6healpy_9_sphtools_3almxfl, NULL, __pyx_n_s_36); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_alm_getlmmax, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__almxfl, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "healpy/src/_sphtools.pyx":1
- * # coding: utf-8             # <<<<<<<<<<<<<<
- * # Wrapper around the query_disc method of Healpix_base class
+ * # Wrapper around the query_disc method of Healpix_base class             # <<<<<<<<<<<<<<
  * 
+ * import numpy as np
  */
   __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
 
-  /* "/usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":976
+  /* "numpy.pxd":971
  *      arr.base = baseptr
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     if arr.base is NULL:
  *         return None
  */
   goto __pyx_L0;
@@ -11007,14 +8830,15 @@
   return;
   #else
   return __pyx_m;
   #endif
 }
 
 /* Runtime support code */
+
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
     m = PyImport_ImportModule((char *)modname);
     if (!m) goto end;
     p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
@@ -11023,533 +8847,351 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif /* CYTHON_REFNANNY */
 
-static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
-    if (unlikely(!result)) {
-        PyErr_Format(PyExc_NameError,
-#if PY_MAJOR_VERSION >= 3
-            "name '%U' is not defined", name);
-#else
-            "name '%.200s' is not defined", PyString_AS_STRING(name));
-#endif
-    }
-    return result;
-}
-
-static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
     PyObject *result;
-#if CYTHON_COMPILING_IN_CPYTHON
-    result = PyDict_GetItem(__pyx_d, name);
-    if (result) {
-        Py_INCREF(result);
-    } else {
-#else
-    result = PyObject_GetItem(__pyx_d, name);
+    result = PyObject_GetAttr(dict, name);
     if (!result) {
-        PyErr_Clear();
-#endif
-        result = __Pyx_GetBuiltinName(name);
-    }
-    return result;
-}
-
-static void __Pyx_RaiseArgtupleInvalid(
-    const char* func_name,
-    int exact,
-    Py_ssize_t num_min,
-    Py_ssize_t num_max,
-    Py_ssize_t num_found)
-{
-    Py_ssize_t num_expected;
-    const char *more_or_less;
-    if (num_found < num_min) {
-        num_expected = num_min;
-        more_or_less = "at least";
-    } else {
-        num_expected = num_max;
-        more_or_less = "at most";
-    }
-    if (exact) {
-        more_or_less = "exactly";
-    }
-    PyErr_Format(PyExc_TypeError,
-                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                 func_name, more_or_less, num_expected,
-                 (num_expected == 1) ? "" : "s", num_found);
-}
-
-static void __Pyx_RaiseDoubleKeywordsError(
-    const char* func_name,
-    PyObject* kw_name)
-{
-    PyErr_Format(PyExc_TypeError,
-        #if PY_MAJOR_VERSION >= 3
-        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
-        #else
-        "%s() got multiple values for keyword argument '%s'", func_name,
-        PyString_AsString(kw_name));
-        #endif
-}
-
-static int __Pyx_ParseOptionalKeywords(
-    PyObject *kwds,
-    PyObject **argnames[],
-    PyObject *kwds2,
-    PyObject *values[],
-    Py_ssize_t num_pos_args,
-    const char* function_name)
-{
-    PyObject *key = 0, *value = 0;
-    Py_ssize_t pos = 0;
-    PyObject*** name;
-    PyObject*** first_kw_arg = argnames + num_pos_args;
-    while (PyDict_Next(kwds, &pos, &key, &value)) {
-        name = first_kw_arg;
-        while (*name && (**name != key)) name++;
-        if (*name) {
-            values[name-argnames] = value;
-            continue;
-        }
-        name = first_kw_arg;
-        #if PY_MAJOR_VERSION < 3
-        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
-            while (*name) {
-                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
-                        && _PyString_Eq(**name, key)) {
-                    values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    if ((**argname == key) || (
-                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
-                             && _PyString_Eq(**argname, key))) {
-                        goto arg_passed_twice;
-                    }
-                    argname++;
-                }
-            }
-        } else
-        #endif
-        if (likely(PyUnicode_Check(key))) {
-            while (*name) {
-                int cmp = (**name == key) ? 0 :
-                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
-                #endif
-                    PyUnicode_Compare(**name, key);
-                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                if (cmp == 0) {
-                    values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    int cmp = (**argname == key) ? 0 :
-                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
-                    #endif
-                        PyUnicode_Compare(**argname, key);
-                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                    if (cmp == 0) goto arg_passed_twice;
-                    argname++;
-                }
-            }
-        } else
-            goto invalid_keyword_type;
-        if (kwds2) {
-            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
-        } else {
-            goto invalid_keyword;
-        }
-    }
-    return 0;
-arg_passed_twice:
-    __Pyx_RaiseDoubleKeywordsError(function_name, key);
-    goto bad;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    goto bad;
-invalid_keyword:
-    PyErr_Format(PyExc_TypeError,
-    #if PY_MAJOR_VERSION < 3
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
-bad:
-    return -1;
-}
-
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
-    }
-    if (likely(PyObject_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
-    return 0;
-}
-
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (!j) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
-    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
-    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
-                                                     int is_list, int wraparound, int boundscheck) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
+        if (dict != __pyx_b) {
+            PyErr_Clear();
+            result = PyObject_GetAttr(__pyx_b, name);
         }
-    } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
-                        PyErr_Clear();
-                    else
-                        return NULL;
-                }
-            }
-            return m->sq_item(o, i);
+        if (!result) {
+            PyErr_SetObject(PyExc_NameError, name);
         }
     }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
-    }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+    return result;
 }
 
 static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
-#if CYTHON_COMPILING_IN_CPYTHON
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     PyThreadState *tstate = PyThreadState_GET();
+
     tmp_type = tstate->curexc_type;
     tmp_value = tstate->curexc_value;
     tmp_tb = tstate->curexc_traceback;
     tstate->curexc_type = type;
     tstate->curexc_value = value;
     tstate->curexc_traceback = tb;
     Py_XDECREF(tmp_type);
     Py_XDECREF(tmp_value);
     Py_XDECREF(tmp_tb);
-#else
-    PyErr_Restore(type, value, tb);
-#endif
 }
+
 static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
-#if CYTHON_COMPILING_IN_CPYTHON
     PyThreadState *tstate = PyThreadState_GET();
     *type = tstate->curexc_type;
     *value = tstate->curexc_value;
     *tb = tstate->curexc_traceback;
+
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
-#else
-    PyErr_Fetch(type, value, tb);
-#endif
 }
 
+
 #if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
-                        CYTHON_UNUSED PyObject *cause) {
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    /* cause is unused */
     Py_XINCREF(type);
-    if (!value || value == Py_None)
-        value = NULL;
-    else
+    Py_XINCREF(value);
+    Py_XINCREF(tb);
+    /* First, check the traceback argument, replacing None with NULL. */
+    if (tb == Py_None) {
+        Py_DECREF(tb);
+        tb = 0;
+    }
+    else if (tb != NULL && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto raise_error;
+    }
+    /* Next, replace a missing value with None */
+    if (value == NULL) {
+        value = Py_None;
         Py_INCREF(value);
-    if (!tb || tb == Py_None)
-        tb = NULL;
-    else {
-        Py_INCREF(tb);
-        if (!PyTraceBack_Check(tb)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: arg 3 must be a traceback or None");
-            goto raise_error;
-        }
     }
     #if PY_VERSION_HEX < 0x02050000
-    if (PyClass_Check(type)) {
+    if (!PyClass_Check(type))
     #else
-    if (PyType_Check(type)) {
+    if (!PyType_Check(type))
     #endif
-#if CYTHON_COMPILING_IN_PYPY
-        if (!value) {
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-#endif
-        PyErr_NormalizeException(&type, &value, &tb);
-    } else {
-        if (value) {
+    {
+        /* Raising an instance.  The value should be a dummy. */
+        if (value != Py_None) {
             PyErr_SetString(PyExc_TypeError,
                 "instance exception may not have a separate value");
             goto raise_error;
         }
+        /* Normalize to raise <class>, <instance> */
+        Py_DECREF(value);
         value = type;
         #if PY_VERSION_HEX < 0x02050000
-        if (PyInstance_Check(type)) {
-            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
-            Py_INCREF(type);
-        } else {
-            type = 0;
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception must be an old-style class or instance");
-            goto raise_error;
-        }
+            if (PyInstance_Check(type)) {
+                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+                Py_INCREF(type);
+            }
+            else {
+                type = 0;
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception must be an old-style class or instance");
+                goto raise_error;
+            }
         #else
-        type = (PyObject*) Py_TYPE(type);
-        Py_INCREF(type);
-        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception class must be a subclass of BaseException");
-            goto raise_error;
-        }
+            type = (PyObject*) Py_TYPE(type);
+            Py_INCREF(type);
+            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception class must be a subclass of BaseException");
+                goto raise_error;
+            }
         #endif
     }
+
     __Pyx_ErrRestore(type, value, tb);
     return;
 raise_error:
     Py_XDECREF(value);
     Py_XDECREF(type);
     Py_XDECREF(tb);
     return;
 }
+
 #else /* Python 3+ */
+
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
-    PyObject* owned_instance = NULL;
     if (tb == Py_None) {
         tb = 0;
     } else if (tb && !PyTraceBack_Check(tb)) {
         PyErr_SetString(PyExc_TypeError,
             "raise: arg 3 must be a traceback or None");
         goto bad;
     }
     if (value == Py_None)
         value = 0;
+
     if (PyExceptionInstance_Check(type)) {
         if (value) {
             PyErr_SetString(PyExc_TypeError,
                 "instance exception may not have a separate value");
             goto bad;
         }
         value = type;
         type = (PyObject*) Py_TYPE(value);
-    } else if (PyExceptionClass_Check(type)) {
-        PyObject *instance_class = NULL;
-        if (value && PyExceptionInstance_Check(value)) {
-            instance_class = (PyObject*) Py_TYPE(value);
-            if (instance_class != type) {
-                if (PyObject_IsSubclass(instance_class, type)) {
-                    type = instance_class;
-                } else {
-                    instance_class = NULL;
-                }
-            }
-        }
-        if (!instance_class) {
-            PyObject *args;
-            if (!value)
-                args = PyTuple_New(0);
-            else if (PyTuple_Check(value)) {
-                Py_INCREF(value);
-                args = value;
-            } else
-                args = PyTuple_Pack(1, value);
-            if (!args)
-                goto bad;
-            owned_instance = PyObject_Call(type, args, NULL);
-            Py_DECREF(args);
-            if (!owned_instance)
-                goto bad;
-            value = owned_instance;
-            if (!PyExceptionInstance_Check(value)) {
-                PyErr_Format(PyExc_TypeError,
-                             "calling %R should have returned an instance of "
-                             "BaseException, not %R",
-                             type, Py_TYPE(value));
-                goto bad;
-            }
-        }
-    } else {
+    } else if (!PyExceptionClass_Check(type)) {
         PyErr_SetString(PyExc_TypeError,
             "raise: exception class must be a subclass of BaseException");
         goto bad;
     }
-#if PY_VERSION_HEX >= 0x03030000
+
     if (cause) {
-#else
-    if (cause && cause != Py_None) {
-#endif
         PyObject *fixed_cause;
-        if (cause == Py_None) {
-            fixed_cause = NULL;
-        } else if (PyExceptionClass_Check(cause)) {
+        if (PyExceptionClass_Check(cause)) {
             fixed_cause = PyObject_CallObject(cause, NULL);
             if (fixed_cause == NULL)
                 goto bad;
-        } else if (PyExceptionInstance_Check(cause)) {
+        }
+        else if (PyExceptionInstance_Check(cause)) {
             fixed_cause = cause;
             Py_INCREF(fixed_cause);
-        } else {
+        }
+        else {
             PyErr_SetString(PyExc_TypeError,
                             "exception causes must derive from "
                             "BaseException");
             goto bad;
         }
+        if (!value) {
+            value = PyObject_CallObject(type, NULL);
+        }
         PyException_SetCause(value, fixed_cause);
     }
+
     PyErr_SetObject(type, value);
+
     if (tb) {
         PyThreadState *tstate = PyThreadState_GET();
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
     }
+
 bad:
-    Py_XDECREF(owned_instance);
     return;
 }
 #endif
 
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
-    PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
+    long q = a / b;
+    long r = a - q*b;
+    q -= ((r != 0) & ((r ^ b) < 0));
+    return q;
 }
 
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
-    PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AS_STRING(kw_name));
+        #endif
 }
 
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-#if CYTHON_COMPILING_IN_CPYTHON
-    PyThreadState *tstate = PyThreadState_GET();
-    PyObject* exc_type = tstate->curexc_type;
-    if (unlikely(exc_type)) {
-        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
-            PyObject *exc_value, *exc_tb;
-            exc_value = tstate->curexc_value;
-            exc_tb = tstate->curexc_traceback;
-            tstate->curexc_type = 0;
-            tstate->curexc_value = 0;
-            tstate->curexc_traceback = 0;
-            Py_DECREF(exc_type);
-            Py_XDECREF(exc_value);
-            Py_XDECREF(exc_tb);
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#else
-    if (unlikely(PyErr_Occurred())) {
-        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
-            PyErr_Clear();
-            return 0;
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
         } else {
-            return -1;
+            #if PY_MAJOR_VERSION < 3
+            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
+            #else
+            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
+            #endif
+                goto invalid_keyword_type;
+            } else {
+                for (name = first_kw_arg; *name; name++) {
+                    #if PY_MAJOR_VERSION >= 3
+                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                        PyUnicode_Compare(**name, key) == 0) break;
+                    #else
+                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                        _PyString_Eq(**name, key)) break;
+                    #endif
+                }
+                if (*name) {
+                    values[name-argnames] = value;
+                } else {
+                    /* unexpected keyword found */
+                    for (name=argnames; name != first_kw_arg; name++) {
+                        if (**name == key) goto arg_passed_twice;
+                        #if PY_MAJOR_VERSION >= 3
+                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
+                        #else
+                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                            _PyString_Eq(**name, key)) goto arg_passed_twice;
+                        #endif
+                    }
+                    if (kwds2) {
+                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+                    } else {
+                        goto invalid_keyword;
+                    }
+                }
+            }
         }
     }
     return 0;
-#endif
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
 }
 
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
     } else {
-        return __Pyx_IterFinish();
+        num_expected = num_max;
+        more_or_less = "at most";
     }
-    return 0;
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %"PY_FORMAT_SIZE_T"d positional argument%s (%"PY_FORMAT_SIZE_T"d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
 }
 
-static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
-    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact)
+{
+    if (!type) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (none_allowed && obj == Py_None) return 1;
+    else if (exact) {
+        if (Py_TYPE(obj) == type) return 1;
+    }
+    else {
+        if (PyObject_TypeCheck(obj, type)) return 1;
+    }
+    PyErr_Format(PyExc_TypeError,
+        "Argument '%s' has incorrect type (expected %s, got %s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
+    return 0;
 }
 
 static CYTHON_INLINE int __Pyx_IsLittleEndian(void) {
   unsigned int n = 1;
   return *(unsigned char*)(&n) != 0;
 }
+
+typedef struct {
+  __Pyx_StructField root;
+  __Pyx_BufFmt_StackElem* head;
+  size_t fmt_offset;
+  size_t new_count, enc_count;
+  int is_complex;
+  char enc_type;
+  char new_packmode;
+  char enc_packmode;
+} __Pyx_BufFmt_Context;
+
 static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
                               __Pyx_BufFmt_StackElem* stack,
                               __Pyx_TypeInfo* type) {
   stack[0].field = &ctx->root;
   stack[0].parent_offset = 0;
   ctx->root.type = type;
   ctx->root.name = "buffer dtype";
@@ -11560,23 +9202,22 @@
   ctx->head->parent_offset = 0;
   ctx->new_packmode = '@';
   ctx->enc_packmode = '@';
   ctx->new_count = 1;
   ctx->enc_count = 0;
   ctx->enc_type = 0;
   ctx->is_complex = 0;
-  ctx->is_valid_array = 0;
-  ctx->struct_alignment = 0;
   while (type->typegroup == 'S') {
     ++ctx->head;
     ctx->head->field = type->fields;
     ctx->head->parent_offset = 0;
     type = type->fields->type;
   }
 }
+
 static int __Pyx_BufFmt_ParseNumber(const char** ts) {
     int count;
     const char* t = *ts;
     if (*t < '0' || *t > '9') {
       return -1;
     } else {
         count = *t++ - '0';
@@ -11584,29 +9225,23 @@
             count *= 10;
             count += *t++ - '0';
         }
     }
     *ts = t;
     return count;
 }
-static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
-    int number = __Pyx_BufFmt_ParseNumber(ts);
-    if (number == -1) /* First char was not a digit */
-        PyErr_Format(PyExc_ValueError,\
-                     "Does not understand character buffer dtype format string ('%c')", **ts);
-    return number;
-}
+
 static void __Pyx_BufFmt_RaiseUnexpectedChar(char ch) {
   PyErr_Format(PyExc_ValueError,
                "Unexpected format string character: '%c'", ch);
 }
+
 static const char* __Pyx_BufFmt_DescribeTypeChar(char ch, int is_complex) {
   switch (ch) {
-    case 'c': return "'char'";
-    case 'b': return "'signed char'";
+    case 'b': return "'char'";
     case 'B': return "'unsigned char'";
     case 'h': return "'short'";
     case 'H': return "'unsigned short'";
     case 'i': return "'int'";
     case 'I': return "'unsigned int'";
     case 'l': return "'long'";
     case 'L': return "'unsigned long'";
@@ -11614,22 +9249,22 @@
     case 'Q': return "'unsigned long long'";
     case 'f': return (is_complex ? "'complex float'" : "'float'");
     case 'd': return (is_complex ? "'complex double'" : "'double'");
     case 'g': return (is_complex ? "'complex long double'" : "'long double'");
     case 'T': return "a struct";
     case 'O': return "Python object";
     case 'P': return "a pointer";
-    case 's': case 'p': return "a string";
     case 0: return "end";
     default: return "unparseable format string";
   }
 }
+
 static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
   switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case '?': case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return 2;
     case 'i': case 'I': case 'l': case 'L': return 4;
     case 'q': case 'Q': return 8;
     case 'f': return (is_complex ? 8 : 4);
     case 'd': return (is_complex ? 16 : 8);
     case 'g': {
       PyErr_SetString(PyExc_ValueError, "Python does not define a standard format string size for long double ('g')..");
@@ -11637,17 +9272,18 @@
     }
     case 'O': case 'P': return sizeof(void*);
     default:
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
 }
+
 static size_t __Pyx_BufFmt_TypeCharToNativeSize(char ch, int is_complex) {
   switch (ch) {
-    case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return sizeof(short);
     case 'i': case 'I': return sizeof(int);
     case 'l': case 'L': return sizeof(long);
     #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(PY_LONG_LONG);
     #endif
     case 'f': return sizeof(float) * (is_complex ? 2 : 1);
@@ -11656,27 +9292,29 @@
     case 'O': case 'P': return sizeof(void*);
     default: {
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
   }
 }
+
 typedef struct { char c; short x; } __Pyx_st_short;
 typedef struct { char c; int x; } __Pyx_st_int;
 typedef struct { char c; long x; } __Pyx_st_long;
 typedef struct { char c; float x; } __Pyx_st_float;
 typedef struct { char c; double x; } __Pyx_st_double;
 typedef struct { char c; long double x; } __Pyx_st_longdouble;
 typedef struct { char c; void *x; } __Pyx_st_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, CYTHON_UNUSED int is_complex) {
+
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
   switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case '?': case 'c': case 'b': case 'B': return 1;
     case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
 #endif
     case 'f': return sizeof(__Pyx_st_float) - sizeof(float);
@@ -11684,67 +9322,29 @@
     case 'g': return sizeof(__Pyx_st_longdouble) - sizeof(long double);
     case 'P': case 'O': return sizeof(__Pyx_st_void_p) - sizeof(void*);
     default:
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
 }
-/* These are for computing the padding at the end of the struct to align
-   on the first member of the struct. This will probably the same as above,
-   but we don't have any guarantees.
- */
-typedef struct { short x; char c; } __Pyx_pad_short;
-typedef struct { int x; char c; } __Pyx_pad_int;
-typedef struct { long x; char c; } __Pyx_pad_long;
-typedef struct { float x; char c; } __Pyx_pad_float;
-typedef struct { double x; char c; } __Pyx_pad_double;
-typedef struct { long double x; char c; } __Pyx_pad_longdouble;
-typedef struct { void *x; char c; } __Pyx_pad_void_p;
-#ifdef HAVE_LONG_LONG
-typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
-#endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, CYTHON_UNUSED int is_complex) {
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
-    case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
-    case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
-#ifdef HAVE_LONG_LONG
-    case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
-#endif
-    case 'f': return sizeof(__Pyx_pad_float) - sizeof(float);
-    case 'd': return sizeof(__Pyx_pad_double) - sizeof(double);
-    case 'g': return sizeof(__Pyx_pad_longdouble) - sizeof(long double);
-    case 'P': case 'O': return sizeof(__Pyx_pad_void_p) - sizeof(void*);
-    default:
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-}
+
 static char __Pyx_BufFmt_TypeCharToGroup(char ch, int is_complex) {
   switch (ch) {
-    case 'c':
-        return 'H';
-    case 'b': case 'h': case 'i':
-    case 'l': case 'q': case 's': case 'p':
-        return 'I';
-    case 'B': case 'H': case 'I': case 'L': case 'Q':
-        return 'U';
-    case 'f': case 'd': case 'g':
-        return (is_complex ? 'C' : 'R');
-    case 'O':
-        return 'O';
-    case 'P':
-        return 'P';
+    case 'c': case 'b': case 'h': case 'i': case 'l': case 'q': return 'I';
+    case 'B': case 'H': case 'I': case 'L': case 'Q': return 'U';
+    case 'f': case 'd': case 'g': return (is_complex ? 'C' : 'R');
+    case 'O': return 'O';
+    case 'P': return 'P';
     default: {
       __Pyx_BufFmt_RaiseUnexpectedChar(ch);
       return 0;
     }
   }
 }
+
 static void __Pyx_BufFmt_RaiseExpected(__Pyx_BufFmt_Context* ctx) {
   if (ctx->head == NULL || ctx->head->field == &ctx->root) {
     const char* expected;
     const char* quote;
     if (ctx->head == NULL) {
       expected = "end";
       quote = "";
@@ -11761,85 +9361,64 @@
     __Pyx_StructField* parent = (ctx->head - 1)->field;
     PyErr_Format(PyExc_ValueError,
                  "Buffer dtype mismatch, expected '%s' but got %s in '%s.%s'",
                  field->type->name, __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex),
                  parent->type->name, field->name);
   }
 }
+
 static int __Pyx_BufFmt_ProcessTypeChunk(__Pyx_BufFmt_Context* ctx) {
   char group;
-  size_t size, offset, arraysize = 1;
+  size_t size, offset;
   if (ctx->enc_type == 0) return 0;
-  if (ctx->head->field->type->arraysize[0]) {
-    int i, ndim = 0;
-    if (ctx->enc_type == 's' || ctx->enc_type == 'p') {
-        ctx->is_valid_array = ctx->head->field->type->ndim == 1;
-        ndim = 1;
-        if (ctx->enc_count != ctx->head->field->type->arraysize[0]) {
-            PyErr_Format(PyExc_ValueError,
-                         "Expected a dimension of size %zu, got %zu",
-                         ctx->head->field->type->arraysize[0], ctx->enc_count);
-            return -1;
-        }
-    }
-    if (!ctx->is_valid_array) {
-      PyErr_Format(PyExc_ValueError, "Expected %d dimensions, got %d",
-                   ctx->head->field->type->ndim, ndim);
-      return -1;
-    }
-    for (i = 0; i < ctx->head->field->type->ndim; i++) {
-      arraysize *= ctx->head->field->type->arraysize[i];
-    }
-    ctx->is_valid_array = 0;
-    ctx->enc_count = 1;
-  }
   group = __Pyx_BufFmt_TypeCharToGroup(ctx->enc_type, ctx->is_complex);
   do {
     __Pyx_StructField* field = ctx->head->field;
     __Pyx_TypeInfo* type = field->type;
+
     if (ctx->enc_packmode == '@' || ctx->enc_packmode == '^') {
       size = __Pyx_BufFmt_TypeCharToNativeSize(ctx->enc_type, ctx->is_complex);
     } else {
       size = __Pyx_BufFmt_TypeCharToStandardSize(ctx->enc_type, ctx->is_complex);
     }
     if (ctx->enc_packmode == '@') {
       size_t align_at = __Pyx_BufFmt_TypeCharToAlignment(ctx->enc_type, ctx->is_complex);
       size_t align_mod_offset;
       if (align_at == 0) return -1;
       align_mod_offset = ctx->fmt_offset % align_at;
       if (align_mod_offset > 0) ctx->fmt_offset += align_at - align_mod_offset;
-      if (ctx->struct_alignment == 0)
-          ctx->struct_alignment = __Pyx_BufFmt_TypeCharToPadding(ctx->enc_type,
-                                                                 ctx->is_complex);
     }
+
     if (type->size != size || type->typegroup != group) {
       if (type->typegroup == 'C' && type->fields != NULL) {
+        /* special case -- treat as struct rather than complex number */
         size_t parent_offset = ctx->head->parent_offset + field->offset;
         ++ctx->head;
         ctx->head->field = type->fields;
         ctx->head->parent_offset = parent_offset;
         continue;
       }
-      if ((type->typegroup == 'H' || group == 'H') && type->size == size) {
-      } else {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return -1;
-      }
+
+      __Pyx_BufFmt_RaiseExpected(ctx);
+      return -1;
     }
+
     offset = ctx->head->parent_offset + field->offset;
     if (ctx->fmt_offset != offset) {
       PyErr_Format(PyExc_ValueError,
-                   "Buffer dtype mismatch; next field is at offset %" CYTHON_FORMAT_SSIZE_T "d but %" CYTHON_FORMAT_SSIZE_T "d expected",
+                   "Buffer dtype mismatch; next field is at offset %"PY_FORMAT_SIZE_T"d but %"PY_FORMAT_SIZE_T"d expected",
                    (Py_ssize_t)ctx->fmt_offset, (Py_ssize_t)offset);
       return -1;
     }
+
     ctx->fmt_offset += size;
-    if (arraysize)
-      ctx->fmt_offset += (arraysize - 1) * size;
+
     --ctx->enc_count; /* Consume from buffer string */
+
+    /* Done checking, move to next field, pushing or popping struct stack if needed */
     while (1) {
       if (field == &ctx->root) {
         ctx->head = NULL;
         if (ctx->enc_count != 0) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return -1;
         }
@@ -11863,71 +9442,30 @@
       }
     }
   } while (ctx->enc_count);
   ctx->enc_type = 0;
   ctx->is_complex = 0;
   return 0;
 }
-static CYTHON_INLINE PyObject *
-__pyx_buffmt_parse_array(__Pyx_BufFmt_Context* ctx, const char** tsp)
-{
-    const char *ts = *tsp;
-    int i = 0, number;
-    int ndim = ctx->head->field->type->ndim;
-;
-    ++ts;
-    if (ctx->new_count != 1) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Cannot handle repeated arrays in format string");
-        return NULL;
-    }
-    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-    while (*ts && *ts != ')') {
-        if (isspace(*ts))
-            continue;
-        number = __Pyx_BufFmt_ExpectNumber(&ts);
-        if (number == -1) return NULL;
-        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i])
-            return PyErr_Format(PyExc_ValueError,
-                        "Expected a dimension of size %zu, got %d",
-                        ctx->head->field->type->arraysize[i], number);
-        if (*ts != ',' && *ts != ')')
-            return PyErr_Format(PyExc_ValueError,
-                                "Expected a comma in format string, got '%c'", *ts);
-        if (*ts == ',') ts++;
-        i++;
-    }
-    if (i != ndim)
-        return PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
-                            ctx->head->field->type->ndim, i);
-    if (!*ts) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Unexpected end of format string, expected ')'");
-        return NULL;
-    }
-    ctx->is_valid_array = 1;
-    ctx->new_count = 1;
-    *tsp = ++ts;
-    return Py_None;
-}
+
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
   int got_Z = 0;
   while (1) {
     switch(*ts) {
       case 0:
         if (ctx->enc_type != 0 && ctx->head == NULL) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return NULL;
         }
         if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
         if (ctx->head != NULL) {
           __Pyx_BufFmt_RaiseExpected(ctx);
           return NULL;
         }
-                return ts;
+        return ts;
       case ' ':
       case 10:
       case 13:
         ++ts;
         break;
       case '<':
         if (!__Pyx_IsLittleEndian()) {
@@ -11951,45 +9489,31 @@
       case '^':
         ctx->new_packmode = *ts++;
         break;
       case 'T': /* substruct */
         {
           const char* ts_after_sub;
           size_t i, struct_count = ctx->new_count;
-          size_t struct_alignment = ctx->struct_alignment;
           ctx->new_count = 1;
           ++ts;
           if (*ts != '{') {
             PyErr_SetString(PyExc_ValueError, "Buffer acquisition: Expected '{' after 'T'");
             return NULL;
           }
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0; /* Erase processed last struct element */
-          ctx->enc_count = 0;
-          ctx->struct_alignment = 0;
           ++ts;
           ts_after_sub = ts;
           for (i = 0; i != struct_count; ++i) {
             ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);
             if (!ts_after_sub) return NULL;
           }
           ts = ts_after_sub;
-          if (struct_alignment) ctx->struct_alignment = struct_alignment;
         }
         break;
       case '}': /* end of substruct; either repeat or move on */
-        {
-          size_t alignment = ctx->struct_alignment;
-          ++ts;
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0; /* Erase processed last struct element */
-          if (alignment && ctx->fmt_offset % alignment) {
-            ctx->fmt_offset += alignment - (ctx->fmt_offset % alignment);
-          }
-        }
+        ++ts;
         return ts;
       case 'x':
         if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
         ctx->fmt_offset += ctx->new_count;
         ctx->new_count = 1;
         ctx->enc_count = 0;
         ctx->enc_type = 0;
@@ -12002,19 +9526,21 @@
         if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
           __Pyx_BufFmt_RaiseUnexpectedChar('Z');
           return NULL;
         }        /* fall through */
       case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
       case 'l': case 'L': case 'q': case 'Q':
       case 'f': case 'd': case 'g':
-      case 'O': case 's': case 'p':
+      case 'O':
         if (ctx->enc_type == *ts && got_Z == ctx->is_complex &&
             ctx->enc_packmode == ctx->new_packmode) {
+          /* Continue pooling same type */
           ctx->enc_count += ctx->new_count;
         } else {
+          /* New type */
           if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
           ctx->enc_count = ctx->new_count;
           ctx->enc_packmode = ctx->new_packmode;
           ctx->enc_type = *ts;
           ctx->is_complex = got_Z;
         }
         ++ts;
@@ -12022,37 +9548,37 @@
         got_Z = 0;
         break;
       case ':':
         ++ts;
         while(*ts != ':') ++ts;
         ++ts;
         break;
-      case '(':
-        if (!__pyx_buffmt_parse_array(ctx, &ts)) return NULL;
-        break;
       default:
         {
-          int number = __Pyx_BufFmt_ExpectNumber(&ts);
-          if (number == -1) return NULL;
-          ctx->new_count = (size_t)number;
+          int number = __Pyx_BufFmt_ParseNumber(&ts);
+          if (number == -1) { /* First char was not a digit */
+            PyErr_Format(PyExc_ValueError,
+                         "Does not understand character buffer dtype format string ('%c')", *ts);
+            return NULL;
+          }
+          ctx->new_count = (size_t)number; 
         }
     }
   }
 }
+
 static CYTHON_INLINE void __Pyx_ZeroBuffer(Py_buffer* buf) {
   buf->buf = NULL;
   buf->obj = NULL;
   buf->strides = __Pyx_zeros;
   buf->shape = __Pyx_zeros;
   buf->suboffsets = __Pyx_minusones;
 }
-static CYTHON_INLINE int __Pyx_GetBufferAndValidate(
-        Py_buffer* buf, PyObject* obj,  __Pyx_TypeInfo* dtype, int flags,
-        int nd, int cast, __Pyx_BufFmt_StackElem* stack)
-{
+
+static CYTHON_INLINE int __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack) {
   if (obj == Py_None || obj == NULL) {
     __Pyx_ZeroBuffer(buf);
     return 0;
   }
   buf->buf = NULL;
   if (__Pyx_GetBuffer(obj, buf, flags) == -1) goto fail;
   if (buf->ndim != nd) {
@@ -12064,207 +9590,122 @@
   if (!cast) {
     __Pyx_BufFmt_Context ctx;
     __Pyx_BufFmt_Init(&ctx, stack, dtype);
     if (!__Pyx_BufFmt_CheckString(&ctx, buf->format)) goto fail;
   }
   if ((unsigned)buf->itemsize != dtype->size) {
     PyErr_Format(PyExc_ValueError,
-      "Item size of buffer (%" CYTHON_FORMAT_SSIZE_T "d byte%s) does not match size of '%s' (%" CYTHON_FORMAT_SSIZE_T "d byte%s)",
+      "Item size of buffer (%"PY_FORMAT_SIZE_T"d byte%s) does not match size of '%s' (%"PY_FORMAT_SIZE_T"d byte%s)",
       buf->itemsize, (buf->itemsize > 1) ? "s" : "",
       dtype->name, (Py_ssize_t)dtype->size, (dtype->size > 1) ? "s" : "");
     goto fail;
   }
   if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
   return 0;
 fail:;
   __Pyx_ZeroBuffer(buf);
   return -1;
 }
+
 static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info) {
   if (info->buf == NULL) return;
   if (info->suboffsets == __Pyx_minusones) info->suboffsets = NULL;
   __Pyx_ReleaseBuffer(info);
 }
 
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(PyObject_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
+}
+
 static void __Pyx_RaiseBufferFallbackError(void) {
-  PyErr_SetString(PyExc_ValueError,
+  PyErr_Format(PyExc_ValueError,
      "Buffer acquisition failed on assignment; and then reacquiring the old buffer failed too!");
 }
 
+
+static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
+    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
+}
+
 static void __Pyx_RaiseBufferIndexError(int axis) {
   PyErr_Format(PyExc_IndexError,
      "Out of bounds on buffer access (axis %d)", axis);
 }
 
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
-    if (likely(PyList_CheckExact(L))) {
-        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
-    } else {
-        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
-        if (unlikely(!retval))
-            return -1;
-        Py_DECREF(retval);
-    }
-    return 0;
-}
 
-static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
-    long q = a / b;
-    long r = a - q*b;
-    q -= ((r != 0) & ((r ^ b) < 0));
-    return q;
-}
-
-static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
-                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
-                                  int full_traceback) {
-    PyObject *old_exc, *old_val, *old_tb;
-    PyObject *ctx;
-    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
-    if (full_traceback) {
-        Py_XINCREF(old_exc);
-        Py_XINCREF(old_val);
-        Py_XINCREF(old_tb);
-        __Pyx_ErrRestore(old_exc, old_val, old_tb);
-        PyErr_PrintEx(1);
-    }
-    #if PY_MAJOR_VERSION < 3
-    ctx = PyString_FromString(name);
-    #else
-    ctx = PyUnicode_FromString(name);
-    #endif
-    __Pyx_ErrRestore(old_exc, old_val, old_tb);
-    if (!ctx) {
-        PyErr_WriteUnraisable(Py_None);
-    } else {
-        PyErr_WriteUnraisable(ctx);
-        Py_DECREF(ctx);
-    }
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+                 "need more than %"PY_FORMAT_SIZE_T"d value%s to unpack",
+                 index, (index == 1) ? "" : "s");
 }
 
-static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
-    PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
-        name, type->tp_name, Py_TYPE(obj)->tp_name);
-}
-static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
-    const char *name, int exact)
-{
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
-    }
-    if (none_allowed && obj == Py_None) return 1;
-    else if (exact) {
-        if (likely(Py_TYPE(obj) == type)) return 1;
-        #if PY_MAJOR_VERSION == 2
-        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
-        #endif
-    }
-    else {
-        if (likely(PyObject_TypeCheck(obj, type))) return 1;
-    }
-    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
-    return 0;
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+    PyErr_Format(PyExc_ValueError,
+                 "too many values to unpack (expected %"PY_FORMAT_SIZE_T"d)", expected);
 }
 
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
-    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
-    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        PyErr_Format(PyExc_ImportError,
-        #if PY_MAJOR_VERSION < 3
-            "cannot import name %.230s", PyString_AS_STRING(name));
-        #else
-            "cannot import name %S", name);
-        #endif
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError(index);
     }
-    return value;
 }
 
 #if PY_MAJOR_VERSION < 3
 static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
   #if PY_VERSION_HEX >= 0x02060000
-    if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
+  if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
   #endif
-        if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) return __pyx_pw_5numpy_7ndarray_1__getbuffer__(obj, view, flags);
-  #if PY_VERSION_HEX < 0x02060000
-    if (obj->ob_type->tp_dict) {
-        PyObject *getbuffer_cobj = PyObject_GetItem(
-            obj->ob_type->tp_dict, __pyx_n_s_pyx_getbuffer);
-        if (getbuffer_cobj) {
-            getbufferproc func = (getbufferproc) PyCObject_AsVoidPtr(getbuffer_cobj);
-            Py_DECREF(getbuffer_cobj);
-            if (!func)
-                goto fail;
-            return func(obj, view, flags);
-        } else {
-            PyErr_Clear();
-        }
+  if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) return __pyx_pf_5numpy_7ndarray___getbuffer__(obj, view, flags);
+  else {
+  PyErr_Format(PyExc_TypeError, "'%100s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
+  return -1;
     }
-  #endif
-    PyErr_Format(PyExc_TypeError, "'%.200s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
-#if PY_VERSION_HEX < 0x02060000
-fail:
-#endif
-    return -1;
 }
+
 static void __Pyx_ReleaseBuffer(Py_buffer *view) {
-    PyObject *obj = view->obj;
-    if (!obj) return;
-  #if PY_VERSION_HEX >= 0x02060000
-    if (PyObject_CheckBuffer(obj)) {
-        PyBuffer_Release(view);
-        return;
-    }
-  #endif
-        if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) { __pyx_pw_5numpy_7ndarray_3__releasebuffer__(obj, view); return; }
-  #if PY_VERSION_HEX < 0x02060000
-    if (obj->ob_type->tp_dict) {
-        PyObject *releasebuffer_cobj = PyObject_GetItem(
-            obj->ob_type->tp_dict, __pyx_n_s_pyx_releasebuffer);
-        if (releasebuffer_cobj) {
-            releasebufferproc func = (releasebufferproc) PyCObject_AsVoidPtr(releasebuffer_cobj);
-            Py_DECREF(releasebuffer_cobj);
-            if (!func)
-                goto fail;
-            func(obj, view);
-            return;
-        } else {
-            PyErr_Clear();
-        }
-    }
-  #endif
-    goto nofail;
-#if PY_VERSION_HEX < 0x02060000
-fail:
-#endif
-    PyErr_WriteUnraisable(obj);
-nofail:
+  PyObject* obj = view->obj;
+  if (obj) {
+    #if PY_VERSION_HEX >= 0x02060000
+    if (PyObject_CheckBuffer(obj)) {PyBuffer_Release(view); return;}
+    #endif
+    if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) __pyx_pf_5numpy_7ndarray_1__releasebuffer__(obj, view);
     Py_DECREF(obj);
     view->obj = NULL;
+  }
 }
-#endif /*  PY_MAJOR_VERSION < 3 */
 
+#endif
 
-        static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, long level) {
+    PyObject *py_import = 0;
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
     PyObject *list;
-    #if PY_VERSION_HEX < 0x03030000
-    PyObject *py_import;
-    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
+    py_import = __Pyx_GetAttrString(__pyx_b, "__import__");
     if (!py_import)
         goto bad;
-    #endif
     if (from_list)
         list = from_list;
     else {
         empty_list = PyList_New(0);
         if (!empty_list)
             goto bad;
         list = empty_list;
@@ -12273,235 +9714,177 @@
     if (!global_dict)
         goto bad;
     empty_dict = PyDict_New();
     if (!empty_dict)
         goto bad;
     #if PY_VERSION_HEX >= 0x02050000
     {
-        #if PY_MAJOR_VERSION >= 3
-        if (level == -1) {
-            if (strchr(__Pyx_MODULE_NAME, '.')) {
-                #if PY_VERSION_HEX < 0x03030000
-                PyObject *py_level = PyInt_FromLong(1);
-                if (!py_level)
-                    goto bad;
-                module = PyObject_CallFunctionObjArgs(py_import,
-                    name, global_dict, empty_dict, list, py_level, NULL);
-                Py_DECREF(py_level);
-                #else
-                module = PyImport_ImportModuleLevelObject(
-                    name, global_dict, empty_dict, list, 1);
-                #endif
-                if (!module) {
-                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
-                        goto bad;
-                    PyErr_Clear();
-                }
-            }
-            level = 0; /* try absolute import on failure */
-        }
-        #endif
-        if (!module) {
-            #if PY_VERSION_HEX < 0x03030000
-            PyObject *py_level = PyInt_FromLong(level);
-            if (!py_level)
-                goto bad;
-            module = PyObject_CallFunctionObjArgs(py_import,
-                name, global_dict, empty_dict, list, py_level, NULL);
-            Py_DECREF(py_level);
-            #else
-            module = PyImport_ImportModuleLevelObject(
-                name, global_dict, empty_dict, list, level);
-            #endif
-        }
+        PyObject *py_level = PyInt_FromLong(level);
+        if (!py_level)
+            goto bad;
+        module = PyObject_CallFunctionObjArgs(py_import,
+            name, global_dict, empty_dict, list, py_level, NULL);
+        Py_DECREF(py_level);
     }
     #else
     if (level>0) {
         PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
         goto bad;
     }
     module = PyObject_CallFunctionObjArgs(py_import,
         name, global_dict, empty_dict, list, NULL);
     #endif
 bad:
-    #if PY_VERSION_HEX < 0x03030000
-    Py_XDECREF(py_import);
-    #endif
     Py_XDECREF(empty_list);
+    Py_XDECREF(py_import);
     Py_XDECREF(empty_dict);
     return module;
 }
 
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-    const long neg_one = (long) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long long)) {
-            return PyLong_FromUnsignedLongLong((unsigned long long) value);
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(long long)) {
-            return PyLong_FromLongLong((long long) value);
-        }
+static CYTHON_INLINE long __Pyx_pow_long(long b, long e) {
+    long t = b;
+    switch (e) {
+        case 3:
+            t *= b;
+        case 2:
+            t *= b;
+        case 1:
+            return t;
+        case 0:
+            return 1;
     }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
+    if (unlikely(e<0)) return 0;
+    t = 1;
+    while (likely(e)) {
+        t *= (b * (e&1)) | ((~e)&1);    /* 1 or b */
+        b *= b;
+        e >>= 1;
     }
+    return t;
 }
 
-#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func)             \
-    {                                                                     \
-        func_type value = func(x);                                        \
-        if (sizeof(target_type) < sizeof(func_type)) {                    \
-            if (unlikely(value != (func_type) (target_type) value)) {     \
-                func_type zero = 0;                                       \
-                PyErr_SetString(PyExc_OverflowError,                      \
-                    (is_unsigned && unlikely(value < zero)) ?             \
-                    "can't convert negative value to " #target_type :     \
-                    "value too large to convert to " #target_type);       \
-                return (target_type) -1;                                  \
-            }                                                             \
-        }                                                                 \
-        return (target_type) value;                                       \
-    }
-
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
+#if CYTHON_CCOMPLEX
+  #ifdef __cplusplus
+    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
+      return ::std::complex< float >(x, y);
+    }
+  #else
+    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
+      return x + y*(__pyx_t_float_complex)_Complex_I;
+    }
+  #endif
+#else
+    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
+      __pyx_t_float_complex z;
+      z.real = x;
+      z.imag = y;
+      return z;
+    }
 #endif
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
-    const int neg_one = (int) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(int) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int");
-                return (int) -1;
-            }
-            return (int) val;
+
+#if CYTHON_CCOMPLEX
+#else
+    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+       return (a.real == b.real) && (a.imag == b.imag);
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real + b.real;
+        z.imag = a.imag + b.imag;
+        return z;
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real - b.real;
+        z.imag = a.imag - b.imag;
+        return z;
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real * b.real - a.imag * b.imag;
+        z.imag = a.real * b.imag + a.imag * b.real;
+        return z;
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        float denom = b.real * b.real + b.imag * b.imag;
+        z.real = (a.real * b.real + a.imag * b.imag) / denom;
+        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
+        return z;
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex a) {
+        __pyx_t_float_complex z;
+        z.real = -a.real;
+        z.imag = -a.imag;
+        return z;
+    }
+    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex a) {
+       return (a.real == 0) && (a.imag == 0);
+    }
+    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex a) {
+        __pyx_t_float_complex z;
+        z.real =  a.real;
+        z.imag = -a.imag;
+        return z;
+    }
+    #if 1
+        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex z) {
+          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
+            return sqrtf(z.real*z.real + z.imag*z.imag);
+          #else
+            return hypotf(z.real, z.imag);
+          #endif
         }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (int) ((PyLongObject*)x)->ob_digit[0];
+        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+            __pyx_t_float_complex z;
+            float r, lnr, theta, z_r, z_theta;
+            if (b.imag == 0 && b.real == (int)b.real) {
+                if (b.real < 0) {
+                    float denom = a.real * a.real + a.imag * a.imag;
+                    a.real = a.real / denom;
+                    a.imag = -a.imag / denom;
+                    b.real = -b.real;
                 }
-            }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to int");
-                return (int) -1;
-            }
-            if (sizeof(int) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(int) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong)
-            }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(int)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(int) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(int) ((PyLongObject*)x)->ob_digit[0];
+                switch ((int)b.real) {
+                    case 0:
+                        z.real = 1;
+                        z.imag = 0;
+                        return z;
+                    case 1:
+                        return a;
+                    case 2:
+                        z = __Pyx_c_prodf(a, a);
+                        return __Pyx_c_prodf(a, a);
+                    case 3:
+                        z = __Pyx_c_prodf(a, a);
+                        return __Pyx_c_prodf(z, a);
+                    case 4:
+                        z = __Pyx_c_prodf(a, a);
+                        return __Pyx_c_prodf(z, z);
                 }
             }
- #endif
-#endif
-            if (sizeof(int) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong)
-            } else if (sizeof(int) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong)
+            if (a.imag == 0) {
+                if (a.real == 0) {
+                    return a;
+                }
+                r = a.real;
+                theta = 0;
+            } else {
+                r = __Pyx_c_absf(a);
+                theta = atan2f(a.imag, a.real);
             }
+            lnr = logf(r);
+            z_r = expf(lnr * b.real - theta * b.imag);
+            z_theta = theta * b.real + lnr * b.imag;
+            z.real = z_r * cosf(z_theta);
+            z.imag = z_r * sinf(z_theta);
+            return z;
         }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            int val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
+    #endif
 #endif
-            return (int) -1;
-        }
-    } else {
-        int val;
-        PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (int) -1;
-        val = __Pyx_PyInt_As_int(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-}
-
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-    const int neg_one = (int) -1, const_zero = 0;
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long long)) {
-            return PyLong_FromUnsignedLongLong((unsigned long long) value);
-        }
-    } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(long long)) {
-            return PyLong_FromLongLong((long long) value);
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
-                                     little, !is_unsigned);
-    }
-}
 
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
       return ::std::complex< double >(x, y);
     }
   #else
@@ -12615,357 +9998,432 @@
             z.real = z_r * cos(z_theta);
             z.imag = z_r * sin(z_theta);
             return z;
         }
     #endif
 #endif
 
-static CYTHON_INLINE long __Pyx_pow_long(long b, long e) {
-    long t = b;
-    switch (e) {
-        case 3:
-            t *= b;
-        case 2:
-            t *= b;
-        case 1:
-            return t;
-        case 0:
-            return 1;
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
     }
-    #if 1
-    if (unlikely(e<0)) return 0;
-    #endif
-    t = 1;
-    while (likely(e)) {
-        t *= (b * (e&1)) | ((~e)&1);    /* 1 or b */
-        b *= b;
-        e >>= 1;
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
     }
-    return t;
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
 }
 
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
-    const long neg_one = (long) -1, const_zero = 0;
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
     const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(long) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
                 PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to long");
-                return (long) -1;
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
             }
-            return (long) val;
+            return (unsigned int)-1;
         }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(long)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
-                }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
             }
- #endif
-#endif
-            if (unlikely(Py_SIZE(x) < 0)) {
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
                 PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to long");
-                return (long) -1;
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
             }
-            if (sizeof(long) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(long) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong)
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
             }
-        } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(long)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
-                }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
             }
- #endif
-#endif
-            if (sizeof(long) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong)
-            } else if (sizeof(long) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong)
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
             }
+            return (signed short)-1;
         }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            long val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
             }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
             }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
 #endif
-            return (long) -1;
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+            return (unsigned long)PyLong_AsLong(x);
         }
     } else {
-        long val;
+        unsigned long val;
         PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (long) -1;
-        val = __Pyx_PyInt_As_long(tmp);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
         Py_DECREF(tmp);
         return val;
     }
 }
 
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
-    const size_t neg_one = (size_t) -1, const_zero = 0;
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
     const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
     if (likely(PyInt_Check(x))) {
-        if (sizeof(size_t) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG)
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to size_t");
-                return (size_t) -1;
-            }
-            return (size_t) val;
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
         }
+        return (unsigned PY_LONG_LONG)val;
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(size_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return (size_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
-#endif
             if (unlikely(Py_SIZE(x) < 0)) {
                 PyErr_SetString(PyExc_OverflowError,
-                                "can't convert negative value to size_t");
-                return (size_t) -1;
-            }
-            if (sizeof(size_t) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, unsigned long, PyLong_AsUnsignedLong)
-            } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, unsigned long long, PyLong_AsUnsignedLongLong)
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
             }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
         } else {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-            if (sizeof(digit) <= sizeof(size_t)) {
-                switch (Py_SIZE(x)) {
-                    case  0: return 0;
-                    case  1: return +(size_t) ((PyLongObject*)x)->ob_digit[0];
-                    case -1: return -(size_t) ((PyLongObject*)x)->ob_digit[0];
-                }
-            }
- #endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
 #endif
-            if (sizeof(size_t) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, long, PyLong_AsLong)
-            } else if (sizeof(size_t) <= sizeof(long long)) {
-                __PYX_VERIFY_RETURN_INT(size_t, long long, PyLong_AsLongLong)
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
             }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+            return (long)PyLong_AsLong(x);
         }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            size_t val;
-            PyObject *v = __Pyx_PyNumber_Int(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
 #endif
-            return (size_t) -1;
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
         }
     } else {
-        size_t val;
+        PY_LONG_LONG val;
         PyObject *tmp = __Pyx_PyNumber_Int(x);
-        if (!tmp) return (size_t) -1;
-        val = __Pyx_PyInt_As_size_t(tmp);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
         Py_DECREF(tmp);
         return val;
     }
 }
 
-#if CYTHON_CCOMPLEX
-  #ifdef __cplusplus
-    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
-      return ::std::complex< float >(x, y);
-    }
-  #else
-    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
-      return x + y*(__pyx_t_float_complex)_Complex_I;
-    }
-  #endif
-#else
-    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
-      __pyx_t_float_complex z;
-      z.real = x;
-      z.imag = y;
-      return z;
-    }
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
 #endif
-
-#if CYTHON_CCOMPLEX
-#else
-    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-       return (a.real == b.real) && (a.imag == b.imag);
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-        __pyx_t_float_complex z;
-        z.real = a.real + b.real;
-        z.imag = a.imag + b.imag;
-        return z;
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-        __pyx_t_float_complex z;
-        z.real = a.real - b.real;
-        z.imag = a.imag - b.imag;
-        return z;
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-        __pyx_t_float_complex z;
-        z.real = a.real * b.real - a.imag * b.imag;
-        z.imag = a.real * b.imag + a.imag * b.real;
-        return z;
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-        __pyx_t_float_complex z;
-        float denom = b.real * b.real + b.imag * b.imag;
-        z.real = (a.real * b.real + a.imag * b.imag) / denom;
-        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
-        return z;
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex a) {
-        __pyx_t_float_complex z;
-        z.real = -a.real;
-        z.imag = -a.imag;
-        return z;
-    }
-    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex a) {
-       return (a.real == 0) && (a.imag == 0);
-    }
-    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex a) {
-        __pyx_t_float_complex z;
-        z.real =  a.real;
-        z.imag = -a.imag;
-        return z;
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
     }
-    #if 1
-        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex z) {
-          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
-            return sqrtf(z.real*z.real + z.imag*z.imag);
-          #else
-            return hypotf(z.real, z.imag);
-          #endif
+}
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
         }
-        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
-            __pyx_t_float_complex z;
-            float r, lnr, theta, z_r, z_theta;
-            if (b.imag == 0 && b.real == (int)b.real) {
-                if (b.real < 0) {
-                    float denom = a.real * a.real + a.imag * a.imag;
-                    a.real = a.real / denom;
-                    a.imag = -a.imag / denom;
-                    b.real = -b.real;
-                }
-                switch ((int)b.real) {
-                    case 0:
-                        z.real = 1;
-                        z.imag = 0;
-                        return z;
-                    case 1:
-                        return a;
-                    case 2:
-                        z = __Pyx_c_prodf(a, a);
-                        return __Pyx_c_prodf(a, a);
-                    case 3:
-                        z = __Pyx_c_prodf(a, a);
-                        return __Pyx_c_prodf(z, a);
-                    case 4:
-                        z = __Pyx_c_prodf(a, a);
-                        return __Pyx_c_prodf(z, z);
-                }
-            }
-            if (a.imag == 0) {
-                if (a.real == 0) {
-                    return a;
-                }
-                r = a.real;
-                theta = 0;
-            } else {
-                r = __Pyx_c_absf(a);
-                theta = atan2f(a.imag, a.real);
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
             }
-            lnr = logf(r);
-            z_r = expf(lnr * b.real - theta * b.imag);
-            z_theta = theta * b.real + lnr * b.imag;
-            z.real = z_r * cosf(z_theta);
-            z.imag = z_r * sinf(z_theta);
-            return z;
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
         }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    #if PY_MAJOR_VERSION < 3
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
     #endif
-#endif
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
+    }
+}
 
 static int __Pyx_check_binary_version(void) {
     char ctversion[4], rtversion[4];
     PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
     PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
     if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
@@ -12978,257 +10436,160 @@
         #else
         return PyErr_WarnEx(NULL, message, 1);
         #endif
     }
     return 0;
 }
 
-#ifndef __PYX_HAVE_RT_ImportModule
-#define __PYX_HAVE_RT_ImportModule
-static PyObject *__Pyx_ImportModule(const char *name) {
-    PyObject *py_name = 0;
-    PyObject *py_module = 0;
-    py_name = __Pyx_PyIdentifier_FromString(name);
-    if (!py_name)
-        goto bad;
-    py_module = PyImport_Import(py_name);
-    Py_DECREF(py_name);
-    return py_module;
-bad:
-    Py_XDECREF(py_name);
-    return 0;
-}
-#endif
-
 #ifndef __PYX_HAVE_RT_ImportType
 #define __PYX_HAVE_RT_ImportType
 static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
     size_t size, int strict)
 {
     PyObject *py_module = 0;
     PyObject *result = 0;
     PyObject *py_name = 0;
     char warning[200];
-    Py_ssize_t basicsize;
-#ifdef Py_LIMITED_API
-    PyObject *py_basicsize;
-#endif
+
     py_module = __Pyx_ImportModule(module_name);
     if (!py_module)
         goto bad;
-    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(class_name);
+    #else
+    py_name = PyUnicode_FromString(class_name);
+    #endif
     if (!py_name)
         goto bad;
     result = PyObject_GetAttr(py_module, py_name);
     Py_DECREF(py_name);
     py_name = 0;
     Py_DECREF(py_module);
     py_module = 0;
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
-            "%.200s.%.200s is not a type object",
+            "%s.%s is not a type object",
             module_name, class_name);
         goto bad;
     }
-#ifndef Py_LIMITED_API
-    basicsize = ((PyTypeObject *)result)->tp_basicsize;
-#else
-    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
-    if (!py_basicsize)
-        goto bad;
-    basicsize = PyLong_AsSsize_t(py_basicsize);
-    Py_DECREF(py_basicsize);
-    py_basicsize = 0;
-    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
-        goto bad;
-#endif
-    if (!strict && (size_t)basicsize > size) {
+    if (!strict && ((PyTypeObject *)result)->tp_basicsize > (Py_ssize_t)size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility",
             module_name, class_name);
         #if PY_VERSION_HEX < 0x02050000
         if (PyErr_Warn(NULL, warning) < 0) goto bad;
         #else
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
         #endif
     }
-    else if ((size_t)basicsize != size) {
+    else if (((PyTypeObject *)result)->tp_basicsize != (Py_ssize_t)size) {
         PyErr_Format(PyExc_ValueError,
-            "%.200s.%.200s has the wrong size, try recompiling",
+            "%s.%s has the wrong size, try recompiling",
             module_name, class_name);
         goto bad;
     }
     return (PyTypeObject *)result;
 bad:
     Py_XDECREF(py_module);
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
-    int start = 0, mid = 0, end = count - 1;
-    if (end >= 0 && code_line > entries[end].code_line) {
-        return count;
-    }
-    while (start < end) {
-        mid = (start + end) / 2;
-        if (code_line < entries[mid].code_line) {
-            end = mid;
-        } else if (code_line > entries[mid].code_line) {
-             start = mid + 1;
-        } else {
-            return mid;
-        }
-    }
-    if (code_line <= entries[mid].code_line) {
-        return mid;
-    } else {
-        return mid + 1;
-    }
-}
-static PyCodeObject *__pyx_find_code_object(int code_line) {
-    PyCodeObject* code_object;
-    int pos;
-    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
-        return NULL;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
-        return NULL;
-    }
-    code_object = __pyx_code_cache.entries[pos].code_object;
-    Py_INCREF(code_object);
-    return code_object;
-}
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
-    int pos, i;
-    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
-    if (unlikely(!code_line)) {
-        return;
-    }
-    if (unlikely(!entries)) {
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
-        if (likely(entries)) {
-            __pyx_code_cache.entries = entries;
-            __pyx_code_cache.max_count = 64;
-            __pyx_code_cache.count = 1;
-            entries[0].code_line = code_line;
-            entries[0].code_object = code_object;
-            Py_INCREF(code_object);
-        }
-        return;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
-        PyCodeObject* tmp = entries[pos].code_object;
-        entries[pos].code_object = code_object;
-        Py_DECREF(tmp);
-        return;
-    }
-    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
-        int new_max = __pyx_code_cache.max_count + 64;
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
-            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
-        if (unlikely(!entries)) {
-            return;
-        }
-        __pyx_code_cache.entries = entries;
-        __pyx_code_cache.max_count = new_max;
-    }
-    for (i=__pyx_code_cache.count; i>pos; i--) {
-        entries[i] = entries[i-1];
-    }
-    entries[pos].code_line = code_line;
-    entries[pos].code_object = code_object;
-    __pyx_code_cache.count++;
-    Py_INCREF(code_object);
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(name);
+    #else
+    py_name = PyUnicode_FromString(name);
+    #endif
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
 }
+#endif
 
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
-            const char *funcname, int c_line,
-            int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
+
+static void __Pyx_AddTraceback(const char *funcname, int __pyx_clineno,
+                               int __pyx_lineno, const char *__pyx_filename) {
     PyObject *py_srcfile = 0;
     PyObject *py_funcname = 0;
+    PyObject *py_globals = 0;
+    PyCodeObject *py_code = 0;
+    PyFrameObject *py_frame = 0;
+
     #if PY_MAJOR_VERSION < 3
-    py_srcfile = PyString_FromString(filename);
+    py_srcfile = PyString_FromString(__pyx_filename);
     #else
-    py_srcfile = PyUnicode_FromString(filename);
+    py_srcfile = PyUnicode_FromString(__pyx_filename);
     #endif
     if (!py_srcfile) goto bad;
-    if (c_line) {
+    if (__pyx_clineno) {
         #if PY_MAJOR_VERSION < 3
-        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
         #else
-        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
         #else
         py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
     if (!py_funcname) goto bad;
-    py_code = __Pyx_PyCode_New(
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_code = PyCode_New(
         0,            /*int argcount,*/
+        #if PY_MAJOR_VERSION >= 3
         0,            /*int kwonlyargcount,*/
+        #endif
         0,            /*int nlocals,*/
         0,            /*int stacksize,*/
         0,            /*int flags,*/
         __pyx_empty_bytes, /*PyObject *code,*/
-        __pyx_empty_tuple, /*PyObject *consts,*/
-        __pyx_empty_tuple, /*PyObject *names,*/
-        __pyx_empty_tuple, /*PyObject *varnames,*/
-        __pyx_empty_tuple, /*PyObject *freevars,*/
-        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        __pyx_empty_tuple,  /*PyObject *consts,*/
+        __pyx_empty_tuple,  /*PyObject *names,*/
+        __pyx_empty_tuple,  /*PyObject *varnames,*/
+        __pyx_empty_tuple,  /*PyObject *freevars,*/
+        __pyx_empty_tuple,  /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
-        py_line,      /*int firstlineno,*/
+        __pyx_lineno,   /*int firstlineno,*/
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
-    Py_DECREF(py_srcfile);
-    Py_DECREF(py_funcname);
-    return py_code;
-bad:
-    Py_XDECREF(py_srcfile);
-    Py_XDECREF(py_funcname);
-    return NULL;
-}
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
-    PyObject *py_globals = 0;
-    PyFrameObject *py_frame = 0;
-    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
-    if (!py_code) {
-        py_code = __Pyx_CreateCodeObjectForTraceback(
-            funcname, c_line, py_line, filename);
-        if (!py_code) goto bad;
-        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
-    }
-    py_globals = PyModule_GetDict(__pyx_m);
-    if (!py_globals) goto bad;
+    if (!py_code) goto bad;
     py_frame = PyFrame_New(
         PyThreadState_GET(), /*PyThreadState *tstate,*/
         py_code,             /*PyCodeObject *code,*/
         py_globals,          /*PyObject *globals,*/
         0                    /*PyObject *locals*/
     );
     if (!py_frame) goto bad;
-    py_frame->f_lineno = py_line;
+    py_frame->f_lineno = __pyx_lineno;
     PyTraceBack_Here(py_frame);
 bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
 
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
         #if PY_MAJOR_VERSION < 3
@@ -13255,96 +10616,34 @@
         if (!*t->p)
             return -1;
         ++t;
     }
     return 0;
 }
 
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
-    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
-}
-static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
-    Py_ssize_t ignore;
-    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
-}
-static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-    if (
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-            __Pyx_sys_getdefaultencoding_not_ascii &&
-#endif
-            PyUnicode_Check(o)) {
-#if PY_VERSION_HEX < 0x03030000
-        char* defenc_c;
-        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
-        if (!defenc) return NULL;
-        defenc_c = PyBytes_AS_STRING(defenc);
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-        {
-            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
-            char* c;
-            for (c = defenc_c; c < end; c++) {
-                if ((unsigned char) (*c) >= 128) {
-                    PyUnicode_AsASCIIString(o);
-                    return NULL;
-                }
-            }
-        }
-#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
-        *length = PyBytes_GET_SIZE(defenc);
-        return defenc_c;
-#else /* PY_VERSION_HEX < 0x03030000 */
-        if (PyUnicode_READY(o) == -1) return NULL;
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-        if (PyUnicode_IS_ASCII(o)) {
-            *length = PyUnicode_GET_DATA_SIZE(o);
-            return PyUnicode_AsUTF8(o);
-        } else {
-            PyUnicode_AsASCIIString(o);
-            return NULL;
-        }
-#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
-        return PyUnicode_AsUTF8AndSize(o, length);
-#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
-#endif /* PY_VERSION_HEX < 0x03030000 */
-    } else
-#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
-#if PY_VERSION_HEX >= 0x02060000
-    if (PyByteArray_Check(o)) {
-        *length = PyByteArray_GET_SIZE(o);
-        return PyByteArray_AS_STRING(o);
-    } else
-#endif
-    {
-        char* result;
-        int r = PyBytes_AsStringAndSize(o, &result, length);
-        if (unlikely(r < 0)) {
-            return NULL;
-        } else {
-            return result;
-        }
-    }
-}
+/* Type Conversion Functions */
+
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
    int is_true = x == Py_True;
    if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
    else return PyObject_IsTrue(x);
 }
+
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
   PyNumberMethods *m;
   const char *name = NULL;
   PyObject *res = NULL;
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
   if (PyInt_Check(x) || PyLong_Check(x))
 #else
   if (PyLong_Check(x))
 #endif
     return Py_INCREF(x), x;
   m = Py_TYPE(x)->tp_as_number;
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
   if (m && m->nb_int) {
     name = "int";
     res = PyNumber_Int(x);
   }
   else if (m && m->nb_long) {
     name = "long";
     res = PyNumber_Long(x);
@@ -13352,75 +10651,63 @@
 #else
   if (m && m->nb_int) {
     name = "int";
     res = PyNumber_Long(x);
   }
 #endif
   if (res) {
-#if PY_MAJOR_VERSION < 3
+#if PY_VERSION_HEX < 0x03000000
     if (!PyInt_Check(res) && !PyLong_Check(res)) {
 #else
     if (!PyLong_Check(res)) {
 #endif
       PyErr_Format(PyExc_TypeError,
-                   "__%.4s__ returned non-%.4s (type %.200s)",
+                   "__%s__ returned non-%s (type %.200s)",
                    name, name, Py_TYPE(res)->tp_name);
       Py_DECREF(res);
       return NULL;
     }
   }
   else if (!PyErr_Occurred()) {
     PyErr_SetString(PyExc_TypeError,
                     "an integer is required");
   }
   return res;
 }
-#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
- #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
- #endif
-#endif
+
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
   Py_ssize_t ival;
-  PyObject *x;
-#if PY_MAJOR_VERSION < 3
-  if (likely(PyInt_CheckExact(b)))
-      return PyInt_AS_LONG(b);
-#endif
-  if (likely(PyLong_CheckExact(b))) {
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
-     #if CYTHON_USE_PYLONG_INTERNALS
-       switch (Py_SIZE(b)) {
-       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
-       case  0: return 0;
-       case  1: return ((PyLongObject*)b)->ob_digit[0];
-       }
-     #endif
-    #endif
-  #if PY_VERSION_HEX < 0x02060000
-    return PyInt_AsSsize_t(b);
-  #else
-    return PyLong_AsSsize_t(b);
-  #endif
-  }
-  x = PyNumber_Index(b);
+  PyObject* x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
+
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
 #if PY_VERSION_HEX < 0x02050000
    if (ival <= LONG_MAX)
        return PyInt_FromLong((long)ival);
    else {
        unsigned char *bytes = (unsigned char *) &ival;
        int one = 1; int little = (int)*(unsigned char*)&one;
        return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
    }
 #else
    return PyInt_FromSize_t(ival);
 #endif
 }
 
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
+       return (size_t)-1;
+   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       PyErr_SetString(PyExc_OverflowError,
+                       "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
 
 #endif /* Py_PYTHON_H */
```

### Comparing `healpy-1.9.1/healpy/rotator.py` & `healpy-github-devel/healpy/rotator.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 #  You should have received a copy of the GNU General Public License
 #  along with Healpy; if not, write to the Free Software
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 # 
 #  For more information about Healpy, see http://code.google.com/p/healpy
 # 
 import numpy as np
-import six
 import warnings
 
 coordname = {'G': 'Galactic', 'E': 'Ecliptic', 'C': 'Equatorial'}
 
 class ConsistencyWarning(Warning):
     """Warns for a problem in the consistency of data
     """
@@ -63,26 +62,22 @@
     coords
       
     Examples
     --------
     >>> r = Rotator(coord=['G','E'])  # Transforms galactic to ecliptic coordinates
     >>> theta_gal, phi_gal = np.pi/2., 0.
     >>> theta_ecl, phi_ecl = r(theta_gal, phi_gal)  # Apply the conversion
-    >>> print(theta_ecl)
-    1.66742286715
-    >>> print(phi_ecl)
-    -1.62596400306
+    >>> print theta_ecl, phi_ecl
+    1.66742286715 -1.62596400306
     >>> theta_ecl, phi_ecl = Rotator(coord='ge')(theta_gal, phi_gal) # In one line
-    >>> print(theta_ecl)
-    1.66742286715
-    >>> print(phi_ecl)
-    -1.62596400306
+    >>> print theta_ecl, phi_ecl
+    1.66742286715 -1.62596400306
     >>> vec_gal = np.array([1, 0, 0]) #Using vectors
     >>> vec_ecl = r(vec_gal)
-    >>> print(vec_ecl)
+    >>> print vec_ecl
     [-0.05488249 -0.99382103 -0.09647625]
     """
     ErrMessWrongPar = ("rot and coord must be single elements or "
                        "sequence of same size.")
 
     def __init__(self,rot=None,coord=None,inv=None,deg=True,
                  eulertype='ZYX'):
@@ -150,16 +145,15 @@
             convmat,do_conv,coordnorm = get_coordconv_matrix(c)
             r = np.dot(rotmat,convmat)
             if i: r = r.T
             self._matrix = np.dot(self._matrix, r)
             self._do_rotation = self._do_rotation or (do_rot or do_conv)
 
     def _is_coords_consistent(self):
-        for c,i in zip(self._coords,self._invs):
-            break
+        c,i = zip(self._coords,self._invs)[0]
         for cnext,inext in zip(self._coords[1:],self._invs[1:]):
             if c[i] != cnext[not inext]:
                 return False
             c,i = cnext,inext
         return True
     consistent = property(_is_coords_consistent,
                           doc="consistency of the coords transform chain")
@@ -264,25 +258,23 @@
         return np.matrix(self._matrix)
 
     @property
     def coordin(self):
         """The input coordinate system.
         """
         if not self.consistent: return None
-        for c,i in zip(self._coords,self._invs):
-            pass
+        c,i = zip(self._coords,self._invs)[-1]
         return c[i]
 
     @property
     def coordout(self):
         """The output coordinate system.
         """
         if not self.consistent: return None
-        for c,i in zip(self._coords,self._invs):
-            pass
+        c,i = zip(self._coords,self._invs)[0]
         return c[not i]
 
     @property
     def coordinstr(self):
         """The input coordinate system in str.
         """
         return coordname.get(self.coordin,'')
@@ -534,17 +526,14 @@
     Returns
     -------
     angles : float, scalar or array-like
       The angle(s) between dir1 and dir2 in radian.
 
     Examples
     --------
-    >>> import healpy as hp
-    >>> hp.rotator.angdist([.2,0], [.2, 1e-6])
-    array([  1.98669331e-07])
     """
     if hasattr(lonlat,'__len__') and len(lonlat) == 2:
         lonlat1,lonlat2 = lonlat
     else:
         lonlat1=lonlat2=lonlat
     dir1 = np.asarray(dir1)
     dir2 = np.asarray(dir2)
@@ -568,20 +557,19 @@
             vec2 = normalize_vec(vec2)
     elif dir2.ndim == 1:
         if dir2.shape[0] == 2: # theta, phi -> vec
             vec2 = np.reshape(dir2vec(dir2, lonlat = lonlat2), (3, 1))
         else:
             vec2 = np.reshape(dir2, (3, 1))
             vec2 = normalize_vec(vec2)
-    # compute vec product
-    vec_prod = np.sqrt((np.cross(vec1.T, vec2.T)**2).sum(axis=1))
     # compute scalar product
-    scal_prod = (vec1*vec2).sum(axis=0)
-
-    return np.arctan2(vec_prod, scal_prod)
+    pscal = (vec1*vec2).sum(axis=0)
+    # if scalar product is greater than 1 but close, set it to 1
+    pscal[(pscal - 1. > 0.) & (pscal - 1. < 1.e-14)] = 1. 
+    return np.arccos(pscal)
 
 def normalize_vec(vec):
     """Normalize the vector(s) *vec* (in-place if it is a ndarray).
 
     Parameters
     ----------
     vec : float, array-like of shape (D,) or (D, N)
@@ -605,15 +593,15 @@
 def check_coord(c):
     """Check if parameter is a valid coord system.
     Raise a TypeError exception if it is not, otherwise returns the normalized
     coordinate system name.
     """
     if c is None:
         return c
-    if not isinstance(c, six.string_types):
+    if type(c) is not str:
         raise TypeError('Coordinate must be a string (G[alactic],'
                         ' E[cliptic], C[elestial]'
                         ' or Equatorial=Celestial)')
     if c[0].upper() == 'G':
         x='G'
     elif c[0].upper() == 'E' and c != 'Equatorial':
         x='E'
```

### Comparing `healpy-1.9.1/healpy/projector.py` & `healpy-github-devel/healpy/projector.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,18 +22,18 @@
 
 SphericalProj : a virtual class (do nothing). Just a template for derived 
                 (useful) classes
 
 GnomonicProj : Gnomonic projection
 """
 
-from . import rotator as R
+import rotator as R
 import numpy as np
-from . import pixelfunc
-from .pixelfunc import UNSEEN
+import pixelfunc
+from pixelfunc import UNSEEN
 
 pi = np.pi
 dtor = np.pi/180.
 
 class SphericalProj(object):
     """
     This class defines functions for spherical projection.
@@ -319,31 +319,31 @@
             raise TypeError("No projection plane array information defined for "
                             "this projector")
         xsize,ysize = self.arrayinfo['xsize'],self.arrayinfo['ysize']
         reso = self.arrayinfo['reso']
         if y is None: x,y = x
         dx = reso/60. * dtor
         xc,yc = 0.5*(xsize-1), 0.5*(ysize-1)
-        j = np.around(xc+x/dx).astype(np.long)
-        i = np.around(yc+y/dx).astype(np.long)
+        j = np.around(xc+x/dx).astype(long)
+        i = np.around(yc+y/dx).astype(long)
         return i,j
     xy2ij.__doc__ = SphericalProj.xy2ij.__doc__ % (name,name)
 
     def ij2xy(self, i=None, j=None):
         if self.arrayinfo is None:
             raise TypeError("No projection plane array information defined for "
                             "this projector")
         xsize,ysize = self.arrayinfo['xsize'],self.arrayinfo['ysize']
         reso = self.arrayinfo['reso']
         dx = reso/60. * dtor
         xc,yc = 0.5*(xsize-1), 0.5*(ysize-1)
         if i is None and j is None:
-            idx=np.outer(np.ones(ysize),np.arange(xsize))
+            idx=np.outer(np.ones(xsize),np.arange(ysize))
             x=(idx-xc) * dx   # astro= '-' sign, geo '+' sign
-            idx=np.outer(np.arange(ysize),np.ones(xsize))
+            idx=np.outer(np.arange(xsize),np.ones(ysize))
             y=(idx-yc)*dx #(idx-yc) * dx
         elif i is not None and j is not None:
             x=(np.asarray(j)-xc) * dx
             y=(np.asarray(i)-yc) * dx #(asarray(i)-yc) * dx
         elif i is not None and j is None:
             i, j = i
             x=(np.asarray(j)-xc) * dx
@@ -352,15 +352,15 @@
             raise TypeError("Wrong parameters")
         return x,y
     ij2xy.__doc__ = SphericalProj.ij2xy.__doc__ % (name,name)
 
     def get_extent(self):
         xsize,ysize = self.arrayinfo['xsize'],self.arrayinfo['ysize']
         left,bottom = self.ij2xy(0,0)
-        right,top = self.ij2xy(ysize-1,xsize-1)
+        right,top = self.ij2xy(xsize-1,ysize-1)
         return (left,right,bottom,top)
 
     def get_fov(self):
         vx,vy,vz = self.xy2vec(self.ij2xy(0,0), direct=True)
         a = np.arccos(vx)
         return 2.*a
 
@@ -447,26 +447,26 @@
             raise TypeError("No projection plane array information defined for "
                             "this projector")
         xsize = self.arrayinfo['xsize']
         ysize=xsize/2
         if y is None: x,y = x
         xc,yc = (xsize-1.)/2., (ysize-1.)/2.
         if hasattr(x,'__len__'):
-            j = np.around(x*xc/2.+xc).astype(np.long)
-            i = np.around(yc+y*yc).astype(np.long)
+            j = long(np.around(x*xc/2.+xc))
+            i = long(np.around(yc+y*yc))
             mask = (x**2/4.+y**2>1.)
             if not mask.any(): mask=np.ma.nomask
             j=np.ma.array(j,mask=mask)
             i=np.ma.array(i,mask=mask)
         else:
             if x**2/4.+y**2 > 1.:
                 i,j=np.nan,np.nan
             else:
-                j = np.around(x*xc/2.+xc).astype(np.long)
-                i = np.around(yc+y*yc).astype(np.long)
+                j = np.around(x*xc/2.+xc).astype(long)
+                i = np.around(yc+y*yc).astype(long)
         return i,j
     xy2ij.__doc__ = SphericalProj.xy2ij.__doc__ % (name,name)
 
     def ij2xy(self, i=None, j=None):
         if self.arrayinfo is None:
             raise TypeError("No projection plane array information defined for "
                             "this projector")
@@ -502,16 +502,16 @@
     @staticmethod
     def __initialise_data():
         if len(MollweideProj.__molldata) == 0:
             X = (np.arange(1.,180.,1.)-90.)*dtor
             Y = MollweideProj.__findRoot(MollweideProj.__fmoll,
                                          MollweideProj.__dfmoll,
                                          X.copy(),X,niter=10)
-            X = np.concatenate([[-pi/2],X,[pi/2]])
-            Y = np.concatenate([[-pi/2],Y,[pi/2]])
+            X = np.concatenate([-pi/2,X,pi/2],None)
+            Y = np.concatenate([-pi/2,Y,pi/2],None)
             MollweideProj.__molldata.append( X )
             MollweideProj.__molldata.append( Y )
         return
 
     @staticmethod
     def __findRoot(f, df, x0, argsf=None, argsdf=None, niter=100):
         x = x0
@@ -554,21 +554,28 @@
         if latra is None: latra = [-90.,90.]
         if (len(lonra)!=2 or len(latra)!=2 or lonra[0]<-180. or lonra[1]>180.
             or latra[0]<-90 or latra[1]>90 or lonra[0]>=lonra[1] or latra[0]>=latra[1]):
             raise TypeError("Wrong argument lonra or latra. Must be lonra=[a,b],latra=[c,d] "
                             "with a<b, c<d, a>=-180, b<=180, c>=-90, d<=+90")
         lonra = self._flip*np.float64(lonra)[::self._flip]
         latra = np.float64(latra)
-        xsize = np.long(xsize)
+        xsize=long(xsize)
         if ysize is None:
             ratio = (latra[1]-latra[0])/(lonra[1]-lonra[0])
-            ysize = np.long(round(ratio*xsize))
+            ysize = long(round(ratio*xsize))
         else:
-            ysize = np.long(ysize)
+            ysize = long(ysize)
             ratio = float(ysize)/float(xsize)
+        if max(xsize,ysize) > 2000:
+            if max(xsize,ysize) == xsize:
+                xsize = 2000
+                ysize = long(round(ratio*xsize))
+            else:
+                ysize = 2000
+                xsize = long(round(ysize/ratio))
         super(CartesianProj,self).set_proj_plane_info(xsize=xsize, lonra=lonra, latra=latra, 
                                                         ysize=ysize, ratio=ratio)
 
     def vec2xy(self, vx, vy=None, vz=None, direct=False):
         if not direct:
             theta,phi=R.vec2dir(self.rotator(vx,vy,vz))
         else:
@@ -586,22 +593,18 @@
         if y is None:
             x,y = np.asarray(x)
         else:
             x,y = np.asarray(x),np.asarray(y)
         flip = self._flip
         theta = pi/2.-y*dtor # convert in radian
         phi = flip*x*dtor # convert in radian
-        # dir2vec does not support 2d arrays, so first use flatten and then
-        # reshape back to previous shape
-        if not direct: 
-            vec = self.rotator.I(R.dir2vec(theta.flatten(),phi.flatten()))
-        else:
-            vec = R.dir2vec(theta.flatten(),phi.flatten())
-        vec = [v.reshape(theta.shape) for v in vec]
-        return vec
+        if not direct:
+            return self.rotator.I(R.dir2vec(theta,phi))
+        else:
+            return R.dir2vec(theta,phi)
     xy2vec.__doc__ = SphericalProj.xy2vec.__doc__ % (name,name)
 
     def ang2xy(self, theta, phi=None, lonlat=False, direct=False):
         return self.vec2xy(R.dir2vec(theta,phi,lonlat=lonlat),direct=direct)
     ang2xy.__doc__ = SphericalProj.ang2xy.__doc__ % (name,name)
     
     def xy2ang(self, x, y=None, lonlat=False, direct=False):
@@ -692,197 +695,7 @@
     def get_center(self,lonlat=False):
         lonra = self.arrayinfo['lonra']
         latra = self.arrayinfo['latra']
         xc = 0.5*(lonra[1]+lonra[0])
         yc = 0.5*(latra[1]+latra[0])
         return self.xy2ang(xc,yc,lonlat=lonlat)
     get_center.__doc__ = SphericalProj.get_center.__doc__
-
-
-class OrthographicProj(SphericalProj):
-    """This class provides methods for orthographic projection
-    """
-    
-    name = "Orthographic"
-    
-    def __init__(self, rot=None, coord=None, xsize=800, half_sky=False,**kwds):
-        super(OrthographicProj,self).__init__(rot=rot, coord=coord,xsize=xsize,
-                                              half_sky=half_sky,**kwds)
-    
-    def set_proj_plane_info(self,xsize,half_sky):
-        super(OrthographicProj,self).set_proj_plane_info(xsize=xsize,
-                                                         half_sky=half_sky)
-    
-    def vec2xy(self, vx, vy=None, vz=None, direct=False):
-        if not direct:
-            theta,phi=R.vec2dir(self.rotator(vx,vy,vz))
-        else:
-            theta,phi=R.vec2dir(vx,vy,vz)
-        if self.arrayinfo is None:
-            raise TypeError("No projection plane array information defined for"
-                            " this projector")
-        half_sky = self.arrayinfo['half_sky']
-        flip = self._flip
-        # set phi in [-pi,pi]
-        phi = flip*(phi+pi)%(2*pi)-pi
-        lat = pi/2. - theta
-        x = np.cos(lat)*np.sin(phi)
-        if not half_sky: x -= 1.0
-        y = np.sin(lat)
-        # unfold back of sphere
-        cosc = np.cos(lat)*np.cos(phi)
-        if np.any(cosc<0):
-            hmask = (cosc<0)
-            if hasattr(x,'__len__'):
-                if half_sky:
-                    x[hmask] = np.nan
-                else:
-                    x[hmask] *= -1
-            elif hmask:
-                if half_sky:
-                    x = np.nan
-                else:
-                    x *= -1
-        if half_sky:
-            mask = (np.asarray(x)**2+np.asarray(y)**2>1.0)
-        else:
-            mask = ((np.mod(np.asarray(x)+2.0,2.0)-1.0)**2 + \
-                    np.asarray(y)**2>1.0)
-        if mask.any():
-            if not hasattr(x,'__len__'):
-                x = np.nan
-                y = np.nan
-            else:
-                x[mask] = np.nan
-                y[mask] = np.nan
-        return x,y
-    vec2xy.__doc__ = SphericalProj.vec2xy.__doc__ % (name,name)
-    
-    def xy2vec(self, x, y=None, direct=False):
-        if y is None:
-            x,y = x
-        if hasattr(x,'__len__'):
-            x,y = np.asarray(x),np.asarray(y)
-        if self.arrayinfo is None:
-            raise TypeError("No projection plane array information defined for"
-                            " this projector")
-        half_sky = self.arrayinfo['half_sky']
-        flip = self._flip
-        # re-fold back of sphere
-        mask = None
-        if not half_sky:
-            if hasattr(x,'__len__'):
-                if np.any(x>0.0):
-                    mask = (x>0.0)
-                    x[mask] *= -1
-            elif x>0:
-                mask = 0
-                x = -x
-            x+=1.0
-        r = np.sqrt(x**2+y**2)
-        if hasattr(r,'__len__'):
-            r[r>1] = np.nan
-        elif r>1: r = np.nan
-        c = np.arcsin(r)
-        if hasattr(y,'__len__'):
-            y[np.abs(y)>1] = np.nan
-        elif np.abs(y)>1: y = np.nan
-        lat = np.arcsin(y)
-        phi = np.arctan2(x,np.cos(c))
-        phi *= flip
-        if not mask is None:
-            if hasattr(phi,'__len__'):
-                phi[mask] = pi-phi[mask]
-            else: phi = pi-phi
-        theta = pi/2. - lat
-        vec = R.dir2vec(theta,phi)
-        if not direct:
-            return self.rotator.I(vec)
-        else:
-            return vec
-    xy2vec.__doc__ = SphericalProj.xy2vec.__doc__ % (name,name)
-    
-    def ang2xy(self, theta, phi=None, lonlat=False, direct=False):
-        return self.vec2xy(R.dir2vec(theta,phi,lonlat=lonlat),direct=direct)
-    ang2xy.__doc__ = SphericalProj.ang2xy.__doc__ % (name,name)
-    
-    def xy2ang(self, x, y=None, lonlat=False, direct=False):
-        return R.vec2dir(self.xy2vec(x,y,direct=direct),lonlat=lonlat)
-    xy2ang.__doc__ = SphericalProj.xy2ang.__doc__ % (name,name)
-
-    def xy2ij(self, x, y=None):
-        if self.arrayinfo is None:
-            raise TypeError("No projection plane array information defined for"
-                            " this projector")
-        xsize = self.arrayinfo['xsize']
-        half_sky = self.arrayinfo['half_sky']
-        if half_sky: ratio = 1.0
-        else: ratio = 2.0
-        ysize = xsize/ratio
-        if y is None: x,y = np.asarray(x)
-        else: x,y = np.asarray(x), np.asarray(y)
-        xc,yc = (xsize-1.)/2., (ysize-1.)/2.
-        if hasattr(x,'__len__'):
-            if half_sky:
-                mask = (x**2+y**2>1.0)
-            else:
-                mask = ((np.mod(x+2.0,2.0)-1.0)**2+y**2>1.0)
-            if not mask.any(): mask = np.ma.nomask
-            j=np.ma.array(np.around(x*xc/ratio+xc).astype(np.long),mask=mask)
-            i=np.ma.array(np.around(yc+y*yc).astype(np.long),mask=mask)
-        else:
-            if ( half_sky and x**2+y**2>1.0 ) or \
-                   ( not half_sky and (np.mod(x+2.0,2.0)-1.0)**2+y**2>1.0 ):
-                i,j,=np.nan,np.nan
-            else:
-                j = np.around(x*xc/ratio+xc).astype(np.long)
-                i = np.around(yc+y*yc).astype(np.long)
-        return i,j
-    xy2ij.__doc__ = SphericalProj.xy2ij.__doc__ % (name,name)
-    
-    def ij2xy(self, i=None, j=None):
-        if self.arrayinfo is None:
-            raise TypeError("No projection plane array information defined for"
-                            " this projector")
-        xsize = self.arrayinfo['xsize']
-        half_sky = self.arrayinfo['half_sky']
-        if half_sky: ratio = 1.0
-        else: ratio = 2.0
-        ysize=xsize/ratio
-        xc,yc=(xsize-1.)/2.,(ysize-1.)/2.
-        if i is None and j is None:
-            idx = np.outer(np.arange(ysize),np.ones(xsize))
-            y = (idx-yc)/yc
-            idx = np.outer(np.ones(ysize),np.arange(xsize))
-            x = ratio*(idx-xc)/xc
-        elif i is not None and j is not None:
-            y = (np.asarray(i)-yc)/yc
-            x = ratio*(np.asarray(j)-xc)/xc
-            # if np.mod(x,1.0)**2+y**2 > 1.0: x,y=np.nan,np.nan
-        elif i is not None and j is None:
-            i,j = i
-            y=(np.asarray(i)-yc)/yc
-            x=ratio*(np.asarray(j)-xc)/xc
-            # if np.mod(x,1.0)**2.+y**2 > 1.: x,y=np.nan,np.nan
-        else:
-            raise TypeError("i and j must be both given or both not given")
-        if half_sky:
-            mask = (x**2+y**2>1.)
-        else:
-            mask = ((np.mod(x+2.0,2.0)-1.0)**2+y**2 > 1.)
-        if not mask.any(): mask=np.ma.nomask
-        x = np.ma.array(x,mask=mask)
-        y = np.ma.array(y,mask=mask)
-        if len(x)==0: x = x[0]
-        if len(y)==0: y = y[0]
-        return x,y
-    ij2xy.__doc__ = SphericalProj.ij2xy.__doc__ % (name,name)
-    
-    def get_extent(self):
-        if self.arrayinfo is None:
-            raise TypeError("No projection plane array information defined for"
-                            " this projector")
-        half_sky = self.arrayinfo['half_sky']
-        if half_sky: ratio = 1.0
-        else: ratio = 2.0
-        return (-ratio,ratio,-1.0,1.0)
-    get_extent.__doc__ = SphericalProj.get_extent.__doc__
```

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n2048.fits` & `healpy-github-devel/healpy/data/pixel_window_n2048.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0004.fits` & `healpy-github-devel/healpy/data/pixel_window_n0004.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n02048.fits` & `healpy-github-devel/healpy/data/weight_ring_n02048.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00032.fits` & `healpy-github-devel/healpy/data/weight_ring_n00032.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0008.fits` & `healpy-github-devel/healpy/data/pixel_window_n0008.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0032.fits` & `healpy-github-devel/healpy/data/pixel_window_n0032.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00064.fits` & `healpy-github-devel/healpy/data/weight_ring_n00064.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n4096.fits` & `healpy-github-devel/healpy/data/pixel_window_n4096.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n01024.fits` & `healpy-github-devel/healpy/data/weight_ring_n01024.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0128.fits` & `healpy-github-devel/healpy/data/pixel_window_n0128.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00256.fits` & `healpy-github-devel/healpy/data/weight_ring_n00256.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00002.fits` & `healpy-github-devel/healpy/data/weight_ring_n00002.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00128.fits` & `healpy-github-devel/healpy/data/weight_ring_n00128.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n04096.fits` & `healpy-github-devel/healpy/data/weight_ring_n04096.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00512.fits` & `healpy-github-devel/healpy/data/weight_ring_n00512.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/totcls.dat` & `healpy-github-devel/healpy/data/totcls.dat`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0016.fits` & `healpy-github-devel/healpy/data/pixel_window_n0016.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0512.fits` & `healpy-github-devel/healpy/data/pixel_window_n0512.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n8192.fits` & `healpy-github-devel/healpy/data/pixel_window_n8192.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0256.fits` & `healpy-github-devel/healpy/data/pixel_window_n0256.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0064.fits` & `healpy-github-devel/healpy/data/pixel_window_n0064.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n08192.fits` & `healpy-github-devel/healpy/data/weight_ring_n08192.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00016.fits` & `healpy-github-devel/healpy/data/weight_ring_n00004.fits`

 * *Files 18% similar despite different names*

```diff
@@ -25,15 +25,15 @@
 00000180: 6564 2069 6e20 2741 7374 726f 6e6f 6d79  ed in 'Astronomy
 00000190: 434f 4d4d 454e 5420 2020 616e 6420 4173  COMMENT   and As
 000001a0: 7472 6f70 6879 7369 6373 272c 2076 6f6c  trophysics', vol
 000001b0: 756d 6520 3337 362c 2070 6167 6520 3335  ume 376, page 35
 000001c0: 393b 2062 6962 636f 6465 3a20 3230 3031  9; bibcode: 2001
 000001d0: 4126 412e 2e2e 3337 362e 2e33 3539 4820  A&A...376..359H 
 000001e0: 4441 5445 2020 2020 3d20 2732 3030 352d  DATE    = '2005-
-000001f0: 3038 2d31 3754 3233 3a30 333a 3537 2720  08-17T23:03:57' 
+000001f0: 3038 2d31 3754 3233 3a30 333a 3432 2720  08-17T23:03:42' 
 00000200: 2f20 6669 6c65 2063 7265 6174 696f 6e20  / file creation 
 00000210: 6461 7465 2028 5959 5959 2d4d 4d2d 4444  date (YYYY-MM-DD
 00000220: 5468 683a 6d6d 3a73 7320 5554 2920 2020  Thh:mm:ss UT)   
 00000230: 454e 4420 2020 2020 2020 2020 2020 2020  END             
 00000240: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000260: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -195,15 +195,15 @@
 00000c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000c30: 4e41 5849 5331 2020 3d20 2020 2020 2020  NAXIS1  =       
 00000c40: 2020 2020 2020 2020 2020 2020 3234 202f              24 /
 00000c50: 2077 6964 7468 206f 6620 7461 626c 6520   width of table 
 00000c60: 696e 2062 7974 6573 2020 2020 2020 2020  in bytes        
 00000c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000c80: 4e41 5849 5332 2020 3d20 2020 2020 2020  NAXIS2  =       
-00000c90: 2020 2020 2020 2020 2020 2020 3332 202f              32 /
+00000c90: 2020 2020 2020 2020 2020 2020 2038 202f               8 /
 00000ca0: 206e 756d 6265 7220 6f66 2072 6f77 7320   number of rows 
 00000cb0: 696e 2074 6162 6c65 2020 2020 2020 2020  in table        
 00000cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000cd0: 5043 4f55 4e54 2020 3d20 2020 2020 2020  PCOUNT  =       
 00000ce0: 2020 2020 2020 2020 2020 2020 2030 202f               0 /
 00000cf0: 2073 697a 6520 6f66 2073 7065 6369 616c   size of special
 00000d00: 2064 6174 6120 6172 6561 2020 2020 2020   data area      
@@ -215,30 +215,30 @@
 00000d60: 6429 2020 2020 2020 2020 2020 2020 2020  d)              
 00000d70: 5446 4945 4c44 5320 3d20 2020 2020 2020  TFIELDS =       
 00000d80: 2020 2020 2020 2020 2020 2020 2033 202f               3 /
 00000d90: 206e 756d 6265 7220 6f66 2066 6965 6c64   number of field
 00000da0: 7320 696e 2065 6163 6820 726f 7720 2020  s in each row   
 00000db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000dc0: 4e53 4944 4520 2020 3d20 2020 2020 2020  NSIDE   =       
-00000dd0: 2020 2020 2020 2020 2020 2020 3136 202f              16 /
+00000dd0: 2020 2020 2020 2020 2020 2020 2034 202f               4 /
 00000de0: 2052 6573 6f6c 7574 696f 6e20 7061 7261   Resolution para
 00000df0: 6d65 7465 7220 666f 7220 4845 414c 5049  meter for HEALPI
 00000e00: 5820 2020 2020 2020 2020 2020 2020 2020  X               
 00000e10: 4352 4541 544f 5220 3d20 2751 5541 445f  CREATOR = 'QUAD_
 00000e20: 5249 4e47 2720 2020 2020 2020 2020 202f  RING'          /
 00000e30: 2053 6f66 7477 6172 6520 6372 6561 7469   Software creati
 00000e40: 6e67 2074 6865 2046 4954 5320 6669 6c65  ng the FITS file
 00000e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000e60: 5645 5253 494f 4e20 3d20 2731 2e33 2e30  VERSION = '1.3.0
 00000e70: 2020 2027 2020 2020 2020 2020 2020 202f     '           /
 00000e80: 2056 6572 7369 6f6e 206f 6620 7468 6520   Version of the 
 00000e90: 7369 6d75 6c61 7469 6f6e 2073 6f66 7477  simulation softw
 00000ea0: 6172 6520 2020 2020 2020 2020 2020 2020  are             
 00000eb0: 4d41 582d 4c50 4f4c 3d20 2020 2020 2020  MAX-LPOL=       
-00000ec0: 2020 2020 2020 2020 2020 2020 3438 202f              48 /
+00000ec0: 2020 2020 2020 2020 2020 2020 2038 202f               8 /
 00000ed0: 204d 6178 696d 756d 206d 756c 7469 706f   Maximum multipo
 00000ee0: 6c65 206c 2075 7365 6420 696e 206d 6170  le l used in map
 00000ef0: 2073 796e 7468 6573 6973 2020 2020 2020   synthesis      
 00000f00: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 00000f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00000f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -304,21 +304,21 @@
 000012f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001300: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001310: 5446 4f52 4d31 2020 3d20 2731 4420 2020  TFORM1  = '1D   
 00001320: 2020 2027 2020 2020 2020 2020 2020 2020     '            
 00001330: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001340: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001360: 4d41 5856 414c 3120 3d20 2020 312e 3635  MAXVAL1 =   1.65
-00001370: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001360: 4d41 5856 414c 3120 3d20 2020 312e 3139  MAXVAL1 =   1.19
+00001370: 3832 3738 3431 3836 3738 452d 3031 202f  8278418678E-01 /
 00001380: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
 00001390: 6620 5420 7765 6967 6874 7320 2020 2020  f T weights     
 000013a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000013b0: 4d49 4e56 414c 3120 3d20 202d 372e 3234  MINVAL1 =  -7.24
-000013c0: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+000013b0: 4d49 4e56 414c 3120 3d20 202d 312e 3933  MINVAL1 =  -1.93
+000013c0: 3133 3130 3232 3431 3033 452d 3032 202f  1310224103E-02 /
 000013d0: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
 000013e0: 6620 5420 7765 6967 6874 7320 2020 2020  f T weights     
 000013f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001400: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 00001410: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001420: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001430: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -334,21 +334,21 @@
 000014d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000014e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000014f0: 5446 4f52 4d32 2020 3d20 2731 4420 2020  TFORM2  = '1D   
 00001500: 2020 2027 2020 2020 2020 2020 2020 2020     '            
 00001510: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001520: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001540: 4d41 5856 414c 3220 3d20 2020 312e 3635  MAXVAL2 =   1.65
-00001550: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001540: 4d41 5856 414c 3220 3d20 2020 312e 3139  MAXVAL2 =   1.19
+00001550: 3832 3738 3431 3836 3738 452d 3031 202f  8278418678E-01 /
 00001560: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
 00001570: 6620 5120 7765 6967 6874 7320 2020 2020  f Q weights     
 00001580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001590: 4d49 4e56 414c 3220 3d20 202d 372e 3234  MINVAL2 =  -7.24
-000015a0: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+00001590: 4d49 4e56 414c 3220 3d20 202d 312e 3933  MINVAL2 =  -1.93
+000015a0: 3133 3130 3232 3431 3033 452d 3032 202f  1310224103E-02 /
 000015b0: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
 000015c0: 6620 5120 7765 6967 6874 7320 2020 2020  f Q weights     
 000015d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000015e0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 000015f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001600: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001610: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -364,21 +364,21 @@
 000016b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000016c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000016d0: 5446 4f52 4d33 2020 3d20 2731 4420 2020  TFORM3  = '1D   
 000016e0: 2020 2027 2020 2020 2020 2020 2020 2020     '            
 000016f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00001710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001720: 4d41 5856 414c 3320 3d20 2020 312e 3635  MAXVAL3 =   1.65
-00001730: 3737 3636 3839 3734 3231 452d 3031 202f  7766897421E-01 /
+00001720: 4d41 5856 414c 3320 3d20 2020 312e 3139  MAXVAL3 =   1.19
+00001730: 3832 3738 3431 3836 3738 452d 3031 202f  8278418678E-01 /
 00001740: 206d 6178 696d 756d 2076 616c 7565 206f   maximum value o
 00001750: 6620 5520 7765 6967 6874 7320 2020 2020  f U weights     
 00001760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001770: 4d49 4e56 414c 3320 3d20 202d 372e 3234  MINVAL3 =  -7.24
-00001780: 3133 3635 3338 3834 3537 452d 3032 202f  1365388457E-02 /
+00001770: 4d49 4e56 414c 3320 3d20 202d 312e 3933  MINVAL3 =  -1.93
+00001780: 3133 3130 3232 3431 3033 452d 3032 202f  1310224103E-02 /
 00001790: 206d 696e 696d 756d 2076 616c 7565 206f   minimum value o
 000017a0: 6620 5520 7765 6967 6874 7320 2020 2020  f U weights     
 000017b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000017c0: 434f 4d4d 454e 5420 2020 2020 2020 2020  COMMENT         
 000017d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000017e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
@@ -534,62 +534,62 @@
 00002150: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002180: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000021a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000021b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000021c0: 3fc5 382b aa70 ce1d 3fc5 382b aa70 ce1d  ?.8+.p..?.8+.p..
-000021d0: 3fc5 382b aa70 ce1d bfb2 89b3 8337 d466  ?.8+.p.......7.f
-000021e0: bfb2 89b3 8337 d466 bfb2 89b3 8337 d466  .....7.f.....7.f
-000021f0: 3fa0 caeb 0c50 0127 3fa0 caeb 0c50 0127  ?....P.'?....P.'
-00002200: 3fa0 caeb 0c50 0127 bf87 e694 5197 3abe  ?....P.'....Q.:.
-00002210: bf87 e694 5197 3abe bf87 e694 5197 3abe  ....Q.:.....Q.:.
-00002220: 3f3d 28f5 9b6b 2ef6 3f3d 28f5 9b6b 2ef6  ?=(..k..?=(..k..
-00002230: 3f3d 28f5 9b6b 2ef6 3f72 93a4 dc48 9006  ?=(..k..?r...H..
-00002240: 3f72 93a4 dc48 9006 3f72 93a4 dc48 9006  ?r...H..?r...H..
-00002250: bf76 f43d 9bf4 da5f bf76 f43d 9bf4 da5f  .v.=..._.v.=..._
-00002260: bf76 f43d 9bf4 da5f 3f72 95a3 fddf 852b  .v.=..._?r.....+
-00002270: 3f72 95a3 fddf 852b 3f72 95a3 fddf 852b  ?r.....+?r.....+
-00002280: bf65 e477 4fd5 1938 bf65 e477 4fd5 1938  .e.wO..8.e.wO..8
-00002290: bf65 e477 4fd5 1938 3f4d 7da3 09c4 990e  .e.wO..8?M}.....
-000022a0: 3f4d 7da3 09c4 990e 3f4d 7da3 09c4 990e  ?M}.....?M}.....
-000022b0: 3f34 e10b 070b 36cc 3f34 e10b 070b 36cc  ?4....6.?4....6.
-000022c0: 3f34 e10b 070b 36cc bf4c c1d1 3392 0fcb  ?4....6..L..3...
-000022d0: bf4c c1d1 3392 0fcb bf4c c1d1 3392 0fcb  .L..3....L..3...
-000022e0: 3f4e 4dc8 7dc2 a9be 3f4e 4dc8 7dc2 a9be  ?NM.}...?NM.}...
-000022f0: 3f4e 4dc8 7dc2 a9be bf4a 1688 9b06 c74e  ?NM.}....J.....N
-00002300: bf4a 1688 9b06 c74e bf4a 1688 9b06 c74e  .J.....N.J.....N
-00002310: 3f54 0c15 96f2 8c2b 3f54 0c15 96f2 8c2b  ?T.....+?T.....+
-00002320: 3f54 0c15 96f2 8c2b bf7a 4800 78b4 dc0d  ?T.....+.zH.x...
-00002330: bf7a 4800 78b4 dc0d bf7a 4800 78b4 dc0d  .zH.x....zH.x...
-00002340: bf3d e0b2 7bc5 224c bf3d e0b2 7bc5 224c  .=..{."L.=..{."L
-00002350: bf3d e0b2 7bc5 224c 3f61 a4d1 6816 9109  .=..{."L?a..h...
-00002360: 3f61 a4d1 6816 9109 3f61 a4d1 6816 9109  ?a..h...?a..h...
-00002370: bf64 44d4 af5c a317 bf64 44d4 af5c a317  .dD..\...dD..\..
-00002380: bf64 44d4 af5c a317 3f5b be82 667c aeef  .dD..\..?[..f|..
-00002390: 3f5b be82 667c aeef 3f5b be82 667c aeef  ?[..f|..?[..f|..
-000023a0: bf26 52a9 5b9d 506d bf26 52a9 5b9d 506d  .&R.[.Pm.&R.[.Pm
-000023b0: bf26 52a9 5b9d 506d bf54 c359 ddd7 7024  .&R.[.Pm.T.Y..p$
-000023c0: bf54 c359 ddd7 7024 bf54 c359 ddd7 7024  .T.Y..p$.T.Y..p$
-000023d0: 3f5b a57c 08c5 cbe6 3f5b a57c 08c5 cbe6  ?[.|....?[.|....
-000023e0: 3f5b a57c 08c5 cbe6 bf49 985d 8d8d 3e66  ?[.|.....I.]..>f
-000023f0: bf49 985d 8d8d 3e66 bf49 985d 8d8d 3e66  .I.]..>f.I.]..>f
-00002400: bf47 7d9e 8fc9 91ee bf47 7d9e 8fc9 91ee  .G}......G}.....
-00002410: bf47 7d9e 8fc9 91ee 3f58 9043 e794 8050  .G}.....?X.C...P
-00002420: 3f58 9043 e794 8050 3f58 9043 e794 8050  ?X.C...P?X.C...P
-00002430: bf4b 8a37 e6a8 a0cc bf4b 8a37 e6a8 a0cc  .K.7.....K.7....
-00002440: bf4b 8a37 e6a8 a0cc bf44 7149 d787 c641  .K.7.....DqI...A
-00002450: bf44 7149 d787 c641 bf44 7149 d787 c641  .DqI...A.DqI...A
-00002460: 3f57 2ce1 2d00 b2b0 3f57 2ce1 2d00 b2b0  ?W,.-...?W,.-...
-00002470: 3f57 2ce1 2d00 b2b0 bf46 2fc2 b146 52c5  ?W,.-....F/..FR.
-00002480: bf46 2fc2 b146 52c5 bf46 2fc2 b146 52c5  .F/..FR..F/..FR.
-00002490: bf4c ee5f cc92 55ef bf4c ee5f cc92 55ef  .L._..U..L._..U.
-000024a0: bf4c ee5f cc92 55ef 3f5b 7542 4965 7a78  .L._..U.?[uBIezx
-000024b0: 3f5b 7542 4965 7a78 3f5b 7542 4965 7a78  ?[uBIezx?[uBIezx
+000021c0: 3fbe ad09 95f9 0093 3fbe ad09 95f9 0093  ?.......?.......
+000021d0: 3fbe ad09 95f9 0093 bf7a b6ee 08a6 ee55  ?........z.....U
+000021e0: bf7a b6ee 08a6 ee55 bf7a b6ee 08a6 ee55  .z.....U.z.....U
+000021f0: bf93 c6d0 5a09 c466 bf93 c6d0 5a09 c466  ....Z..f....Z..f
+00002200: bf93 c6d0 5a09 c466 bf7e 6146 ceb7 6ba4  ....Z..f.~aF..k.
+00002210: bf7e 6146 ceb7 6ba4 bf7e 6146 ceb7 6ba4  .~aF..k..~aF..k.
+00002220: bf71 3079 248e e37e bf71 3079 248e e37e  .q0y$..~.q0y$..~
+00002230: bf71 3079 248e e37e bf6a 9e62 a476 b45c  .q0y$..~.j.b.v.\
+00002240: bf6a 9e62 a476 b45c bf6a 9e62 a476 b45c  .j.b.v.\.j.b.v.\
+00002250: 3f2c a304 43b1 30db 3f2c a304 43b1 30db  ?,..C.0.?,..C.0.
+00002260: 3f2c a304 43b1 30db 3f73 ef35 bbe1 c3b4  ?,..C.0.?s.5....
+00002270: 3f73 ef35 bbe1 c3b4 3f73 ef35 bbe1 c3b4  ?s.5....?s.5....
+00002280: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002290: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000022f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002300: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002310: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002320: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002330: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002340: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002350: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002360: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002370: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002380: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002390: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000023f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002400: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002410: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002420: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002430: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002440: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002450: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002460: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002470: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002480: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+00002490: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000024a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
+000024b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000024c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000024d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000024e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 000024f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00002500: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00002510: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00002520: 0000 0000 0000 0000 0000 0000 0000 0000  ................
```

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n1024.fits` & `healpy-github-devel/healpy/data/pixel_window_n1024.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/weight_ring_n00008.fits` & `healpy-github-devel/healpy/data/weight_ring_n00008.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/data/pixel_window_n0002.fits` & `healpy-github-devel/healpy/data/pixel_window_n0002.fits`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpy/projaxes.py` & `healpy-github-devel/healpy/projaxes.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,28 +13,26 @@
 # 
 #  You should have received a copy of the GNU General Public License
 #  along with Healpy; if not, write to the Free Software
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 # 
 #  For more information about Healpy, see http://code.google.com/p/healpy
 # 
-from . import projector as P
-from . import rotator as R
-from . import pixelfunc
+import projector as P
+import rotator as R
+import pixelfunc
 import matplotlib
-import matplotlib.axes
+from matplotlib import axes,ticker,colors,cm,lines,cbook,figure
 import numpy as np
-import six
-
-from ._healpy_pixel_lib import UNSEEN
+from _healpy_pixel_lib import UNSEEN
 
 pi = np.pi
 dtor = pi/180.
 
-class SphericalProjAxes(matplotlib.axes.Axes):
+class SphericalProjAxes(axes.Axes):
     """Define a special Axes to take care of spherical projection.
 
     Parameters
     ----------
     projection : a SphericalProj class or a class derived from it.
         type of projection
     rot : list or string
@@ -175,15 +173,14 @@
         img = np.ma.masked_values(img, badval)
         aximg = self.imshow(img,extent = ext,cmap=cm,norm=nn,
                             interpolation='nearest',origin='lower',
                             vmin=vmin,vmax=vmax,**kwds)
         xmin,xmax,ymin,ymax = self.proj.get_extent()
         self.set_xlim(xmin,xmax)
         self.set_ylim(ymin,ymax)
-        return img
 
     def projplot(self,*args,**kwds):
         """projplot is a wrapper around :func:`matplotlib.Axes.plot` to take into account the
         spherical projection.
 
         You can call this function as::
         
@@ -252,22 +249,19 @@
         vec = (R.Rotator(rot=rot,coord=coord,eulertype='Y')).I(vec)
         x,y = self.proj.vec2xy(vec,direct=kwds.pop('direct',False))
         x,y = self._make_segment(x,y,threshold=kwds.pop('threshold',
                                                         self._segment_threshold))
         thelines = []
         for xx,yy in zip(x,y):
             if fmt is not None:
-                try: # works in matplotlib 1.3 and earlier
-                    linestyle, marker, color = matplotlib.axes._process_plot_format(fmt)
-                except: # matplotlib 1.4 and later
-                    linestyle, marker, color = matplotlib.axes._axes._process_plot_format(fmt)
+                linestyle, marker, color = axes._process_plot_format(fmt)
                 kwds.setdefault('linestyle',linestyle)
                 kwds.setdefault('marker',marker)
                 if color is not None: kwds.setdefault('color',color)
-            l = matplotlib.lines.Line2D(xx,yy,**kwds)
+            l = lines.Line2D(xx,yy,**kwds)
             self.add_line(l)
             thelines.append(l)
         return thelines
 
     def projscatter(self,theta, phi=None,*args,**kwds):
         """Projscatter is a wrapper around :func:`matplotlib.Axes.scatter` to take into account the
         spherical projection.
@@ -392,15 +386,15 @@
             x=np.roll(x,-w[0])
             y=np.roll(y,-w[0])
             xx.append(x)
             yy.append(y)
         elif len(w) >= 2:
             xx.append(x[0:w[0]])
             yy.append(y[0:w[0]])
-            for i in six.moves.xrange(len(w)-1):
+            for i in xrange(len(w)-1):
                 xx.append(x[w[i]:w[i+1]])
                 yy.append(y[w[i]:w[i+1]])
             xx.append(x[w[-1]:])
             yy.append(y[w[-1]:])
         else:
             xx.append(x)
             yy.append(y)
@@ -482,17 +476,15 @@
         if u_mmax: u_mmax = ( ((u_mmax+180.)%360)-180)*dtor
         pmin,pmax = self.get_parallel_interval(vec0)
         mmin,mmax = self.get_meridian_interval(vec0)
         if u_pmin: pmin = u_pmin
         if u_pmax: pmax = u_pmax
         if u_mmin: mmin = u_mmin
         if u_mmax: mmax = u_pmax
-        if verbose:
-            print('{0} {1} {2} {3}'.format(
-                pmin/dtor, pmax/dtor, mmin/dtor, mmax/dtor))
+        if verbose: print pmin/dtor,pmax/dtor,mmin/dtor,mmax/dtor
         if not kwds.pop('force',False):
             dpar,dmer = self._get_interv_graticule(pmin,pmax,dpar,
                                                    mmin,mmax,dmer,
                                                    verbose=verbose)
         theta_list = np.around(np.arange(pmin,pmax+0.5*dpar,dpar)/dpar)*dpar
         phi_list = np.around(np.arange(mmin,mmax+0.5*dmer,dmer)/dmer)*dmer
         theta = np.arange(pmin,pmax,min((pmax-pmin)/100.,
@@ -552,15 +544,15 @@
         if hasattr(self,'_graticules'):
             for dum1,dum2,g in self._graticules:
                 for gl in g:
                     for l in gl: 
                         if l in self.lines:
                             self.lines.remove(l)
                         else:
-                            print('line not in lines')
+                            print 'line not in lines'
             del self._graticules
 
     def _get_interv_graticule(self,pmin,pmax,dpar,mmin,mmax,dmer,verbose=True):
         def set_prec(d,n,nn=2):
             arcmin=False
             if d/n < 1.:
                 d *= 60
@@ -579,20 +571,20 @@
         n_mer = (mmax-mmin)/dmer
         if n_par > max_n_par:
             dpar = set_prec((pmax-pmin)/dtor,max_n_par/2)*dtor
         if n_mer > max_n_mer:
             dmer = set_prec((mmax-mmin)/dtor,max_n_mer/2,nn=1)*dtor
         if dmer/dpar < 0.2 or dmer/dpar > 5.:
             dmer = dpar = max(dmer,dpar)
-        vdeg = int(np.floor(np.around(dpar/dtor,10)))
+        vdeg = np.floor(np.around(dpar/dtor,10))
         varcmin = (dpar/dtor-vdeg)*60.
-        if verbose: print("The interval between parallels is {0:d} deg {1:.2f}'.".format(vdeg,varcmin))
-        vdeg = int(np.floor(np.around(dmer/dtor,10)))
+        if verbose: print "The interval between parallels is %d deg %.2f'."%(vdeg,varcmin)
+        vdeg = np.floor(np.around(dmer/dtor,10))
         varcmin = (dmer/dtor-vdeg)*60.
-        if verbose: print("The interval between meridians is {0:d} deg {1:.2f}'.".format(vdeg,varcmin))
+        if verbose: print "The interval between meridians is %d deg %.2f'."%(vdeg,varcmin)
         return dpar,dmer
         
 class GnomonicAxes(SphericalProjAxes):
     """Define a gnomonic Axes to handle gnomonic projection.
 
     Input:
       - rot=, coord= : define rotation and coordinate system. See rotator.
@@ -606,24 +598,24 @@
         super(GnomonicAxes,self).__init__(P.GnomonicProj, *args,**kwds)
         self._do_border = False
         self._gratdef['local'] = True
         self._gratdef['dpar'] = 1.
 
     def projmap(self,map,vec2pix_func,xsize=200,ysize=None,reso=1.5,**kwds):
         self.proj.set_proj_plane_info(xsize=xsize,ysize=ysize,reso=reso)
-        return super(GnomonicAxes,self).projmap(map,vec2pix_func,**kwds)
+        super(GnomonicAxes,self).projmap(map,vec2pix_func,**kwds)
         
 class HpxGnomonicAxes(GnomonicAxes):
     def projmap(self,map,nest=False,**kwds):
         nside = pixelfunc.npix2nside(pixelfunc.get_map_size(map))
         f = lambda x,y,z: pixelfunc.vec2pix(nside,x,y,z,nest=nest)
         xsize = kwds.pop('xsize',200)
         ysize = kwds.pop('ysize',None)
         reso = kwds.pop('reso',1.5)
-        return super(HpxGnomonicAxes,self).projmap(map,f,xsize=xsize,
+        super(HpxGnomonicAxes,self).projmap(map,f,xsize=xsize,
                                             ysize=ysize,reso=reso,**kwds)
 
 
 class MollweideAxes(SphericalProjAxes):
     """Define a mollweide Axes to handle mollweide projection.
 
     Input:
@@ -637,84 +629,55 @@
         kwds.setdefault('coordprec',2)
         super(MollweideAxes,self).__init__(P.MollweideProj, *args,**kwds)
         self.set_xlim(-2.01,2.01)
         self.set_ylim(-1.01,1.01)
 
     def projmap(self,map,vec2pix_func,xsize=800,**kwds):
         self.proj.set_proj_plane_info(xsize=xsize)
-        img = super(MollweideAxes,self).projmap(map,vec2pix_func,**kwds)
+        super(MollweideAxes,self).projmap(map,vec2pix_func,**kwds)
         self.set_xlim(-2.01,2.01)
         self.set_ylim(-1.01,1.01)
-        return img
         
 class HpxMollweideAxes(MollweideAxes):
     def projmap(self,map,nest=False,**kwds):
         nside = pixelfunc.npix2nside(pixelfunc.get_map_size(map))
         f = lambda x,y,z: pixelfunc.vec2pix(nside,x,y,z,nest=nest)
-        return super(HpxMollweideAxes,self).projmap(map,f,**kwds)
+        super(HpxMollweideAxes,self).projmap(map,f,**kwds)
+
 
 class CartesianAxes(SphericalProjAxes):
     """Define a cylindrical Axes to handle cylindrical projection.
     """
     def __init__(self,*args,**kwds):
         kwds.setdefault('coordprec',2)
         super(CartesianAxes,self).__init__(P.CartesianProj, *args, **kwds)
         self._segment_threshold = 180
         self._segment_step_rad = 0.1*pi/180
         self._do_border = True
         
     def projmap(self,map,vec2pix_func,xsize=800,ysize=None,lonra=None,latra=None,**kwds):
         self.proj.set_proj_plane_info(xsize=xsize,ysize=ysize,lonra=lonra,latra=latra)
-        return super(CartesianAxes,self).projmap(map,vec2pix_func,**kwds)
+        super(CartesianAxes,self).projmap(map,vec2pix_func,**kwds)
         
 class HpxCartesianAxes(CartesianAxes):
     def projmap(self,map,nest=False,**kwds):
         nside = pixelfunc.npix2nside(pixelfunc.get_map_size(map))
         f = lambda x,y,z: pixelfunc.vec2pix(nside,x,y,z,nest=nest)
-        return super(HpxCartesianAxes,self).projmap(map,f,**kwds)
+        super(HpxCartesianAxes,self).projmap(map,f,**kwds)
 
         
-class OrthographicAxes(SphericalProjAxes):
-    """Define an orthographic Axes to handle orthographic projection.
-    
-    Input:
-    - rot=, coord= : define rotation and coordinate system. See rotator.
-    - coordprec= : num of digits after floating point for coordinates display.
-    - format= : format string for value display.
-    
-    Other keywords from Axes (see Axes).
-    """
-    def __init__(self,*args,**kwds):
-        kwds.setdefault('coordprec',2)
-        super(OrthographicAxes,self).__init__(P.OrthographicProj, *args,**kwds)
-        self._segment_threshold = 0.01
-        self._do_border = False
-        
-    def projmap(self,map,vec2pix_func,xsize=800,half_sky=False,**kwds):
-        self.proj.set_proj_plane_info(xsize=xsize,half_sky=half_sky)
-        img = super(OrthographicAxes,self).projmap(map,vec2pix_func,**kwds)
-        if half_sky: ratio = 1.01
-        else: ratio = 2.01
-        self.set_xlim(-ratio,ratio)
-        self.set_ylim(-1.01,1.01)
-        return img
-        
-class HpxOrthographicAxes(OrthographicAxes):
-    def projmap(self,map,nest=False,**kwds):
-        nside = pixelfunc.npix2nside(len(map))
-        f = lambda x,y,z: pixelfunc.vec2pix(nside,x,y,z,nest=nest)
-        return super(HpxOrthographicAxes,self).projmap(map,f,**kwds)
-
 
 ###################################################################
 #
 #   Table color for mollview and gnomview, ...
 
 def get_color_table(vmin,vmax,val,cmap=None,norm=None):
-    # Create color table
+    # Create color table for gnomonic view
+    if cmap is None:
+        cmap = cm.jet
     newjet = create_colormap(cmap)
     if type(norm) is str:
         if norm.lower().startswith('log'):
             norm = LogNorm2(clip=False)
         elif norm.lower().startswith('hist'):
             norm = HistEqNorm(clip=False)
         else:
@@ -725,29 +688,29 @@
     norm.vmin = vmin
     norm.vmax = vmax
     norm.autoscale_None(val)
     
     return newjet,norm
 
 def create_colormap(cmap):
-    if cmap is not None:
-        return cmap 
-    cmap0 = matplotlib.cm.jet
-    newcm = matplotlib.colors.LinearSegmentedColormap('newcm',cmap0._segmentdata,
-                                               cmap0.N)
+    if isinstance(cmap,colors.LinearSegmentedColormap):
+        newcm = colors.LinearSegmentedColormap('newcm',cmap._segmentdata,
+                                               cmap.N)
+    else:
+        newcm = cmap
     newcm.set_over(newcm(1.0))
     newcm.set_under('w')
     newcm.set_bad('gray')
     return newcm
 
 ##################################################################
 #
 #   A Locator that gives the bounds of the interval
 #
-class BoundaryLocator(matplotlib.ticker.Locator):
+class BoundaryLocator(ticker.Locator):
     def __init__(self,N=2):
         if N < 2:
             raise ValueError("Number of locs must be greater than 1")
         self.Nlocs=N
 
     def __call__(self):
         if matplotlib.__version__ < '0.98':
@@ -770,25 +733,25 @@
 
 ##################################################################
 #
 #   A normalization class to get color table equalised by
 #   the histogram of data
 #
 
-class HistEqNorm(matplotlib.colors.Normalize):
+class HistEqNorm(colors.Normalize):
     def __init__(self, vmin=None, vmax=None, clip=False):
-        matplotlib.colors.Normalize.__init__(self,vmin,vmax,clip)
+        colors.Normalize.__init__(self,vmin,vmax,clip)
         self.xval = None
         self.yval = None
 
     def __call__(self, value, clip=None):
         if clip is None:
             clip = self.clip
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             vtype = 'array'
             val = np.ma.asarray(value).astype(np.float)
         else:
             vtype = 'scalar'
             val = np.ma.array([value]).astype(np.float)
 
         self.autoscale_None(val)
@@ -810,15 +773,15 @@
             result = result[0]
         return result
 
     def inverse(self, value):
         if not self.scaled():
             raise ValueError("Not invertible until scaled")
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             vtype='array'
             val = np.ma.array(value)
         else:
             vtype='scalar'
             val = np.ma.array([value])
         result = np.ma.array(self._lininterp(val, self.yval, self.xval),
                               mask=np.ma.getmask(val))
@@ -845,32 +808,33 @@
 
     def _set_xyvals(self,val):
         data = np.ma.asarray(val).ravel()
         w=np.isinf(data.data)
         if data.mask is not np.ma.nomask:
             w = w|data.mask
         data2 = data.data[~w]
-        bins = min(data2.size//20, 5000)
+        bins = long(min(data2.size/20, 5000))
         if bins < 3: bins=data2.size
         try:
             # for numpy 1.1, use new bins format (left and right edges)
             hist, bins = np.histogram(data2,bins=bins,
                                        range=(self.vmin,self.vmax),
                                        new=True)
         except TypeError:
             # for numpy <= 1.0 or numpy >= 1.2, no new keyword
             hist, bins = np.histogram(data2,bins=bins,
                                        range=(self.vmin,self.vmax))
         if bins.size == hist.size+1:
             # new bins format, remove last point
             bins = bins[:-1]
         hist = hist.astype(np.float)/np.float(hist.sum())
-        self.yval = np.concatenate([[0.], hist.cumsum(), [1.]])
-        self.xval = np.concatenate([[self.vmin], bins + 0.5*(bins[1]-bins[0]),
-                                    [self.vmax]])
+        self.yval = np.concatenate([0., hist.cumsum(), 1.], None)
+        self.xval = np.concatenate([self.vmin,
+                                     bins + 0.5*(bins[1]-bins[0]),
+                                     self.vmax], None)
 
     def _lininterp(self,x,X,Y):
         if hasattr(x,'__len__'):
             xtype = 'array'
             xx=np.asarray(x).astype(np.float)
         else:
             xtype = 'scalar'
@@ -896,23 +860,23 @@
 
 
 ##################################################################
 #
 #   A normalization class to get logarithmic color table
 #
 
-class LogNorm2(matplotlib.colors.Normalize):
+class LogNorm2(colors.Normalize):
     """
     Normalize a given value to the 0-1 range on a log scale
     """
     def __call__(self, value, clip=None):
         if clip is None:
             clip = self.clip
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             vtype = 'array'
             val = np.ma.asarray(value).astype(np.float)
         else:
             vtype = 'scalar'
             val = np.ma.array([value]).astype(np.float)
 
         val = np.ma.masked_where(np.isinf(val.data),val)
@@ -940,44 +904,44 @@
             result = result[0]
         return result
 
     def autoscale_None(self, A):
         ' autoscale only None-valued vmin or vmax'
         if self.vmin is None or self.vmax is None:
             val = np.ma.masked_where(np.isinf(A.data),A)
-            matplotlib.colors.Normalize.autoscale_None(self,val)
+            colors.Normalize.autoscale_None(self,val)
 
     def inverse(self, value):
         if not self.scaled():
             raise ValueError("Not invertible until scaled")
         vmin, vmax = float(self.vmin), float(self.vmax)
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             val = np.ma.asarray(value)
             return vmin * np.ma.power((vmax/vmin), val)
         else:
             return vmin * np.pow((vmax/vmin), value)
 
 
 
         
 ##################################################################
 #
 #   A normalization class to get linear color table
 #
 
-class LinNorm2(matplotlib.colors.Normalize):
+class LinNorm2(colors.Normalize):
     """
     Normalize a given value to the 0-1 range on a lin scale
     """
     def __call__(self, value, clip=None):
         if clip is None:
             clip = self.clip
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             vtype = 'array'
             val = np.ma.asarray(value).astype(np.float)
         else:
             vtype = 'scalar'
             val = np.ma.array([value]).astype(np.float)
 
         winf = np.isinf(val.data)
@@ -1004,19 +968,21 @@
             result = result[0]
         return result
 
     def autoscale_None(self, A):
         ' autoscale only None-valued vmin or vmax'
         if self.vmin is None or self.vmax is None:
             val = np.ma.masked_where(np.isinf(A.data),A)
-            matplotlib.colors.Normalize.autoscale_None(self,val)
+            colors.Normalize.autoscale_None(self,val)
 
     def inverse(self, value):
         if not self.scaled():
             raise ValueError("Not invertible until scaled")
         vmin, vmax = float(self.vmin), float(self.vmax)
 
-        if matplotlib.cbook.iterable(value):
+        if cbook.iterable(value):
             val = np.ma.asarray(value)
             return vmin + (vmax-vmin) * val
         else:
             return vmin + (vmax-vmin) * value
+
+
```

### Comparing `healpy-1.9.1/healpy/pixelfunc.py` & `healpy-github-devel/healpy/pixelfunc.py`

 * *Files 15% similar despite different names*

```diff
@@ -29,18 +29,16 @@
 
 - :func:`pix2ang` converts pixel number to angular coordinates
 - :func:`pix2vec` converts pixel number to unit 3-vector direction
 - :func:`ang2pix` converts angular coordinates to pixel number
 - :func:`vec2pix` converts 3-vector to pixel number 
 - :func:`vec2ang` converts 3-vector to angular coordinates
 - :func:`ang2vec` converts angular coordinates to unit 3-vector
-- :func:`pix2xyf` converts pixel number to coordinates within face
-- :func:`xyf2pix` converts coordinates within face to pixel number
-- :func:`get_interp_weights` returns the 4 nearest pixels for given
-  angular coordinates and the relative weights for interpolation
+- :func:`get_neighbours` returns the 4 nearest pixels for given
+  angular coordinates
 - :func:`get_all_neighbours` return the 8 nearest pixels for given
   angular coordinates
 
 conversion between NESTED and RING schemes
 ------------------------------------------
 
 - :func:`nest2ring` converts NESTED scheme pixel numbers to RING
@@ -50,16 +48,14 @@
 - :func:`reorder` reorders a healpix map pixels from one scheme to another
 
 nside/npix/resolution
 ---------------------
 
 - :func:`nside2npix` converts healpix nside parameter to number of pixel
 - :func:`npix2nside` converts number of pixel to healpix nside parameter
-- :func:`nside2order` converts nside to order
-- :func:`order2nside` converts order to nside
 - :func:`nside2resol` converts nside to mean angular resolution
 - :func:`nside2pixarea` converts nside to pixel area
 - :func:`isnsideok` checks the validity of nside
 - :func:`isnpixok` checks the validity of npix
 - :func:`get_map_size` gives the number of pixel of a map
 - :func:`get_min_valid_nside` gives the minimum nside possible for a given
   number of pixel
@@ -82,158 +78,32 @@
 - :func:`fit_monopole` fits a monopole on the map
 - :func:`remove_dipole` fits and removes a monopole+dipole from the map
 - :func:`remove_monopole` fits and remove a monopole from the map
 - :func:`get_interp_val` computes a bilinear interpolation of the map
   at given angular coordinates, using 4 nearest neighbours
 """
 
-try:
-    from exceptions import NameError
-except:
-    pass
-
 import numpy as np
-from functools import wraps
+import exceptions
+import warnings
+import _healpy_pixel_lib as pixlib
 
-UNSEEN = None
-
-try:
-    from . import _healpy_pixel_lib as pixlib
-    #: Special value used for masked pixels
-    UNSEEN = pixlib.UNSEEN
-except:
-    import warnings
-    warnings.warn('Warning: cannot import _healpy_pixel_lib module')
-
-# We are using 64-bit integer types.
-# nside > 2**29 requires extended integer types.
-max_nside = 1 << 29
+#: Special value used for masked pixels
+UNSEEN = pixlib.UNSEEN
 
 __all__ = ['pix2ang', 'pix2vec', 'ang2pix', 'vec2pix',
            'ang2vec', 'vec2ang',
-           'get_interp_weights', 'get_neighbours', 'get_interp_val', 'get_all_neighbours',
-           'max_pixrad',
+           'get_neighbours', 'get_interp_val', 'get_all_neighbours',
            'nest2ring', 'ring2nest', 'reorder', 'ud_grade',
            'UNSEEN', 'mask_good', 'mask_bad', 'ma',
            'fit_dipole', 'remove_dipole', 'fit_monopole', 'remove_monopole',
-           'nside2npix', 'npix2nside', 'nside2order', 'order2nside',
-           'nside2resol', 'nside2pixarea',
-           'isnsideok', 'isnpixok',
+           'nside2npix', 'npix2nside', 'nside2resol',
+           'nside2pixarea', 'isnsideok', 'isnpixok',
            'get_map_size', 'get_min_valid_nside',
-           'get_nside', 'maptype', 'ma_to_array']
-
-def check_theta_valid(theta):
-    """Raises exception if theta is not within 0 and pi"""
-    theta = np.asarray(theta)
-    if not((theta >= 0).all() and (theta <= np.pi + 1e-5).all()):
-        raise ValueError('THETA is out of range [0,pi]')
-
-def maptype(m):
-    """Describe the type of the map (valid, single, sequence of maps).
-    Checks : the number of maps, that all maps have same length and that this
-    length is a valid map size (using :func:`isnpixok`).
-
-    Parameters
-    ----------
-    m : sequence
-      the map to get info from
-
-    Returns
-    -------
-    info : int
-      -1 if the given object is not a valid map, 0 if it is a single map,
-      *info* > 0 if it is a sequence of maps (*info* is then the number of
-      maps)
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> hp.pixelfunc.maptype(np.arange(12))
-    0
-    >>> hp.pixelfunc.maptype([np.arange(12), np.arange(12)])
-    2
-    """
-    if not hasattr(m, '__len__'):
-        raise TypeError('input map is a scalar')
-    if len(m) == 0:
-        raise TypeError('input map has length zero')
-    if hasattr(m[0], '__len__'):
-        npix=len(m[0])
-        for mm in m[1:]:
-            if len(mm) != npix:
-                raise TypeError('input maps have different npix')
-        if isnpixok(len(m[0])):
-            return len(m)
-        else:
-            raise TypeError('bad number of pixels')
-    else:
-        if isnpixok(len(m)):
-            return 0
-        else:
-            raise TypeError('bad number of pixels')
-
-def ma_to_array(m):
-    """Converts a masked array or a list of masked arrays to filled numpy arrays
-
-    Parameters
-    ----------
-    m : a map (may be a sequence of maps)
-
-    Returns
-    -------
-    m : filled map or tuple of filled maps
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> m = hp.ma(np.array([2., 2., 3, 4, 5, 0, 0, 0, 0, 0, 0, 0]))
-    >>> m.mask = np.array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.bool)
-    >>> print(m.data[1]) # data is not affected by mask
-    2.0
-    >>> print(m[1]) # shows that the value is masked
-    --
-    >>> print(ma_to_array(m)[1]) # filled array, masked values replace by UNSEEN
-    -1.6375e+30
-    """
-
-    try:
-        return m.filled()
-    except AttributeError:
-        try:
-            return tuple([mm.filled() for mm in m])
-        except AttributeError:
-            pass
-    return m
-
-def is_ma(m):
-    """Converts a masked array or a list of masked arrays to filled numpy arrays
-
-    Parameters
-    ----------
-    m : a map (may be a sequence of maps)
-
-    Returns
-    -------
-    is_ma : bool
-        whether the input map was a ma or not
-    """
-    return hasattr(m, 'filled') or hasattr(m[0], 'filled')
-
-def accept_ma(f):
-    """Wraps a function in order to convert the input map from
-    a masked to a regular numpy array, and convert back the
-    output from a regular array to a masked array"""
-    @wraps(f)
-    def wrapper(map_in, *args, **kwds):
-        return_ma = is_ma(map_in)
-        m = ma_to_array(map_in)
-        out = f(m, *args, **kwds)
-        return ma(out) if return_ma else out
-
-    return wrapper
+           'get_nside', 'maptype']
 
 def mask_bad(m, badval = UNSEEN, rtol = 1.e-5, atol = 1.e-8):
     """Returns a bool array with ``True`` where m is close to badval.
 
     Parameters
     ----------
     m : a map (may be a sequence of maps)
@@ -253,22 +123,20 @@
     See Also
     --------
     mask_good, ma
 
     Examples
     --------
     >>> import healpy as hp
-    >>> import numpy as np
     >>> m = np.arange(12.)
     >>> m[3] = hp.UNSEEN
     >>> hp.mask_bad(m)
     array([False, False, False,  True, False, False, False, False, False,
            False, False, False], dtype=bool)
     """
-    m = np.asarray(m)
     atol = np.absolute(atol)
     rtol = np.absolute(rtol)
     return np.absolute(m - badval) <= atol + rtol * np.absolute(badval)
 
 def mask_good(m, badval = UNSEEN, rtol = 1.e-5, atol = 1.e-8):
     """Returns a bool array with ``False`` where m is close to badval.
 
@@ -296,15 +164,14 @@
     >>> import healpy as hp
     >>> m = np.arange(12.)
     >>> m[3] = hp.UNSEEN
     >>> hp.mask_good(m)
     array([ True,  True,  True, False,  True,  True,  True,  True,  True,
             True,  True,  True], dtype=bool)
     """
-    m = np.asarray(m)
     atol = np.absolute(atol)
     rtol = np.absolute(rtol)
     return np.absolute(m - badval) > atol + rtol * np.absolute(badval)
 
 def ma(m, badval = UNSEEN, rtol = 1e-5, atol = 1e-8, copy = True):
     """Return map as a masked array, with ``badval`` pixels masked.
 
@@ -318,16 +185,16 @@
     atol : float, optional
         The absolute tolerance
     copy : bool, optional
         If ``True``, a copy of the input map is made.
 
     Returns
     -------
-    a masked array with the same shape as the input map, 
-    masked where input map is close to badval.
+    a masked array with the same shape as the input map, masked where input map is
+    close to badval.
 
     See Also
     --------
     mask_good, mask_bad, numpy.ma.masked_values
 
     Examples
     --------
@@ -336,26 +203,23 @@
     >>> m[3] = hp.UNSEEN
     >>> hp.ma(m)
     masked_array(data = [0.0 1.0 2.0 -- 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0],
                  mask = [False False False  True False False False False False False False False],
            fill_value = -1.6375e+30)
     <BLANKLINE>
     """
-    if maptype(m) == 0:
-        return np.ma.masked_values(m, badval, rtol = rtol, atol = atol, copy = copy)
-    else:
-        return tuple([ma(mm) for mm in m])
+    return np.ma.masked_values(m, badval, rtol = rtol, atol = atol, copy = copy)
 
 def ang2pix(nside,theta,phi,nest=False):
     """ang2pix : nside,theta[rad],phi[rad],nest=False -> ipix (default:RING)
 
     Parameters
     ----------
     nside : int, scalar or array-like
-      The healpix nside parameter, must be a power of 2, less than 2**30
+      The healpix nside parameter, must be a power of 2
     theta, phi : float, scalars or array-like
       Angular coordinates of a point on the sphere
     nest : bool, optional
       if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
 
     Returns
     -------
@@ -378,30 +242,28 @@
 
     >>> hp.ang2pix(16, np.pi/2, [0, np.pi/2])
     array([1440, 1520])
 
     >>> hp.ang2pix([1, 2, 4, 8, 16], np.pi/2, 0)
     array([   4,   12,   72,  336, 1440])
     """
-    check_theta_valid(theta)
-    check_nside(nside)
     if nest:
         return pixlib._ang2pix_nest(nside,theta,phi)
     else:
         return pixlib._ang2pix_ring(nside,theta,phi)
 
 def pix2ang(nside,ipix,nest=False):
     """pix2ang : nside,ipix,nest=False -> theta[rad],phi[rad] (default RING)
 
     Parameters
     ----------
     nside : int or array-like
-      The healpix nside parameter, must be a power of 2, less than 2**30
+      The healpix nside parameter, must be a power of 2
     ipix : int or array-like
-      Pixel indices
+      Angular coordinates of a point on the sphere
     nest : bool, optional
       if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
 
     Returns
     -------
     theta, phi : float, scalar or array-like
       The angular coordinates corresponding to ipix. Scalar if all input
@@ -419,107 +281,26 @@
 
     >>> hp.pix2ang(16, [1440,  427, 1520,    0, 3068])
     (array([ 1.52911759,  0.78550497,  1.57079633,  0.05103658,  3.09055608]), array([ 0.        ,  0.78539816,  1.61988371,  0.78539816,  0.78539816]))
 
     >>> hp.pix2ang([1, 2, 4, 8], 11)
     (array([ 2.30052398,  0.84106867,  0.41113786,  0.2044802 ]), array([ 5.49778714,  5.89048623,  5.89048623,  5.89048623]))
     """
-    check_nside(nside)
     if nest:
         return pixlib._pix2ang_nest(nside, ipix)
     else:
         return pixlib._pix2ang_ring(nside,ipix)
 
-def xyf2pix(nside,x,y,face,nest=False):
-    """xyf2pix : nside,x,y,face,nest=False -> ipix (default:RING)
-
-    Parameters
-    ----------
-    nside : int, scalar or array-like
-      The healpix nside parameter, must be a power of 2
-    x, y : int, scalars or array-like
-      Pixel indices within face
-    face : int, scalars or array-like
-      Face number
-    nest : bool, optional
-      if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
-
-    Returns
-    -------
-    pix : int or array of int
-      The healpix pixel numbers. Scalar if all input are scalar, array otherwise.
-      Usual numpy broadcasting rules apply.
-
-    See Also
-    --------
-    pix2xyf
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> hp.xyf2pix(16, 8, 8, 4)
-    1440
-
-    >>> hp.xyf2pix(16, [8, 8, 8, 15, 0], [8, 8, 7, 15, 0], [4, 0, 5, 0, 8])
-    array([1440,  427, 1520,    0, 3068])
-    """
-    check_nside(nside)
-    if nest:
-        return pixlib._xyf2pix_nest(nside,x,y,face)
-    else:
-        return pixlib._xyf2pix_ring(nside,x,y,face)
-
-def pix2xyf(nside,ipix,nest=False):
-    """pix2xyf : nside,ipix,nest=False -> x,y,face (default RING)
-
-    Parameters
-    ----------
-    nside : int or array-like
-      The healpix nside parameter, must be a power of 2
-    ipix : int or array-like
-      Pixel indices
-    nest : bool, optional
-      if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
-
-    Returns
-    -------
-    x, y : int, scalars or array-like
-      Pixel indices within face
-    face : int, scalars or array-like
-      Face number
-
-    See Also
-    --------
-    xyf2pix
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> hp.pix2xyf(16, 1440)
-    (8, 8, 4)
-
-    >>> hp.pix2xyf(16, [1440,  427, 1520,    0, 3068])
-    (array([ 8,  8,  8, 15,  0]), array([ 8,  8,  7, 15,  0]), array([4, 0, 5, 0, 8]))
-
-    >>> hp.pix2xyf([1, 2, 4, 8], 11)
-    (array([0, 1, 3, 7]), array([0, 0, 2, 6]), array([11,  3,  3,  3]))
-    """
-    check_nside(nside)
-    if nest:
-        return pixlib._pix2xyf_nest(nside, ipix)
-    else:
-        return pixlib._pix2xyf_ring(nside,ipix)
-
 def vec2pix(nside,x,y,z,nest=False):
     """vec2pix : nside,x,y,z,nest=False -> ipix (default:RING)
 
     Parameters
     ----------
     nside : int or array-like
-      The healpix nside parameter, must be a power of 2, less than 2**30
+      The healpix nside parameter, must be a power of 2
     x,y,z : floats or array-like
       vector coordinates defining point on the sphere
     nest : bool, optional
       if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
 
     Returns
     -------
@@ -550,15 +331,15 @@
 
 def pix2vec(nside,ipix,nest=False):
     """pix2vec : nside,ipix,nest=False -> x,y,z (default RING)
 
     Parameters
     ----------
     nside : int, scalar or array-like
-      The healpix nside parameter, must be a power of 2, less than 2**30
+      The healpix nside parameter, must be a power of 2
     ipix : int, scalar or array-like
       Healpix pixel number
     nest : bool, optional
       if True, assume NESTED pixel ordering, otherwise, RING pixel ordering
 
     Returns
     -------
@@ -578,15 +359,14 @@
 
     >>> hp.pix2vec(16, [1440,  427])
     (array([ 0.99913157,  0.5000534 ]), array([ 0.       ,  0.5000534]), array([ 0.04166667,  0.70703125]))
 
     >>> hp.pix2vec([1, 2], 11)
     (array([ 0.52704628,  0.68861915]), array([-0.52704628, -0.28523539]), array([-0.66666667,  0.66666667]))
     """
-    check_nside(nside)
     if nest:
         return pixlib._pix2vec_nest(nside,ipix)
     else:
         return pixlib._pix2vec_ring(nside,ipix)
 
 def ang2vec(theta, phi):
     """ang2vec : convert angles to 3D position vector
@@ -604,15 +384,16 @@
       if theta and phi are vectors, the result is a 2D array with a vector per row
       otherwise, it is a 1D array of shape (3,)
 
     See Also
     --------
     vec2ang, rotator.dir2vec, rotator.vec2dir
     """
-    check_theta_valid(theta)
+    if np.any(theta < 0) or np.any(theta > np.pi):
+        raise exceptions.ValueError('THETA is out of range [0,pi]')
     sintheta = np.sin(theta)
     return np.array([sintheta*np.cos(phi),
                       sintheta*np.sin(phi),
                       np.cos(theta)]).T
 
 def vec2ang(vectors):
     """vec2ang: vectors [x, y, z] -> theta[rad], phi[rad]
@@ -659,21 +440,20 @@
     
     Examples
     --------
     >>> import healpy as hp
     >>> hp.ring2nest(16, 1504)
     1130
 
-    >>> hp.ring2nest(2, np.arange(10))
+    >>> hp.ring2nest(2, range(10))
     array([ 3,  7, 11, 15,  2,  1,  6,  5, 10,  9])
     
     >>> hp.ring2nest([1, 2, 4, 8], 11)
     array([ 11,  13,  61, 253])
     """
-    check_nside(nside)
     return pixlib._ring2nest(nside, ipix)
 
 def nest2ring(nside, ipix):
     """Convert pixel number from NESTED ordering to RING ordering.
 
     Parameters
     ----------
@@ -693,43 +473,40 @@
     
     Examples
     --------
     >>> import healpy as hp
     >>> hp.nest2ring(16, 1130)
     1504
 
-    >>> hp.nest2ring(2, np.arange(10))
+    >>> hp.nest2ring(2, range(10))
     array([13,  5,  4,  0, 15,  7,  6,  1, 17,  9])
     
     >>> hp.nest2ring([1, 2, 4, 8], 11)
     array([ 11,   2,  12, 211])
     """
-    check_nside(nside)
     return pixlib._nest2ring(nside, ipix)
 
-@accept_ma
 def reorder(map_in, inp=None, out=None, r2n=None, n2r=None):
     """Reorder an healpix map from RING/NESTED ordering to NESTED/RING
 
     Parameters
     ----------
     map_in : array-like
-      the input map to reorder, accepts masked arrays
+      the input map to reorder
     inp, out : ``'RING'`` or ``'NESTED'``
       define the input and output ordering
     r2n : bool
       if True, reorder from RING to NESTED
     n2r : bool
       if True, reorder from NESTED to RING
 
     Returns
     -------
     map_out : array-like
-      the reordered map, as masked array if the input was a 
-      masked array
+      the reordered map
 
     Notes
     -----
     if ``r2n`` or ``n2r`` is defined, override ``inp`` and ``out``.
 
     See Also
     --------
@@ -738,46 +515,27 @@
     Examples
     --------
     >>> import healpy as hp
     >>> hp.reorder(np.arange(48), r2n = True)
     array([13,  5,  4,  0, 15,  7,  6,  1, 17,  9,  8,  2, 19, 11, 10,  3, 28,
            20, 27, 12, 30, 22, 21, 14, 32, 24, 23, 16, 34, 26, 25, 18, 44, 37,
            36, 29, 45, 39, 38, 31, 46, 41, 40, 33, 47, 43, 42, 35])
-    >>> hp.reorder(np.arange(12), n2r = True)
+    >>> hp.reorder(range(12), n2r = True)
     array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
-    >>> hp.reorder(hp.ma(np.arange(12.)), n2r = True)
-    masked_array(data = [  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.  11.],
-                 mask = False,
-           fill_value = -1.6375e+30)
-    <BLANKLINE>
-    >>> m = [np.arange(12.), np.arange(12.), np.arange(12.)]
-    >>> m[0][2] = hp.UNSEEN
-    >>> m[1][2] = hp.UNSEEN
-    >>> m[2][2] = hp.UNSEEN
-    >>> m = hp.ma(m)
-    >>> hp.reorder(m, n2r = True)
-    (masked_array(data = [0.0 1.0 -- 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0],
-                 mask = [False False  True False False False False False False False False False],
-           fill_value = -1.6375e+30)
-    , masked_array(data = [0.0 1.0 -- 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0],
-                 mask = [False False  True False False False False False False False False False],
-           fill_value = -1.6375e+30)
-    , masked_array(data = [0.0 1.0 -- 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0],
-                 mask = [False False  True False False False False False False False False False],
-           fill_value = -1.6375e+30)
-    )
     """
     typ = maptype(map_in)
+    if typ < 0:
+        raise TypeError('map_in is not a map nor a sequence of maps')
     if typ == 0:
         npix = len(map_in)
     else:
         npix = len(map_in[0])
     nside = npix2nside(npix)
     if nside>128:
-        bunchsize = npix//24
+        bunchsize = npix/24
     else:
         bunchsize = npix
     if r2n:
         inp='RING'
         out='NEST'
     if n2r:
         inp='NEST'
@@ -792,115 +550,80 @@
         mapin = map_in
     mapout = []
     for m_in in mapin:
         if inp == out:
             mapout.append(m_in)
         elif inp == 'RING':
             m_out = np.zeros(npix,dtype=type(m_in[0]))
-            for ibunch in range(npix//bunchsize):
+            for ibunch in range(npix/bunchsize):
                 ipix_n = np.arange(ibunch*bunchsize,
                                     (ibunch+1)*bunchsize)
                 ipix_r = nest2ring(nside, ipix_n)
                 m_out[ipix_n] = np.asarray(m_in)[ipix_r]
             mapout.append(m_out)
         elif inp == 'NEST':
             m_out = np.zeros(npix,dtype=type(m_in[0]))
-            for ibunch in range(npix//bunchsize):
+            for ibunch in range(npix/bunchsize):
                 ipix_r = np.arange(ibunch*bunchsize,
                                     (ibunch+1)*bunchsize)
                 ipix_n = ring2nest(nside, ipix_r)
                 m_out[ipix_r] = np.asarray(m_in)[ipix_n]
             mapout.append(m_out)
     if typ == 0:
         return mapout[0]
     else:
         return mapout
 
 def nside2npix(nside):
-    """Give the number of pixels for the given nside.
+    """Give the number of pixel for the given nside.
 
     Parameters
     ----------
     nside : int
       healpix nside parameter; an exception is raised if nside is not valid
-      (nside must be a power of 2, less than 2**30)
+      (nside must be a power of 2)
 
     Returns
     -------
     npix : int
       corresponding number of pixels
     
     Notes
     -----
     Raise a ValueError exception if nside is not valid.
 
     Examples
     --------
     >>> import healpy as hp
-    >>> import numpy as np
     >>> hp.nside2npix(8)
     768
 
     >>> np.all([hp.nside2npix(nside) == 12 * nside**2 for nside in [2**n for n in range(12)]])
     True
 
     >>> hp.nside2npix(7)
     Traceback (most recent call last):
-        ...
-    ValueError: 7 is not a valid nside parameter (must be a power of 2, less than 2**30)
+       ...
+    ValueError: Given number is not a valid nside parameter (must be a power of 2)
     """
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError("Given number is not a valid nside parameter "
+                         "(must be a power of 2)")
     return 12*nside**2
 
-def nside2order(nside):
-    """Give the resolution order for a given nside.
-
-    Parameters
-    ----------
-    nside : int
-      healpix nside parameter; an exception is raised if nside is not valid
-      (nside must be a power of 2, less than 2**30)
-
-    Returns
-    -------
-    order : int
-      corresponding order where nside = 2**(order)
-
-    Notes
-    -----
-    Raise a ValueError exception if nside is not valid.
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> import numpy as np
-    >>> hp.nside2order(128)
-    7
-
-    >>> np.all([hp.nside2order(2**o) == o for o in range(30)])
-    True
-
-    >>> hp.nside2order(7)
-    Traceback (most recent call last):
-        ...
-    ValueError: 7 is not a valid nside parameter (must be a power of 2, less than 2**30)
-    """
-    check_nside(nside)
-    return len('{0:b}'.format(nside)) - 1
-
 def nside2resol(nside, arcmin=False):
-    """Give approximate resolution (pixel size in radian or arcmin) for nside.
+    """Give approximate resolution for nside.
 
     Resolution is just the square root of the pixel area, which is a gross
     approximation given the different pixel shapes
 
     Parameters
     ----------
     nside : int
-      healpix nside parameter, must be a power of 2, less than 2**30
+      healpix nside parameter, must be a power of 2
     arcmin : bool
       if True, return resolution in arcmin, otherwise in radian
 
     Returns
     -------
     resol : float
       approximate pixel size in radians or arcmin
@@ -917,40 +640,42 @@
 
     >>> hp.nside2resol(256)
     0.0039973699529159707
 
     >>> hp.nside2resol(7)
     Traceback (most recent call last):
        ...
-    ValueError: 7 is not a valid nside parameter (must be a power of 2, less than 2**30)
+    ValueError: Given number is not a valid nside parameter (must be a power of 2)
     """
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError("Given number is not a valid nside parameter "
+                         "(must be a power of 2)")
     
     resol = np.sqrt(nside2pixarea(nside))
 
     if arcmin:
         resol = np.rad2deg(resol) * 60
         
     return resol
 
 
 def nside2pixarea(nside, degrees=False):
-    """Give pixel area given nside in square radians or square degrees.
+    """Give pixel area given nside.
 
     Parameters
     ----------
     nside : int
-      healpix nside parameter, must be a power of 2, less than 2**30
+      healpix nside parameter, must be a power of 2
     degrees : bool
       if True, returns pixel area in square degrees, in square radians otherwise
 
     Returns
     -------
     pixarea : float
-      pixel area in square radian or square degree
+      pixel area in suqare radian or square degree
 
     Notes
     -----
     Raise a ValueError exception if nside is not valid.
 
     Examples
     --------
@@ -960,17 +685,19 @@
 
     >>> hp.nside2pixarea(256)
     1.5978966540475428e-05
 
     >>> hp.nside2pixarea(7)
     Traceback (most recent call last):
        ...
-    ValueError: 7 is not a valid nside parameter (must be a power of 2, less than 2**30)
+    ValueError: Given number is not a valid nside parameter (must be a power of 2)
     """
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError("Given number is not a valid nside parameter "
+                         "(must be a power of 2)")
     
     pixarea = 4*np.pi/nside2npix(nside)
 
     if degrees:
         pixarea = np.rad2deg(np.rad2deg(pixarea))
         
     return pixarea
@@ -1007,50 +734,16 @@
         ...
     ValueError: Wrong pixel number (it is not 12*nside**2)
     """
     nside = np.sqrt(npix/12.)
     if nside != np.floor(nside):
         raise ValueError("Wrong pixel number (it is not 12*nside**2)")
     nside=int(np.floor(nside))
-    check_nside(nside)
-    return nside
-
-def order2nside(order):
-    """Give the nside parameter for the given resolution order.
-
-    Parameters
-    ----------
-    order : int
-      the resolution order
-
-    Returns
-    -------
-    nside : int
-      the nside parameter corresponding to order
-
-    Notes
-    -----
-    Raise a ValueError exception if order produces an nside out of range.
-
-    Examples
-    --------
-    >>> import healpy as hp
-    >>> hp.order2nside(7)
-    128
-
-    >>> hp.order2nside(np.arange(8))
-    array([  1,   2,   4,   8,  16,  32,  64, 128])
-
-    >>> hp.order2nside(31)
-    Traceback (most recent call last):
-        ...
-    ValueError: 2147483648 is not a valid nside parameter (must be a power of 2, less than 2**30)
-    """
-    nside = 1<<order
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError("Wrong nside value (it is not 2**N)")
     return nside
 
 def isnsideok(nside):
     """Returns :const:`True` if nside is a valid nside parameter, :const:`False` otherwise.
 
     Parameters
     ----------
@@ -1070,29 +763,20 @@
     
     >>> hp.isnsideok(32)
     True
 
     >>> hp.isnsideok([1, 2, 3, 4, 8, 16])
     array([ True,  True, False,  True,  True,  True], dtype=bool)
     """
-    # we use standard bithacks from http://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2
     if hasattr(nside, '__len__'):
-        if not isinstance(nside, np.ndarray):
-            nside = np.asarray(nside)
-        return ((nside == nside.astype(np.int)) & (0 < nside) &
-                (nside <= max_nside) &
-                ((nside.astype(np.int) & (nside.astype(np.int) - 1)) == 0))
-    else:
-        return (nside == int(nside) and 0 < nside <= max_nside and
-               (int(nside) & (int(nside) - 1)) == 0)
-
-def check_nside(nside):
-    """Raises exception is nside is not valid"""
-    if not np.all(isnsideok(nside)):
-        raise ValueError("%s is not a valid nside parameter (must be a power of 2, less than 2**30)" % str(nside))
+        return nside == 2**np.int32(np.around(np.ma.log2(nside).filled(0)))
+    elif nside <= 0:
+        return False
+    else:
+        return nside == 2**int(round(np.log2(nside)))
 
 def isnpixok(npix):
     """Return :const:`True` if npix is a valid value for healpix map size, :const:`False` otherwise.
 
     Parameters
     ----------
     npix : int, scalar or array-like
@@ -1124,38 +808,34 @@
 
 def get_interp_val(m,theta,phi,nest=False):
     """Return the bi-linear interpolation value of a map using 4 nearest neighbours.
 
     Parameters
     ----------
     m : array-like
-      an healpix map, accepts masked arrays
+      an healpix map
     theta, phi : float, scalar or array-like
       angular coordinates of point at which to interpolate the map
     nest : bool
       if True, the is assumed to be in NESTED ordering.
 
     Returns
     -------
       val : float, scalar or arry-like
         the interpolated value(s), usual numpy broadcasting rules apply.
 
     See Also
     --------
-    get_interp_weights, get_all_neighbours
+    get_neighbours, get_all_neighbours
 
     Examples
     --------
     >>> import healpy as hp
     >>> hp.get_interp_val(np.arange(12.), np.pi/2, 0)
     4.0
-    >>> hp.get_interp_val(np.arange(12.), np.pi/2, np.pi/2)
-    5.0
-    >>> hp.get_interp_val(np.arange(12.), np.pi/2, np.pi/2 + 2*np.pi)
-    5.0
     >>> hp.get_interp_val(np.arange(12.), np.linspace(0, np.pi, 10), 0)
     array([ 1.5       ,  1.5       ,  1.5       ,  2.20618428,  3.40206143,
             5.31546486,  7.94639458,  9.5       ,  9.5       ,  9.5       ])
     """
     m2=m.ravel()
     nside=npix2nside(m2.size)
     if nest:
@@ -1163,21 +843,16 @@
     else:
         r=pixlib._get_interpol_ring(nside,theta,phi)
     p=np.array(r[0:4])
     w=np.array(r[4:8])
     del r
     return np.sum(m2[p]*w,0)
 
-def get_neighbours(nside, theta, phi=None, nest=False):
-    raise NameError("get_neighbours has been renamed to get_interp_weights")
-
-def get_interp_weights(nside,theta,phi=None,nest=False):
-    """Return the 4 closest pixels on the two rings above and below the
-    location and corresponding weights.
-    Weights are provided for bilinear interpolation along latitude and longitude
+def get_neighbours(nside,theta,phi=None,nest=False):
+    """Return the 4 nearest pixels and corresponding weights.
 
     Parameters
     ----------
     nside : int
       the healpix nside
     theta, phi : float, scalar or array-like
       if phi is not given, theta is interpreted as pixel number,
@@ -1194,30 +869,31 @@
     See Also
     --------
     get_interp_val, get_all_neighbours
 
     Examples
     --------
     >>> import healpy as hp
-    >>> hp.get_interp_weights(1, 0)
+    >>> hp.get_neighbours(1, 0)
     (array([0, 1, 4, 5]), array([ 1.,  0.,  0.,  0.]))
 
-    >>> hp.get_interp_weights(1, 0, 0)
+    >>> hp.get_neighbours(1, 0, 0)
     (array([1, 2, 3, 0]), array([ 0.25,  0.25,  0.25,  0.25]))
 
-    >>> hp.get_interp_weights(1, [0, np.pi/2], 0)
+    >>> hp.get_neighbours(1, [0, np.pi/2], 0)
     (array([[ 1,  4],
            [ 2,  5],
            [ 3, 11],
            [ 0,  8]]), array([[ 0.25,  1.  ],
            [ 0.25,  0.  ],
            [ 0.25,  0.  ],
            [ 0.25,  0.  ]]))
     """
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError('Wrong nside value. Must be a power of 2.')
     if phi == None:
         theta,phi = pix2ang(nside,theta,nest=nest)
     if nest:
         r=pixlib._get_interpol_nest(nside,theta,phi)
     else:
         r=pixlib._get_interpol_ring(nside,theta,phi)
     p=np.array(r[0:4])
@@ -1243,65 +919,43 @@
       pixel number of the SW, W, NW, N, NE, E, SE and S neighbours,
       shape is (8,) if input is scalar, otherwise shape is (8, N) if input is
       of length N. If a neighbor does not exist (it can be the case for W, N, E and S)
       the corresponding pixel number will be -1.
 
     See Also
     --------
-    get_interp_weights, get_interp_val
+    get_neighbours, get_interp_val
 
     Examples
     --------
     >>> import healpy as hp
     >>> hp.get_all_neighbours(1, 4)
     array([11,  7,  3, -1,  0,  5,  8, -1])
 
     >>> hp.get_all_neighbours(1, np.pi/2, np.pi/2)
     array([ 8,  4,  0, -1,  1,  6,  9, -1])
     """
-    check_nside(nside)
+    if not isnsideok(nside):
+        raise ValueError('Wrong nside value. Must be a power of 2.')
     if phi is not None:
         theta = ang2pix(nside,theta, phi,nest=nest)
     if nest:
         r=pixlib._get_neighbors_nest(nside,theta)
     else:
         r=pixlib._get_neighbors_ring(nside,theta)
     res=np.array(r[0:8])
     return res
 
-def max_pixrad(nside):
-    """Maximum angular distance between any pixel center and its corners
-
-    Parameters
-    ----------
-    nside : int
-      the nside to work with
-
-    Returns
-    -------
-    rads: double
-       angular distance (in radians)
-
-    Examples
-    --------
-    >>> '%.15f' % max_pixrad(1)
-    '0.841068670567930'
-    >>> '%.15f' % max_pixrad(16)
-    '0.066014761432513'
-    """
-    check_nside(nside)
-    return pixlib._max_pixrad(nside)
-
 def fit_dipole(m, nest=False, bad=UNSEEN, gal_cut=0):
     """Fit a dipole and a monopole to the map, excluding bad pixels.
 
     Parameters
     ----------
     m : float, array-like
-      the map to which a dipole is fitted and subtracted, accepts masked maps
+      the map to which a dipole is fitted and subtracted
     nest : bool
       if ``False`` m is assumed in RING scheme, otherwise map is NESTED
     bad : float
       bad values of pixel, default to :const:`UNSEEN`.
     gal_cut : float
       pixels at latitude in [-gal_cut;+gal_cut] degrees are not taken into account
 
@@ -1310,25 +964,24 @@
     res : tuple of length 2
       the monopole value in res[0] and the dipole vector (as array) in res[1]
 
     See Also
     --------
     remove_dipole, fit_monopole, remove_monopole
     """
-    m=ma_to_array(m)
     m=np.asarray(m)
     npix = m.size
     nside = npix2nside(npix)
     if nside>128:
-        bunchsize = npix//24
+        bunchsize = npix/24
     else:
         bunchsize = npix
     aa = np.zeros((4,4),dtype=np.float64)
     v = np.zeros(4,dtype=np.float64)
-    for ibunch in range(npix//bunchsize):
+    for ibunch in range(npix/bunchsize):
         ipix = np.arange(ibunch*bunchsize,
                           (ibunch+1)*bunchsize)
         ipix = ipix[(m.flat[ipix]!=bad) & (np.isfinite(m.flat[ipix]))]
         x,y,z = pix2vec(nside, ipix, nest)
         if gal_cut>0:
             w = (np.abs(z)>=np.sin(gal_cut*np.pi/180))
             ipix=ipix[w]
@@ -1358,21 +1011,21 @@
     aa[2,3] = aa[3,2]
     res = np.dot(np.linalg.inv(aa),v)
     mono = res[0]
     dipole = res[1:4]
     return mono,dipole
 
 def remove_dipole(m,nest=False,bad=UNSEEN,gal_cut=0,fitval=False,
-                  copy=True,verbose=True):
+                  copy=True,verbose=False):
     """Fit and subtract the dipole and the monopole from the given map m.
 
     Parameters
     ----------
     m : float, array-like
-      the map to which a dipole is fitted and subtracted, accepts masked arrays
+      the map to which a dipole is fitted and subtracted
     nest : bool
       if ``False`` m is assumed in RING scheme, otherwise map is NESTED
     bad : float
       bad values of pixel, default to :const:`UNSEEN`.
     gal_cut : float
       pixels at latitude in [-gal_cut;+gal_cut] are not taken into account
     fitval : bool
@@ -1389,54 +1042,51 @@
       otherwise, returns map (array, in res[0]), monopole (float, in res[1]), 
       dipole_vector (array, in res[2])
 
     See Also
     --------
     fit_dipole, fit_monopole, remove_monopole
     """
-    input_ma = is_ma(m)
-    m=ma_to_array(m)
     m=np.array(m,copy=copy)
     npix = m.size
     nside = npix2nside(npix)
     if nside>128:
-        bunchsize = npix//24
+        bunchsize = npix/24
     else:
         bunchsize = npix
     mono,dipole = fit_dipole(m,nest=nest,bad=bad,gal_cut=gal_cut)
-    for ibunch in range(npix//bunchsize):
+    for ibunch in range(npix/bunchsize):
         ipix = np.arange(ibunch*bunchsize,
                           (ibunch+1)*bunchsize)
         ipix = ipix[(m.flat[ipix]!=bad) & (np.isfinite(m.flat[ipix]))]
         x,y,z = pix2vec(nside, ipix, nest)
         m.flat[ipix] -= (dipole[0]*x)
         m.flat[ipix] -= dipole[1]*y
         m.flat[ipix] -= dipole[2]*z
         m.flat[ipix] -= mono
     if verbose:
-        from . import rotator as R
+        import rotator as R
         lon,lat = R.vec2dir(dipole,lonlat=True)
         amp = np.sqrt((dipole**2).sum())
-        print(
-            'monopole: {0:g}  dipole: lon: {1:g}, lat: {2:g}, amp: {3:g}'
-            .format(mono, lon, lat, amp))
-    if is_ma:
-        m = ma(m)
+        print 'monopole: %g  dipole: lon: %g, lat: %g, amp: %g'%(mono,
+                                                                 lon,
+                                                                 lat,
+                                                                 amp)
     if fitval:
         return m,mono,dipole
     else:
         return m
 
-def fit_monopole(m,nest=False,bad=UNSEEN,gal_cut=0):
+def fit_monopole(m,nest=False,bad=pixlib.UNSEEN,gal_cut=0):
     """Fit a monopole to the map, excluding unseen pixels.
 
     Parameters
     ----------
     m : float, array-like
-      the map to which a dipole is fitted and subtracted, accepts masked arrays
+      the map to which a dipole is fitted and subtracted
     nest : bool
       if ``False`` m is assumed in RING scheme, otherwise map is NESTED
     bad : float
       bad values of pixel, default to :const:`UNSEEN`.
     gal_cut : float
       pixels at latitude in [-gal_cut;+gal_cut] degrees are not taken into account
 
@@ -1445,24 +1095,23 @@
     res: float
       fitted monopole value
 
     See Also
     --------
     fit_dipole, remove_monopole, remove_monopole
     """
-    m=ma_to_array(m)
     m=np.asarray(m)
     npix=m.size
     nside = npix2nside(npix)
     if nside>128:
-        bunchsize=npix//24
+        bunchsize=npix/24
     else:
         bunchsize=npix
     aa = v = 0.0
-    for ibunch in range(npix//bunchsize):
+    for ibunch in range(npix/bunchsize):
         ipix = np.arange(ibunch*bunchsize,
                           (ibunch+1)*bunchsize)
         ipix = ipix[(m.flat[ipix]!=bad) & (np.isfinite(m.flat[ipix]))]
         x,y,z = pix2vec(nside, ipix, nest)
         if gal_cut>0:
             w = (np.abs(z)>=np.sin(gal_cut*np.pi/180))
             ipix=ipix[w]
@@ -1471,16 +1120,16 @@
             z=z[w]
             del w
         aa += ipix.size
         v += m.flat[ipix].sum()
     mono = v/aa
     return mono
 
-def remove_monopole(m,nest=False,bad=UNSEEN,gal_cut=0,fitval=False,
-                    copy=True,verbose=True):
+def remove_monopole(m,nest=False,bad=pixlib.UNSEEN,gal_cut=0,fitval=False,
+                    copy=True,verbose=False):
     """Fit and subtract the monopole from the given map m.
 
     Parameters
     ----------
     m : float, array-like
       the map to which a monopole is fitted and subtracted
     nest : bool
@@ -1502,34 +1151,30 @@
       if fitval is False, returns map with monopole subtracted,
       otherwise, returns map (array, in res[0]) and monopole (float, in res[1])
 
     See Also
     --------
     fit_dipole, fit_monopole, remove_dipole
     """
-    input_ma = is_ma(m)
-    m= ma_to_array(m)
     m=np.array(m,copy=copy)
     npix = m.size
     nside = npix2nside(npix)
     if nside>128:
-        bunchsize = npix//24
+        bunchsize = npix/24
     else:
         bunchsize = npix
     mono = fit_monopole(m,nest=nest,bad=bad,gal_cut=gal_cut)
-    for ibunch in range(npix//bunchsize):
+    for ibunch in range(npix/bunchsize):
         ipix = np.arange(ibunch*bunchsize,
                           (ibunch+1)*bunchsize)
         ipix = ipix[(m.flat[ipix]!=bad) & (np.isfinite(m.flat[ipix]))]
         x,y,z = pix2vec(nside, ipix, nest)
         m.flat[ipix] -= mono
     if verbose:
-        print('monopole: {0:g}'.format(mono))
-    if input_ma:
-        m = ma(m)
+        print 'monopole: %g'%mono
     if fitval:
         return m,mono
     else:
         return m
 
 def get_map_size(m):
     """Returns the npix of a given map (implicit or explicit pixelization).
@@ -1553,22 +1198,22 @@
      In implicit pixellization, raise a ValueError exception if the size of the input
      is not a valid pixel number.
 
      Examples
      --------
     >>> import healpy as hp
      >>> m = {0: 1, 1: 1, 2: 1, 'nside': 1}
-     >>> print(hp.get_map_size(m))
+     >>> print hp.get_map_size(m)
      12
 
      >>> m = {0: 1, 767: 1}
-     >>> print(hp.get_map_size(m))
+     >>> print hp.get_map_size(m)
      768
 
-     >>> print(hp.get_map_size(np.zeros(12 * 8 ** 2)))
+     >>> print hp.get_map_size(np.zeros(12 * 8 ** 2))
      768
     """
     if isinstance(m, dict):
         if 'nside' in m:
             return nside2npix(m['nside'])
         elif hasattr(ma, 'nside'):
             return nside2npix(m.nside)
@@ -1601,14 +1246,61 @@
     8
     >>> hp.pixelfunc.get_min_valid_nside(768)
     8
     """
     order = 0.5 * np.log2(npix / 12.)
     return 2**int(np.ceil(order))
 
+def maptype(m):
+    """Describe the type of the map (valid, single, sequence of maps).
+    Checks : the number of maps, that all maps have same length and that this
+    length is a valid map size (using :func:`isnpixok`).
+
+    Parameters
+    ----------
+    m : sequence
+      the map to get info from
+
+    Returns
+    -------
+    info : int
+      -1 if the given object is not a valid map, 0 if it is a single map,
+      *info* > 0 if it is a sequence of maps (*info* is then the number of
+      maps)
+
+    Examples
+    --------
+    >>> import healpy as hp
+    >>> hp.pixelfunc.maptype(np.arange(12))
+    0
+    >>> hp.pixelfunc.maptype(2)
+    -1
+    >>> hp.pixelfunc.maptype([np.arange(12), np.arange(12)])
+    2
+    >>> hp.pixelfunc.maptype([np.arange(12), np.arange(768)])
+    -1
+    """
+    if not hasattr(m, '__len__'):
+        return -1
+    if len(m) == 0:
+        return -1
+    if hasattr(m[0], '__len__'):
+        npix=len(m[0])
+        for mm in m[1:]:
+            if len(mm) != npix:
+                return -1
+        if isnpixok(len(m[0])):
+            return len(m)
+        else:
+            return -1
+    else:
+        if isnpixok(len(m)):
+            return 0
+        else:
+            return -1
 
 def get_nside(m):
     """Return the nside of the given map.
 
     Parameters
     ----------
     m : sequence
@@ -1622,44 +1314,39 @@
     Notes
     -----
     If the input is a sequence of maps, all of them must have same size.
     If the input is not a valid map (not a sequence, unvalid number of pixels),
     a TypeError exception is raised.
     """
     typ = maptype(m)
+    if typ < 0:
+        raise TypeError('m is not a map nor a sequence of maps of same size')
     if typ == 0:
         return npix2nside(len(m))
     else:
         return npix2nside(len(m[0]))
 
-@accept_ma
 def ud_grade(map_in,nside_out,pess=False,order_in='RING',order_out=None,
              power=None, dtype=None):
     """Upgrade or degrade resolution of a map (or list of maps).
 
-    in degrading the resolution, ud_grade sets the value of the superpixel
-    as the mean of the children pixels.
-
     Parameters
     ----------
     map_in : array-like or sequence of array-like
       the input map(s) (if a sequence of maps, all must have same size)
     nside_out : int
       the desired nside of the output map(s)
     pess : bool
       if ``True``, in degrading, reject pixels which contains
       a bad sub_pixel. Otherwise, estimate average with good pixels
     order_in, order_out : str
       pixel ordering of input and output ('RING' or 'NESTED')
     power : float
-      if non-zero, divide the result by (nside_in/nside_out)**power
-      Examples:
-      power=-2 keeps the sum of the map invariant (useful for hitmaps),
-      power=2 divides the mean by another factor of (nside_in/nside_out)**2
-      (useful for variance maps)
+      if non-zero, multiply the result by (nside_in/nside_out)**power
+      For example, power=-2 keep the sum of the map invariant
     dtype : type
       the type of the output map
 
     Returns
     -------
     map_out : array-like or sequence of array-like
       the upgraded or degraded map(s)
@@ -1667,15 +1354,16 @@
     Examples
     --------
     >>> import healpy as hp
     >>> hp.ud_grade(np.arange(48.), 1)
     array([  5.5 ,   7.25,   9.  ,  10.75,  21.75,  21.75,  23.75,  25.75,
             36.5 ,  38.25,  40.  ,  41.75])
     """
-    check_nside(nside_out)
+    if not isnsideok(nside_out):
+        raise ValueError('Invalid nside for output')
     typ = maptype(map_in)
     if typ<0:
         raise TypeError('Invalid map')
     if typ == 0:
         m_in = [map_in]
     else:
         m_in = map_in
@@ -1698,41 +1386,48 @@
     and single (not a list of maps)
     """
     nside_in = get_nside(m)
     if dtype:
         type_out = dtype
     else:
         type_out = type(m[0])
-    check_nside(nside_out)
+    if not isnsideok(nside_out):
+        raise ValueError('invalid nside_out value')
     npix_in = nside2npix(nside_in)
     npix_out = nside2npix(nside_out)
 
     if power:
         power = float(power)
         ratio = (float(nside_out)/float(nside_in))**power
     else:
         ratio = 1
     
     if nside_out > nside_in:
-        rat2 = npix_out//npix_in
+        rat2 = npix_out/npix_in
         fact = np.ones(rat2, dtype=type_out)*ratio
         map_out = np.outer(m,fact).reshape(npix_out)
     elif nside_out < nside_in:
-        rat2 = npix_in//npix_out
+        rat2 = npix_in/npix_out
+        bads = (mask_bad(m) | (~np.isfinite(m)))
+        hit = np.ones(npix_in,dtype=np.int16)
+        hit[bads] = 0
+        m[bads] = 0
         mr = m.reshape(npix_out,rat2)
-        goods = ~(mask_bad(mr) | (~np.isfinite(mr)))
-        map_out = np.sum(mr*goods, axis=1).astype(type_out)
-        nhit = goods.sum(axis=1)
+        hit = hit.reshape(npix_out,rat2)
+        map_out = mr.sum(axis=1).astype(type_out)
+        nhit = hit.sum(axis=1)
         if pess:
             badout = np.where(nhit != rat2)
         else:
             badout = np.where(nhit == 0)
         if power:
-            nhit = nhit / ratio
-        map_out[nhit!=0] = map_out[nhit!=0] / nhit[nhit!=0]
+            nhit /= ratio
+        map_out /= nhit
         try:
             map_out[badout] = UNSEEN
+            m[bads] = UNSEEN
         except OverflowError:
             pass
     else:
         map_out = m
     return map_out.astype(type_out)
+
```

### Comparing `healpy-1.9.1/healpy/fitsfunc.py` & `healpy-github-devel/healpy/fitsfunc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,502 +1,336 @@
-#
+# 
 #  This file is part of Healpy.
-#
+# 
 #  Healpy is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
 #  the Free Software Foundation; either version 2 of the License, or
 #  (at your option) any later version.
-#
+# 
 #  Healpy is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #  GNU General Public License for more details.
-#
+# 
 #  You should have received a copy of the GNU General Public License
 #  along with Healpy; if not, write to the Free Software
 #  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-#
+# 
 #  For more information about Healpy, see http://code.google.com/p/healpy
-#
+# 
 """Provides input and output functions for Healpix maps, alm, and cl.
 """
-from __future__ import with_statement
-
-import six
-import gzip
-import tempfile
-import shutil
-import os
-import warnings
-
-try:
-    import astropy.io.fits as pf
-except ImportError:
-    import pyfits as pf
 
+import pyfits as pf
 import numpy as np
-
-from . import pixelfunc
-from .sphtfunc import Alm
-from .pixelfunc import UNSEEN
-from . import cookbook as cb
-
-standard_column_names = {
-    1 : "I_STOKES",
-    3 : ["%s_STOKES" % comp for comp in "IQU"],
-    6 : ["II", "IQ", "IU", "QQ", "QU", "UU"]
-}
+import pixelfunc
+from sphtfunc import Alm
+import warnings
+from pixelfunc import UNSEEN
+from exceptions import NotImplementedError
 
 class HealpixFitsWarning(Warning):
     pass
 
-def writeto(tbhdu, filename):
-    # FIXME: Pyfits versions earlier than 3.1.2 had no support or flaky support
-    # for writing to .gz files or GzipFile objects. Drop this code when
-    # we decide to drop support for older versions of Pyfits or if we decide
-    # to support only Astropy.
-    if isinstance(filename, six.string_types) and filename.endswith('.gz'):
-        basefilename, ext = os.path.splitext(filename)
-        with tempfile.NamedTemporaryFile(suffix='.fits') as tmpfile:
-            tbhdu.writeto(tmpfile.name, clobber=True)
-            gzfile = gzip.open(filename, 'wb')
-            try:
-                try:
-                    shutil.copyfileobj(tmpfile, gzfile)
-                finally:
-                    gzfile.close()
-            except:
-                os.unlink(gzfile.name)
-                raise
-    else:
-        tbhdu.writeto(filename, clobber=True)
-
-def read_cl(filename, dtype=np.float64, h=False):
+def read_cl(filename,dtype=np.float64,h=False):
     """Reads Cl from an healpix file, as IDL fits2cl.
 
     Parameters
     ----------
-    filename : str or HDUList or HDU
+    filename : str
       the fits file name
     dtype : data type, optional
       the data type of the returned array
 
     Returns
     -------
     cl : array
-      the cl array
+      the cl array, currently TT only
     """
-    fits_hdu = _get_hdu(filename, hdu=1)
-    cl = [fits_hdu.data.field(n) for n in range(len(fits_hdu.columns))]
-    if len(cl) == 1:
-        return cl[0]
-    else:
-        return cl
+    hdulist=pf.open(filename)
+    return hdulist[1].data.field(0)
 
-def write_cl(filename, cl, dtype=np.float64):
+def write_cl(filename,cl,dtype=np.float32):
     """Writes Cl into an healpix file, as IDL cl2fits.
 
     Parameters
     ----------
     filename : str
       the fits file name
     cl : array
       the cl array to write to file, currently TT only
     """
     # check the dtype and convert it
     fitsformat = getformat(dtype)
-    column_names = ['TEMPERATURE','GRADIENT','CURL','G-T','C-T','C-G']
     if isinstance(cl, list):
-        cols = [pf.Column(name=column_name,
-                               format='%s'%fitsformat,
-                               array=column_cl) for column_name, column_cl in zip(column_names[:len(cl)], cl)]
+        raise NotImplementedError('Currently it supports only temperature-only cls')
     else: # we write only one TT
         cols = [pf.Column(name='TEMPERATURE',
                                format='%s'%fitsformat,
                                array=cl)]
-
+            
     tbhdu = pf.new_table(cols)
     # add needed keywords
     tbhdu.header.update('CREATOR','healpy')
-    writeto(tbhdu, filename)
+    tbhdu.writeto(filename,clobber=True)
 
-def write_map(filename,m,nest=False,dtype=np.float32,fits_IDL=True,coord=None,partial=False,column_names=None,column_units=None,extra_header=()):
+def write_map(filename,m,nest=False,dtype=np.float32,fits_IDL=True,coord=None):
     """Writes an healpix map into an healpix file.
 
     Parameters
     ----------
     filename : str
       the fits file name
     m : array or sequence of 3 arrays
       the map to write. Possibly a sequence of 3 maps of same size.
-      They will be considered as I, Q, U maps.
-      Supports masked maps, see the `ma` function.
+      They will be considered as I, Q, U maps
     nest : bool, optional
-      If True, ordering scheme is assumed to be NESTED, otherwise, RING. Default: RING.
-      The map ordering is not modified by this function, the input map array
-      should already be in the desired ordering (run `ud_grade` beforehand).
+      If False, ordering scheme is NESTED, otherwise, it is RING. Default: RING.
     fits_IDL : bool, optional
-      If True, reshapes columns in rows of 1024, otherwise all the data will
+      If True, reshapes columns in rows of 1024, otherwise all the data will 
       go in one column. Default: True
     coord : str
-      The coordinate system, typically 'E' for Ecliptic, 'G' for Galactic or 'C' for
-      Celestial (equatorial)
-    partial : bool, optional
-      If True, fits file is written as a partial-sky file with explicit indexing.
-      Otherwise, implicit indexing is used.  Default: False.
-    column_names : str or list
-      Column name or list of column names, if None we use:
-      I_STOKES for 1 component,
-      I/Q/U_STOKES for 3 components,
-      II, IQ, IU, QQ, QU, UU for 6 components,
-      COLUMN_0, COLUMN_1... otherwise
-    column_units : str or list
-      Units for each column, or same units for all columns.
-    extra_header : list
-      Extra records to add to FITS header.
+      The coordinate system, typically 'E' for Ecliptic, 'G' for Galactic or 'Q' for Equatorial  
     """
     if not hasattr(m, '__len__'):
         raise TypeError('The map must be a sequence')
     # check the dtype and convert it
     fitsformat = getformat(dtype)
-
-    m = pixelfunc.ma_to_array(m)
-    if pixelfunc.maptype(m) == 0: # a single map is converted to a list
-        m = [m]
-
-    if column_names is None:
-        column_names = standard_column_names.get(len(m), ["COLUMN_%d" % n for n in range(len(m))])
-    else:
-        assert len(column_names) == len(m), "Length column_names != number of maps"
-
-    if column_units is None or isinstance(column_units, six.string_types):
-        column_units = [column_units] * len(m)
-
-    # maps must have same length
-    assert len(set(map(len, m))) == 1, "Maps must have same length"
-    nside = pixelfunc.npix2nside(len(m[0]))
-
-    if nside < 0:
-        raise ValueError('Invalid healpix map : wrong number of pixel')
-
-    cols=[]
-    if partial:
-        fits_IDL = False
-        mask = pixelfunc.mask_good(m[0])
-        pix = np.where(mask)[0]
-        if len(pix) == 0:
-            raise ValueError('Invalid healpix map : empty partial map')
-        m = [mm[mask] for mm in m]
-        ff = getformat(np.min_scalar_type(-pix.max()))
-        if ff is None:
-            ff = 'I'
-        cols.append(pf.Column(name='PIXEL',
-                              format=ff,
-                              array=pix,
-                              unit=None))
-
-    for cn, cu, mm in zip(column_names, column_units, m):
-        if len(mm) > 1024 and fits_IDL:
-            # I need an ndarray, for reshape:
-            mm2 = np.asarray(mm)
-            cols.append(pf.Column(name=cn,
-                                   format='1024%s' % fitsformat,
-                                   array=mm2.reshape(mm2.size/1024,1024),
-                                   unit=cu))
+    #print 'format to use: "%s"'%fitsformat
+    if hasattr(m[0], '__len__'):
+        # we should have three maps
+        if len(m) != 3 or len(m[1]) != len(m[0]) or len(m[2]) != len(m[0]):
+            raise ValueError("You should give 3 maps of same size "
+                             "for polarisation...")
+        nside = pixelfunc.npix2nside(len(m[0]))
+        if nside < 0:
+            raise ValueError('Invalid healpix map : wrong number of pixel')
+        cols=[]
+        colnames=['I_STOKES','Q_STOKES','U_STOKES']
+        for cn,mm in zip(colnames,m):
+            if len(mm) > 1024 and fits_IDL:
+                # I need an ndarray, for reshape:
+                mm2 = np.asarray(mm)
+                cols.append(pf.Column(name=cn,
+                                       format='1024%s'%fitsformat,
+                                       array=mm2.reshape(mm2.size/1024,1024)))
+            else:
+                cols.append(pf.Column(name=cn,
+                                       format='%s'%fitsformat,
+                                       array=mm))
+    else: # we write only one map
+        nside = pixelfunc.npix2nside(len(m))
+        if nside < 0:
+            raise ValueError('Invalid healpix map : wrong number of pixel')
+        if m.size > 1024 and fits_IDL:
+            cols = [pf.Column(name='I_STOKES',
+                               format='1024%s'%fitsformat,
+                               array=m.reshape(m.size/1024,1024))]
         else:
-            cols.append(pf.Column(name=cn,
-                                   format='%s' % fitsformat,
-                                   array=mm,
-                                   unit=cu))
-
+            cols = [pf.Column(name='I_STOKES',
+                               format='%s'%fitsformat,
+                               array=m)]
+            
     tbhdu = pf.new_table(cols)
     # add needed keywords
     tbhdu.header.update('PIXTYPE','HEALPIX','HEALPIX pixelisation')
     if nest: ordering = 'NESTED'
     else:    ordering = 'RING'
     tbhdu.header.update('ORDERING',ordering,
                         'Pixel ordering scheme, either RING or NESTED')
     if coord:
-        tbhdu.header.update('COORDSYS',coord,
-                            'Ecliptic, Galactic or Celestial (equatorial)')
+        tbhdu.header.update('COORD',coord,
+                            'Ecliptic, Galactic or eQuatorial')
     tbhdu.header.update('EXTNAME','xtension',
                         'name of this binary table extension')
     tbhdu.header.update('NSIDE',nside,'Resolution parameter of HEALPIX')
-    if not partial:
-        tbhdu.header.update('FIRSTPIX', 0, 'First pixel # (0 based)')
-        tbhdu.header.update('LASTPIX',pixelfunc.nside2npix(nside)-1,
-                            'Last pixel # (0 based)')
-    tbhdu.header.update('INDXSCHM', 'EXPLICIT' if partial else 'IMPLICIT',
+    tbhdu.header.update('FIRSTPIX', 0, 'First pixel # (0 based)')
+    tbhdu.header.update('LASTPIX',pixelfunc.nside2npix(nside)-1,
+                        'Last pixel # (0 based)')
+    tbhdu.header.update('INDXSCHM','IMPLICIT',
                         'Indexing: IMPLICIT or EXPLICIT')
-    tbhdu.header.update('OBJECT', 'PARTIAL' if partial else 'FULLSKY',
-                        'Sky coverage, either FULLSKY or PARTIAL')
-
-    # FIXME: In modern versions of Pyfits, header.update() understands a
-    # header as an argument, and headers can be concatenated with the `+'
-    # operator.
-    for args in extra_header:
-        if args[0] == 'COMMENT':
-            tbhdu.header.add_comment(*args[1:])
-        else:
-            tbhdu.header.update(*args)
+    tbhdu.writeto(filename,clobber=True)
 
-    writeto(tbhdu, filename)
 
-
-def read_map(filename,field=0,dtype=np.float64,nest=False,partial=False,hdu=1,h=False,
-             verbose=True,memmap=False):
-    """Read an healpix map from a fits file.  Partial-sky files,
-    if properly identified, are expanded to full size and filled with UNSEEN.
+def read_map(filename,field=0,dtype=np.float64,nest=False,hdu=1,h=False,
+             verbose=False):
+    """Read an healpix map from a fits file.
 
     Parameters
     ----------
-    filename : str or HDU or HDUList
+    filename : str
       the fits file name
-    field : int or tuple of int, or None, optional
+    field : int or tuple of int, optional
       The column to read. Default: 0.
       By convention 0 is temperature, 1 is Q, 2 is U.
       Field can be a tuple to read multiple columns (0,1,2)
-      If the fits file is a partial-sky file, field=0 corresponds to the
-      first column after the pixel index column.
-      If None, all columns are read in.
     dtype : data type, optional
       Force the conversion to some type. Default: np.float64
     nest : bool, optional
-      If True return the map in NEST ordering, otherwise in RING ordering;
+      If True return the map in NEST ordering, otherwise in RING ordering; 
       use fits keyword ORDERING to decide whether conversion is needed or not
       If None, no conversion is performed.
-    partial : bool, optional
-      If True, fits file is assumed to be a partial-sky file with explicit indexing,
-      if the indexing scheme cannot be determined from the header.
-      If False, implicit indexing is assumed.  Default: False.
-      A partial sky file is one in which OBJECT=PARTIAL and INDXSCHM=EXPLICIT,
-      and the first column is then assumed to contain pixel indices.
-      A full sky file is one in which OBJECT=FULLSKY and INDXSCHM=IMPLICIT.
-      At least one of these keywords must be set for the indexing
-      scheme to be properly identified.
     hdu : int, optional
       the header number to look at (start at 0)
-    h : bool, optional
+    h : boo, optional
       If True, return also the header. Default: False.
     verbose : bool, optional
       If True, print a number of diagnostic messages
-    memmap : bool, optional
-      Argument passed to astropy.io.fits.open, if True, the map is not read into memory,
-      but only the required pixels are read when needed. Default: False.
 
     Returns
     -------
     m | (m0, m1, ...) [, header] : array or a tuple of arrays, optionally with header appended
       The map(s) read from the file, and the header if *h* is True.
     """
-
-    fits_hdu = _get_hdu(filename, hdu=hdu, memmap=memmap)
-
-    nside = fits_hdu.header.get('NSIDE')
+    hdulist=pf.open(filename)
+    #print hdulist[1].header
+    nside = hdulist[hdu].header.get('NSIDE')
     if nside is None:
-        warnings.warn("No NSIDE in the header file : will use length of array", HealpixFitsWarning)
+        warnings.warn("No NSIDE in the header file : will use length of array",
+                      HealpixFitsWarning)
     else:
         nside = int(nside)
-    if verbose: print('NSIDE = {0:d}'.format(nside))
+    if verbose: print 'NSIDE = %d'%nside
 
     if not pixelfunc.isnsideok(nside):
         raise ValueError('Wrong nside parameter.')
-    ordering = fits_hdu.header.get('ORDERING','UNDEF').strip()
+    ordering = hdulist[hdu].header.get('ORDERING','UNDEF').strip()
     if ordering == 'UNDEF':
         ordering = (nest and 'NESTED' or 'RING')
         warnings.warn("No ORDERING keyword in header file : "
                       "assume %s"%ordering)
-    if verbose: print('ORDERING = {0:s} in fits file'.format(ordering))
+    if verbose: print 'ORDERING = %s in fits file'%ordering
 
     sz=pixelfunc.nside2npix(nside)
-    ret = []
-
-    # partial sky: check OBJECT, then INDXSCHM
-    obj = fits_hdu.header.get('OBJECT', 'UNDEF').strip()
-    if obj != 'UNDEF':
-        if obj == 'PARTIAL':
-            partial = True
-        elif obj == 'FULLSKY':
-            partial = False
-
-    schm = fits_hdu.header.get('INDXSCHM', 'UNDEF').strip()
-    if schm != 'UNDEF':
-        if schm == 'EXPLICIT':
-            if obj == 'FULLSKY':
-                raise ValueError('Incompatible INDXSCHM keyword')
-            partial = True
-        elif schm == 'IMPLICIT':
-            if obj == 'PARTIAL':
-                raise ValueError('Incompatible INDXSCHM keyword')
-            partial = False
-
-    if schm == 'UNDEF':
-        schm = (partial and 'EXPLICIT' or 'IMPLICIT')
-        warnings.warn("No INDXSCHM keyword in header file : "
-                       "assume {}".format(schm))
-    if verbose:
-        print('INDXSCHM = {0:s}'.format(schm))
-
-    if field is None:
-        field = range(len(fits_hdu.data.columns) - 1*partial)
-    if not (hasattr(field, '__len__') or isinstance(field, str)):
+    if not hasattr(field, '__len__'):
         field = (field,)
-
-    if partial:
-        # increment field counters
-        field = tuple(f if isinstance(f, str) else f+1 for f in field)
-        try:
-            pix = fits_hdu.data.field(0).astype(int).ravel()
-        except pf.VerifyError as e:
-            print(e)
-            print("Trying to fix a badly formatted header")
-            fits_hdu.verify("fix")
-            pix = fits_hdu.data.field(0).astype(int).ravel()
+    ret = []
 
     for ff in field:
-        try:
-            m=fits_hdu.data.field(ff).astype(dtype).ravel()
-        except pf.VerifyError as e:
-            print(e)
-            print("Trying to fix a badly formatted header")
-            m=fits_hdu.verify("fix")
-            m=fits_hdu.data.field(ff).astype(dtype).ravel()
-
-        if partial:
-            mnew = UNSEEN * np.ones(sz, dtype=dtype)
-            mnew[pix] = m
-            m = mnew
-
+        m=hdulist[hdu].data.field(ff).astype(dtype).ravel()
         if (not pixelfunc.isnpixok(m.size) or (sz>0 and sz != m.size)) and verbose:
-            print('nside={0:d}, sz={1:d}, m.size={2:d}'.format(nside,sz,m.size))
+            print 'nside=%d, sz=%d, m.size=%d'%(nside,sz,m.size)
             raise ValueError('Wrong nside parameter.')
         if not nest is None: # no conversion with None
             if nest and ordering == 'RING':
                 idx = pixelfunc.nest2ring(nside,np.arange(m.size,dtype=np.int32))
                 m = m[idx]
-                if verbose: print('Ordering converted to NEST')
+                if verbose: print 'Ordering converted to NEST'
             elif (not nest) and ordering == 'NESTED':
                 idx = pixelfunc.ring2nest(nside,np.arange(m.size,dtype=np.int32))
                 m = m[idx]
-                if verbose: print('Ordering converted to RING')
+                if verbose: print 'Ordering converted to RING'
         try:
             m[pixelfunc.mask_bad(m)] = UNSEEN
-        except OverflowError:
+        except OverflowError, e:
             pass
         ret.append(m)
-
+    
     if len(ret) == 1:
         if h:
-            return ret[0],fits_hdu.header.items()
+            return ret[0],hdulist[hdu].header.items()
         else:
             return ret[0]
     else:
         if h:
-            ret.append(fits_hdu.header.items())
+            ret.append(hdulist[hdu].header.items())
             return tuple(ret)
         else:
             return tuple(ret)
 
 
 def write_alm(filename,alms,out_dtype=None,lmax=-1,mmax=-1,mmax_in=-1):
-    """Write alms to a fits file.
-
-    In the fits file the alms are written
+    """Write alms to a fits file. 
+    
+    In the fits file the alms are written 
     with explicit index scheme, index = l*l + l + m +1, possibly out of order.
     By default write_alm makes a table with the same precision as the alms.
     If specified, the lmax and mmax parameters truncate the input data to
     include only alms for which l <= lmax and m <= mmax.
 
     Parameters
     ----------
     filename : str
       The filename of the output fits file
-    alms : array, complex or list of arrays
-      A complex ndarray holding the alms, index = m*(2*lmax+1-m)/2+l, see Alm.getidx
+    alms : array, complex
+      A complex ndarray holding the alms.
     lmax : int, optional
       The maximum l in the output file
     mmax : int, optional
       The maximum m in the output file
     out_dtype : data type, optional
       data type in the output file (must be a numpy dtype). Default: *alms*.real.dtype
     mmax_in : int, optional
       maximum m in the input array
     """
 
-    if not cb.is_seq_of_seq(alms):
-        alms = [alms]
-
-    l2max = Alm.getlmax(len(alms[0]),mmax=mmax_in)
+    l2max = Alm.getlmax(len(alms),mmax=mmax_in)
     if (lmax != -1 and lmax > l2max):
         raise ValueError("Too big lmax in parameter")
     elif lmax == -1:
         lmax = l2max
 
     if mmax_in == -1:
-        mmax_in = l2max
+	mmax_in = l2max
 
     if mmax == -1:
         mmax = lmax
     if mmax > mmax_in:
-        mmax = mmax_in
+	mmax = mmax_in
 
     if (out_dtype == None):
-        out_dtype = alms[0].real.dtype
+        out_dtype = alms.real.dtype
 
     l,m = Alm.getlm(lmax)
     idx = np.where((l <= lmax)*(m <= mmax))
     l = l[idx]
     m = m[idx]
 
     idx_in_original = Alm.getidx(l2max, l=l, m=m)
-
+    
     index = l**2 + l + m + 1
 
-    hdulist = pf.HDUList()
-    for alm in alms:
-        out_data = np.empty(len(index),
-                   dtype=[('index','i'),
-                          ('real',out_dtype),
-                          ('imag',out_dtype)])
-        out_data['index'] = index
-        out_data['real'] = alm.real[idx_in_original]
-        out_data['imag'] = alm.imag[idx_in_original]
-
-        cindex = pf.Column(name="index", format=getformat(np.int32), unit="l*l+l+m+1", array=out_data['index'])
-        creal = pf.Column(name="real", format=getformat(out_dtype), unit="unknown", array=out_data['real'])
-        cimag = pf.Column(name="imag", format=getformat(out_dtype), unit="unknown", array=out_data['imag'])
-
-        tbhdu = pf.new_table([cindex,creal,cimag])
-        hdulist.append(tbhdu)
-    writeto(tbhdu, filename)
-
+    out_data = np.empty(len(index),\
+                             dtype=[('index','i'),\
+                                        ('real',out_dtype),('imag',out_dtype)])
+    out_data['index'] = index
+    out_data['real'] = alms.real[idx_in_original]
+    out_data['imag'] = alms.imag[idx_in_original]
+
+    cindex = pf.Column(name="index", format=getformat(np.int32), unit="l*l+l+m+1", array=out_data['index'])
+    creal = pf.Column(name="real", format=getformat(out_dtype), unit="unknown", array=out_data['real'])
+    cimag = pf.Column(name="imag", format=getformat(out_dtype), unit="unknown", array=out_data['imag'])
+
+    tbhdu = pf.new_table([cindex,creal,cimag])
+    tbhdu.writeto(filename,clobber=True)       
+    
 def read_alm(filename,hdu=1,return_mmax=False):
-    """Read alm from a fits file.
-
+    """Read alm from a fits file. 
+    
     In the fits file, the alm are written
     with explicit index scheme, index = l**2+l+m+1, while healpix cxx
-    uses index = m*(2*lmax+1-m)/2+l. The conversion is done in this
+    uses index = m*(2*lmax+1-m)/2+l. The conversion is done in this 
     function.
 
     Parameters
     ----------
-    filename : str or HDUList or HDU
+    filename : str
       The name of the fits file to read
     hdu : int, optional
       The header to read. Start at 0. Default: hdu=1
     return_mmax : bool, optional
       If true, both the alms and mmax is returned in a tuple. Default: return_mmax=False
 
     Returns
     -------
     alms[, mmax] : complex array or tuple of a complex array and an int
       The alms read from the file and optionally mmax read from the file
     """
     idx, almr, almi = mrdfits(filename,hdu=hdu)
-    l = np.floor(np.sqrt(idx-1)).astype(np.long)
+    l = np.floor(np.sqrt(idx-1)).astype(long)
     m = idx - l**2 - l - 1
     if (m<0).any():
         raise ValueError('Negative m value encountered !')
     lmax = l.max()
     mmax = m.max()
     alm = almr*(0+0j)
     i = Alm.getidx(lmax,l,m)
@@ -505,69 +339,40 @@
     if return_mmax:
         return alm, mmax
     else:
         return alm
 
 ## Generic functions to read and write column of data in fits file
 
-def _get_hdu(input_data, hdu=None, memmap=None):
-    """
-    Return an HDU from a FITS file
+def mrdfits(filename,hdu=1):
+    """Read a table in a fits file.
 
     Parameters
     ----------
-    input_data : str or HDUList or HDU instance
-        The input FITS file, either as a filename, HDU list, or HDU instance.
-
-    Returns
-    -------
-    fits_hdu : HDU
-        The extracted HDU
-    """
-
-    if isinstance(input_data, six.string_types):
-        hdulist = pf.open(input_data, memmap=memmap)
-        return _get_hdu(hdulist, hdu=hdu)
-
-    if isinstance(input_data, pf.HDUList):
-        if isinstance(hdu, int) and hdu >= len(input_data):
-            raise ValueError('Available hdu in [0-%d]' % len(hdulist))
-        else:
-            fits_hdu = input_data[hdu]
-    elif isinstance(input_data, (pf.PrimaryHDU, pf.ImageHDU, pf.BinTableHDU, pf.TableHDU, pf.GroupsHDU)):
-        fits_hdu = input_data
-    else:
-        raise TypeError("First argument should be a input_data, HDUList instance, or HDU instance")
-
-    return fits_hdu
-
-
-def mrdfits(filename, hdu=1):
-    """
-    Read a table in a fits file.
-
-    Parameters
-    ----------
-    filename : str or HDUList or HDU
-      The name of the fits file to read, or an HDUList or HDU instance.
+    filename : str
+      The name of the fits file to read
     hdu : int, optional
       The header to read. Start at 0. Default: hdu=1
 
     Returns
     -------
     cols : a list of arrays
       A list of column data in the given header
     """
-    fits_hdu = _get_hdu(filename, hdu=hdu)
+    hdulist=pf.open(filename)
+    if hdu>=len(hdulist):
+        raise ValueError('Available hdu in [0-%d]'%len(hdulist))
+    hdu=hdulist[hdu]
     val=[]
-    for i in range(len(fits_hdu.columns)):
-        val.append(fits_hdu.data.field(i))
+    for i in range(len(hdu.columns)):
+        val.append(hdu.data.field(i))
+    hdulist.close()
+    del hdulist
     return val
 
-
 def mwrfits(filename,data,hdu=1,colnames=None,keys=None):
     """Write columns to a fits file in a table extension.
 
     Parameters
     ----------
     filename : str
       The fits file name
@@ -583,24 +388,24 @@
     # Check the inputs
     if colnames is not None:
         if len(colnames) != len(data):
             raise ValueError("colnames and data must the same length")
     else:
         colnames = ['']*len(data)
     cols=[]
-    for line in six.moves.xrange(len(data)):
+    for line in xrange(len(data)):
         cols.append(pf.Column(name=colnames[line],
                                format=getformat(data[line]),
                                array=data[line]))
     tbhdu = pf.new_table(cols)
     if type(keys) is dict:
         for k,v in keys.items():
             tbhdu.header.update(k,v)
     # write the file
-    writeto(tbhdu, filename)
+    tbhdu.writeto(filename,clobber=True)
 
 def getformat(t):
     """Get the FITS convention format string of data type t.
 
     Parameters
     ----------
     t : data type
@@ -654,7 +459,8 @@
         pass
     try:
         if type(t[0]) is str:
             l=max(len(s) for s in t)
             return 'A%d'%(l)
     except:
         pass
+
```

### Comparing `healpy-1.9.1/COPYING` & `healpy-github-devel/hpbeta/COPYING`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/sse_utils.h` & `healpy-github-devel/hpbeta/c_utils/sse_utils.h`

 * *Files 5% similar despite different names*

```diff
@@ -28,18 +28,22 @@
  *  Copyright (C) 2010,2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_SSE_UTILS_H
 #define PLANCK_SSE_UTILS_H
 
+#ifndef PLANCK_DISABLE_SSE
+
 #if (defined(__SSE__))
 
 #include <xmmintrin.h>
 
+#define PLANCK_HAVE_SSE
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 typedef __m128 v4sf; /* vector of 4 floats (SSE1) */
 
 typedef union {
@@ -65,14 +69,16 @@
 
 #endif
 
 #if (defined(__SSE2__))
 
 #include <emmintrin.h>
 
+#define PLANCK_HAVE_SSE2
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 typedef __m128d v2df; /* vector of 2 doubles (SSE2) */
 
 typedef union {
@@ -117,10 +123,14 @@
 
 #endif
 
 #if (defined(__SSE3__))
 
 #include <pmmintrin.h>
 
+#define PLANCK_HAVE_SSE3
+
+#endif
+
 #endif
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/c_utils/walltime_c.h` & `healpy-github-devel/hpbeta/libfftpack/bluestein.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,54 +1,48 @@
 /*
- *  This file is part of libc_utils.
+ *  This file is part of libfftpack.
  *
- *  libc_utils is free software; you can redistribute it and/or modify
+ *  libfftpack is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libc_utils is distributed in the hope that it will be useful,
+ *  libfftpack is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libc_utils; if not, write to the Free Software
+ *  along with libfftpack; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libc_utils is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libfftpack is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file walltime_c.h
- *  Functionality for reading wall clock time
- *
- *  Copyright (C) 2010 Max-Planck-Society
+/*
+ *  Copyright (C) 2005 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
-#ifndef PLANCK_WALLTIME_C_H
-#define PLANCK_WALLTIME_C_H
+#ifndef PLANCK_BLUESTEIN_H
+#define PLANCK_BLUESTEIN_H
+
+#include "c_utils.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-/*! Returns an approximation of the current wall time (in seconds).
-    The first available of the following timers will be used:
-    <ul>
-    <li> \a omp_get_wtime(), if OpenMP is available
-    <li> \a MPI_Wtime(), if MPI is available
-    <li> \a gettimeofday() otherwise
-    </ul>
-    \note Only useful for measuring time differences.
-    \note This function has an execution time between 10 and 100 nanoseconds. */
-double wallTime(void);
+size_t prime_factor_sum (size_t n);
+
+void bluestein_i (size_t n, double **tstorage, size_t *worksize);
+void bluestein (size_t n, double *data, double *tstorage, int isign);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_core.h` & `healpy-github-devel/hpbeta/libpsht/psht_almhelpers.h`

 * *Files 27% similar despite different names*

```diff
@@ -1,50 +1,57 @@
 /*
- *  This file is part of libsharp.
+ *  This file is part of libpsht.
  *
- *  libsharp is free software; you can redistribute it and/or modify
+ *  libpsht is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libsharp is distributed in the hope that it will be useful,
+ *  libpsht is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libsharp; if not, write to the Free Software
+ *  along with libpsht; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libsharp is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libpsht is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file sharp_core.h
- *  Interface for the computational core
+/*! \file psht_almhelpers.h
+ *  PSHT helper function for the creation of a_lm data structures
  *
- *  Copyright (C) 2012-2013 Max-Planck-Society
+ *  Copyright (C) 2008-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
-#ifndef PLANCK_SHARP_CORE_H
-#define PLANCK_SHARP_CORE_H
+#ifndef PLANCK_PSHT_ALMHELPERS_H
+#define PLANCK_PSHT_ALMHELPERS_H
 
-#include "sharp_internal.h"
-#include "sharp_ylmgen_c.h"
+#include "psht.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-void inner_loop (sharp_job *job, const int *ispair,const double *cth,
-  const double *sth, int llim, int ulim, sharp_Ylmgen_C *gen, int mi,
-  const int *mlim);
+/*! Initialises an a_lm data structure according to the scheme used by
+    Healpix_cxx.
+    \ingroup almgroup */
+void psht_make_triangular_alm_info (int lmax, int mmax, int stride,
+  psht_alm_info **alm_info);
+
+/*! Initialises an a_lm data structure according to the scheme used by
+    Fortran Healpix
+    \ingroup almgroup */
+void psht_make_rectangular_alm_info (int lmax, int mmax, int stride,
+  psht_alm_info **alm_info);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_almhelpers.c` & `healpy-github-devel/hpbeta/libpsht/psht_almhelpers.c`

 * *Files 12% similar despite different names*

```diff
@@ -1,70 +1,71 @@
 /*
- *  This file is part of libsharp.
+ *  This file is part of libpsht.
  *
- *  libsharp is free software; you can redistribute it and/or modify
+ *  libpsht is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libsharp is distributed in the hope that it will be useful,
+ *  libpsht is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libsharp; if not, write to the Free Software
+ *  along with libpsht; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libsharp is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libpsht is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file sharp_almhelpers.c
+/*! \file psht_almhelpers.c
  *  Spherical transform library
  *
- *  Copyright (C) 2008-2013 Max-Planck-Society
+ *  Copyright (C) 2008-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
-#include "sharp_almhelpers.h"
+#include "psht_almhelpers.h"
 #include "c_utils.h"
 
-void sharp_make_triangular_alm_info (int lmax, int mmax, int stride,
-  sharp_alm_info **alm_info)
+void psht_make_triangular_alm_info (int lmax, int mmax, int stride,
+  psht_alm_info **alm_info)
   {
-  sharp_alm_info *info = RALLOC(sharp_alm_info,1);
+  ptrdiff_t m;
+  int tval;
+  psht_alm_info *info = RALLOC(psht_alm_info,1);
   info->lmax = lmax;
   info->nm = mmax+1;
   info->mval = RALLOC(int,mmax+1);
   info->mvstart = RALLOC(ptrdiff_t,mmax+1);
   info->stride = stride;
-  info->flags = 0;
-  ptrdiff_t tval = 2*lmax+1;
-  for (ptrdiff_t m=0; m<=mmax; ++m)
+  tval = 2*lmax+1;
+  for (m=0; m<=mmax; ++m)
     {
     info->mval[m] = m;
     info->mvstart[m] = stride*((m*(tval-m))>>1);
     }
   *alm_info = info;
   }
 
-void sharp_make_rectangular_alm_info (int lmax, int mmax, int stride,
-  sharp_alm_info **alm_info)
+void psht_make_rectangular_alm_info (int lmax, int mmax, int stride,
+  psht_alm_info **alm_info)
   {
-  sharp_alm_info *info = RALLOC(sharp_alm_info,1);
+  ptrdiff_t m;
+  psht_alm_info *info = RALLOC(psht_alm_info,1);
   info->lmax = lmax;
   info->nm = mmax+1;
   info->mval = RALLOC(int,mmax+1);
   info->mvstart = RALLOC(ptrdiff_t,mmax+1);
   info->stride = stride;
-  info->flags = 0;
-  for (ptrdiff_t m=0; m<=mmax; ++m)
+  for (m=0; m<=mmax; ++m)
     {
     info->mval[m] = m;
     info->mvstart[m] = stride*m*(lmax+1);
     }
   *alm_info = info;
   }
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_internal.h` & `healpy-github-devel/hpbeta/libfftpack/fftpack.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,66 +1,64 @@
 /*
- *  This file is part of libsharp.
+ *  This file is part of libfftpack.
  *
- *  libsharp is free software; you can redistribute it and/or modify
+ *  libfftpack is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libsharp is distributed in the hope that it will be useful,
+ *  libfftpack is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libsharp; if not, write to the Free Software
+ *  along with libfftpack; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libsharp is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libfftpack is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file sharp_internal.h
- *  Internally used functionality for the spherical transform library.
- *
- *  Copyright (C) 2006-2013 Max-Planck-Society
- *  \author Martin Reinecke \author Dag Sverre Seljebotn
+/*
+  fftpack.h : function declarations for fftpack.c
+  Algorithmically based on Fortran-77 FFTPACK by Paul N. Swarztrauber
+  (Version 4, 1985).
+
+  Pekka Janhunen 23.2.1995
+
+  (reformatted by joerg arndt)
+
+  reformatted and slightly enhanced by Martin Reinecke (2004)
  */
 
-#ifndef PLANCK_SHARP_INTERNAL_H
-#define PLANCK_SHARP_INTERNAL_H
+#ifndef PLANCK_FFTPACK_H
+#define PLANCK_FFTPACK_H
+
+#include "c_utils.h"
 
 #ifdef __cplusplus
-#error This header file cannot be included from C++, only from C
+extern "C" {
 #endif
 
-#include "sharp.h"
-
-#define SHARP_MAXTRANS 100
+/*! forward complex transform */
+void cfftf(size_t N, double complex_data[], double wrk[]);
+/*! backward complex transform */
+void cfftb(size_t N, double complex_data[], double wrk[]);
+/*! initializer for complex transforms */
+void cffti(size_t N, double wrk[]);
+
+/*! forward real transform */
+void rfftf(size_t N, double data[], double wrk[]);
+/*! backward real transform */
+void rfftb(size_t N, double data[], double wrk[]);
+/*! initializer for real transforms */
+void rffti(size_t N, double wrk[]);
 
-typedef struct
-  {
-  sharp_jobtype type;
-  int spin;
-  int nmaps, nalm;
-  int flags;
-  void **map;
-  void **alm;
-  int s_m, s_th; // strides in m and theta direction
-  complex double *phase;
-  double *norm_l;
-  complex double *almtmp;
-  const sharp_geom_info *ginfo;
-  const sharp_alm_info *ainfo;
-  double time;
-  int ntrans;
-  unsigned long long opcnt;
-  } sharp_job;
-
-int sharp_get_nv_max (void);
-int sharp_nv_oracle (sharp_jobtype type, int spin, int ntrans);
-int sharp_get_mlim (int lmax, int spin, double sth, double cth);
+#ifdef __cplusplus
+}
+#endif
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_almhelpers.h` & `healpy-github-devel/hpbeta/cxxsupport/alloc_utils.h`

 * *Files 27% similar despite different names*

```diff
@@ -1,57 +1,73 @@
 /*
- *  This file is part of libsharp.
+ *  This file is part of libcxxsupport.
  *
- *  libsharp is free software; you can redistribute it and/or modify
+ *  libcxxsupport is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libsharp is distributed in the hope that it will be useful,
+ *  libcxxsupport is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libsharp; if not, write to the Free Software
+ *  along with libcxxsupport; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libsharp is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file sharp_almhelpers.h
- *  SHARP helper function for the creation of a_lm data structures
+/*! \file alloc_utils.h
+ *  Classes providing raw memory allocation and deallocation support.
  *
- *  Copyright (C) 2008-2011 Max-Planck-Society
+ *  Copyright (C) 2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
-#ifndef PLANCK_SHARP_ALMHELPERS_H
-#define PLANCK_SHARP_ALMHELPERS_H
+#ifndef PLANCK_ALLOC_UTILS_H
+#define PLANCK_ALLOC_UTILS_H
 
-#include "sharp_lowlevel.h"
+#include <cstdlib>
+#include "datatypes.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*! Initialises an a_lm data structure according to the scheme used by
-    Healpix_cxx.
-    \ingroup almgroup */
-void sharp_make_triangular_alm_info (int lmax, int mmax, int stride,
-  sharp_alm_info **alm_info);
-
-/*! Initialises an a_lm data structure according to the scheme used by
-    Fortran Healpix
-    \ingroup almgroup */
-void sharp_make_rectangular_alm_info (int lmax, int mmax, int stride,
-  sharp_alm_info **alm_info);
-
-#ifdef __cplusplus
-}
+template <typename T> class normalAlloc__
+  {
+  public:
+    T *alloc(tsize sz) const { return (sz>0) ? new T[sz] : 0; }
+    void dealloc (T *ptr) const { delete[] ptr; }
+  };
+
+template <typename T, int align> class alignAlloc__
+  {
+  public:
+    T *alloc(tsize sz) const
+      {
+      using namespace std;
+      if (sz==0) return 0;
+      planck_assert((align&(align-1))==0,"alignment must be power of 2");
+      void *res;
+/* OSX up to version 10.5 does not define posix_memalign(), but fortunately
+   the normal malloc() returns 16 byte aligned storage */
+#ifdef __APPLE__
+      planck_assert(align<=16, "bad alignment requested");
+      res=malloc(sz*sizeof(T));
+      planck_assert(res!=0,"error in malloc()");
+#else
+      planck_assert(posix_memalign(&res,align,sz*sizeof(T))==0,
+        "error in posix_memalign()");
 #endif
+      return static_cast<T *>(res);
+      }
+    void dealloc(T *ptr) const
+      {
+      using namespace std;
+      free(ptr);
+      }
+  };
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/libsharp.dox` & `healpy-github-devel/hpbeta/libpsht/libpsht.dox`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-/*! \mainpage libsharp documentation
+/*! \mainpage libpsht documentation
   <ul>
   <li>\ref introduction "Introduction"
   <li><a href="modules.html">Programming interface</a>
   </ul>
  */
 
-/*! \page introduction Introduction to libsharp
+/*! \page introduction Introduction to libpsht
 
-  "SHARP" is an acronym for <i>Spherical HARmonic Package</i>.
+  "PSHT" is an acronym for <i>Performant Spherical Harmonic Transforms</i>.
   All user-visible data types and functions in this library start with
-  the prefix "sharp_" to avoid pollution of the global C namespace.
+  the prefix "psht_", or with "pshts_" and "pshtd_" for single- and
+  double precision variants, respectively.
 
-  <i>libsharp</i>'s main functionality is the conversion between <i>maps</i>
+  <i>libpsht</i>'s main functionality is the conversion between <i>maps</i>
   on the sphere and <i>spherical harmonic coefficients</i> (or <i>a_lm</i>).
   A map is defined as a set of <i>rings</i>, which in turn consist of
   individual pixels that
   <ul>
   <li>all have the same colatitude and</li>
   <li>are uniformly spaced in azimuthal direction.</li>
   </ul>
@@ -31,55 +32,75 @@
   </ul>
   The map array is a one-dimensional array of type <i>float</i> or
   <i>double</i>, which contains the values of all map pixels. It is assumed
   that the pixels of every ring are stored inside this array in order of
   increasing azimuth and with the specified stride. Note however that the rings
   themselves can be stored in any order inside the array.
 
-  The a_lm array is a one-dimensional array of type <i>complex float</i> or
-  <i>complex double</i>, which contains all spherical harmonic coefficients
+  The a_lm array is a one-dimensional array of type <i>pshts_cmplx</i> or
+  <i>pshtd_cmplx</i>, which contains all spherical harmonic coefficients
   for a full or partial set of m quantum numbers with 0<=m<=mmax and m<=l<=lmax.
   There is only one constraint on the internal structure of the array, which is:
 
   <code>Index[a_l+1,m] = Index[a_l,m] + stride</code>
 
   That means that coefficients with identical <i>m</i> but different <i>l</i>
   can be interpreted as a one-dimensional array in <i>l</i> with a unique
   stride.
 
   Several functions are provided for efficient index computation in this array;
   they are documented \ref almgroup "here".
 
   Information about a pixelisation of the sphere is stored in objects of
-  type sharp_geom_info. It is possible to create such an object for any
-  supported pixelisation by using the function sharp_make_geometry_info();
+  type psht_geom_info. It is possible to create such an object for any
+  supported pixelisation by using the function psht_make_geometry_info();
   however, several easier-to-use functions are \ref geominfogroup "supplied"
   for generating often-used pixelisations like ECP grids, Gaussian grids,
   and Healpix grids.
 
-  Currently, libsharp supports the following kinds of transforms:
+  A distinctive feature of PSHT is the ability to execute several transforms
+  simultaneously (as long as they have the same geometry information and
+  a_lm structure); this has the advantage that the spherical
+  harmonics only have to be evaluated once for all of the transforms, saving
+  a substantial amount of CPU time. The set of functions dealing with such
+  <i>job lists</i> is implemented twice, both for \ref sjoblistgroup "single"
+  and \ref djoblistgroup "double" precision transforms.
+
+  Currently, PSHT supports the following kinds of transforms:
   <ul>
   <li>scalar a_lm to map</li>
   <li>scalar map to a_lm</li>
-<!--  <li>polarised a_lm to map</li>
-  <li>polarised map to a_lm</li> !-->
+  <li>polarised a_lm to map</li>
+  <li>polarised map to a_lm</li>
   <li>spin a_lm to map</li>
   <li>spin map to a_lm</li>
   <li>scalar a_lm to maps of first derivatives</li>
   </ul>
 
-  libsharp supports shared-memory parallelisation via OpenMP; this feature will
+  All these different kinds can be mixed freely within a job list; i.e., it is
+  possible to perform an a_lm->map and a map->a_lm transform simultaneously.
+
+  PSHT supports shared-memory parallelisation via OpenMP; this feature will
   be automatically enabled if the compiler supports it.
 
-  Libsharp will also make use of SSE2 and AVX instructions when compiled for a
-  platform known to support them.
+  PSHT will also make use of SSE2 instructions when compiled for a platform
+  known to support them (basically all Intel/AMD processors running a 64bit
+  operating system).
 
-  Support for MPI-parallel transforms is also available; in this mode,
+  Experimental support for MPI-parallel transforms is available; in this mode,
   every MPI task must provide a unique subset of the map and a_lm coefficients.
 
-  The spherical harmonic transforms can be executed on double-precision and
+  The spherical harmonic transforms can ce executed on double-precision and
   single-precision maps and a_lm, but for accuracy reasons the computations
   will always be performed in double precision. As a consequence,
   single-precision transforms will most likely not be faster than their
   double-precision counterparts, but they will require significantly less
   memory.
+
+  Two example and benchmark programs are distributed with PSHT:
+  <ul>
+  <li>psht_test.c checks the accuracy of the (iterative) map analysis
+      algorithm</li>
+  <li>psht_perftest.c checks the performance of single or multiple
+      transforms</li>
+  </ul>
 */
```

#### html2text {}

```diff
@@ -1,16 +1,17 @@
-/*! \mainpage libsharp documentation
+/*! \mainpage libpsht documentation
     * \ref introduction "Introduction"
     * _P_r_o_g_r_a_m_m_i_n_g_ _i_n_t_e_r_f_a_c_e
-*/ /*! \page introduction Introduction to libsharp "SHARP" is an acronym for
-Spherical HARmonic Package. All user-visible data types and functions in this
-library start with the prefix "sharp_" to avoid pollution of the global C
-namespace. libsharp's main functionality is the conversion between maps on the
-sphere and spherical harmonic coefficients (or a_lm). A map is defined as a set
-of rings, which in turn consist of individual pixels that
+*/ /*! \page introduction Introduction to libpsht "PSHT" is an acronym for
+Performant Spherical Harmonic Transforms. All user-visible data types and
+functions in this library start with the prefix "psht_", or with "pshts_" and
+"pshtd_" for single- and double precision variants, respectively. libpsht's
+main functionality is the conversion between maps on the sphere and spherical
+harmonic coefficients (or a_lm). A map is defined as a set of rings, which in
+turn consist of individual pixels that
     * all have the same colatitude and
     * are uniformly spaced in azimuthal direction.
 Consequently, a ring is completely defined by
     * its colatitute (in radians)
     * the number of pixels it contains
     * the azimuth (in radians) of the first pixel in the ring
     * the weight that must be multiplied to every pixel during a map analysis
@@ -18,35 +19,50 @@
     * the offset of the first ring pixel in the map array
     * the stride between consecutive pixels in the ring.
 The map array is a one-dimensional array of type float or double, which
 contains the values of all map pixels. It is assumed that the pixels of every
 ring are stored inside this array in order of increasing azimuth and with the
 specified stride. Note however that the rings themselves can be stored in any
 order inside the array. The a_lm array is a one-dimensional array of type
-complex float or complex double, which contains all spherical harmonic
-coefficients for a full or partial set of m quantum numbers with 0<=m<=mmax and
-m<=l<=lmax. There is only one constraint on the internal structure of the
-array, which is: Index[a_l+1,m] = Index[a_l,m] + stride That means that
-coefficients with identical m but different l can be interpreted as a one-
-dimensional array in l with a unique stride. Several functions are provided for
-efficient index computation in this array; they are documented \ref almgroup
-"here". Information about a pixelisation of the sphere is stored in objects of
-type sharp_geom_info. It is possible to create such an object for any supported
-pixelisation by using the function sharp_make_geometry_info(); however, several
+pshts_cmplx or pshtd_cmplx, which contains all spherical harmonic coefficients
+for a full or partial set of m quantum numbers with 0<=m<=mmax and m<=l<=lmax.
+There is only one constraint on the internal structure of the array, which is:
+Index[a_l+1,m] = Index[a_l,m] + stride That means that coefficients with
+identical m but different l can be interpreted as a one-dimensional array in l
+with a unique stride. Several functions are provided for efficient index
+computation in this array; they are documented \ref almgroup "here".
+Information about a pixelisation of the sphere is stored in objects of type
+psht_geom_info. It is possible to create such an object for any supported
+pixelisation by using the function psht_make_geometry_info(); however, several
 easier-to-use functions are \ref geominfogroup "supplied" for generating often-
-used pixelisations like ECP grids, Gaussian grids, and Healpix grids.
-Currently, libsharp supports the following kinds of transforms:
+used pixelisations like ECP grids, Gaussian grids, and Healpix grids. A
+distinctive feature of PSHT is the ability to execute several transforms
+simultaneously (as long as they have the same geometry information and a_lm
+structure); this has the advantage that the spherical harmonics only have to be
+evaluated once for all of the transforms, saving a substantial amount of CPU
+time. The set of functions dealing with such job lists is implemented twice,
+both for \ref sjoblistgroup "single" and \ref djoblistgroup "double" precision
+transforms. Currently, PSHT supports the following kinds of transforms:
     * scalar a_lm to map
     * scalar map to a_lm
+    * polarised a_lm to map
+    * polarised map to a_lm
     * spin a_lm to map
     * spin map to a_lm
     * scalar a_lm to maps of first derivatives
-libsharp supports shared-memory parallelisation via OpenMP; this feature will
-be automatically enabled if the compiler supports it. Libsharp will also make
-use of SSE2 and AVX instructions when compiled for a platform known to support
-them. Support for MPI-parallel transforms is also available; in this mode,
-every MPI task must provide a unique subset of the map and a_lm coefficients.
-The spherical harmonic transforms can be executed on double-precision and
-single-precision maps and a_lm, but for accuracy reasons the computations will
-always be performed in double precision. As a consequence, single-precision
-transforms will most likely not be faster than their double-precision
-counterparts, but they will require significantly less memory. */
+All these different kinds can be mixed freely within a job list; i.e., it is
+possible to perform an a_lm->map and a map->a_lm transform simultaneously. PSHT
+supports shared-memory parallelisation via OpenMP; this feature will be
+automatically enabled if the compiler supports it. PSHT will also make use of
+SSE2 instructions when compiled for a platform known to support them (basically
+all Intel/AMD processors running a 64bit operating system). Experimental
+support for MPI-parallel transforms is available; in this mode, every MPI task
+must provide a unique subset of the map and a_lm coefficients. The spherical
+harmonic transforms can ce executed on double-precision and single-precision
+maps and a_lm, but for accuracy reasons the computations will always be
+performed in double precision. As a consequence, single-precision transforms
+will most likely not be faster than their double-precision counterparts, but
+they will require significantly less memory. Two example and benchmark programs
+are distributed with PSHT:
+    * psht_test.c checks the accuracy of the (iterative) map analysis algorithm
+    * psht_perftest.c checks the performance of single or multiple transforms
+*/
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libsharp/sharp_vecutil.h` & `healpy-github-devel/hpbeta/cxxsupport/pointing.cc`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,64 @@
 /*
- *  This file is part of libc_utils.
+ *  This file is part of libcxxsupport.
  *
- *  libc_utils is free software; you can redistribute it and/or modify
+ *  libcxxsupport is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libc_utils is distributed in the hope that it will be useful,
+ *  libcxxsupport is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libc_utils; if not, write to the Free Software
+ *  along with libcxxsupport; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /*
- *  libc_utils is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file sharp_vecutil.h
- *  Functionality related to vector instruction support
+/*! \file pointing.cc
+ *  Class representing a direction in 3D space
  *
- *  Copyright (C) 2012 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
-#ifndef SHARP_VECUTIL_H
-#define SHARP_VECUTIL_H
+#include "pointing.h"
+#include "lsconstants.h"
+#include "math_utils.h"
 
-#if (defined (__AVX__))
-#define VLEN 4
-#elif (defined (__SSE2__))
-#define VLEN 2
-#else
-#define VLEN 1
-#endif
+using namespace std;
 
-#endif
+vec3 pointing::to_vec3() const
+  {
+  double st=sin(theta);
+  return vec3 (st*cos(phi), st*sin(phi), cos(theta));
+  }
+void pointing::from_vec3 (const vec3 &inp)
+  {
+  theta = atan2(sqrt(inp.x*inp.x+inp.y*inp.y),inp.z);
+  phi = safe_atan2 (inp.y,inp.x);
+  if (phi<0.) phi += twopi;
+  }
+void pointing::normalize()
+  {
+  theta=fmodulo(theta,twopi);
+  if (theta>pi)
+    {
+    phi+=pi;
+    theta=twopi-theta;
+    }
+  phi=fmodulo(phi,twopi);
+  }
+
+ostream &operator<< (ostream &os, const pointing &p)
+  {
+  os << p.theta << ", " << p.phi << std::endl;
+  return os;
+  }
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/fitshandle.h` & `healpy-github-devel/hpbeta/cxxsupport/fitshandle.h`

 * *Files 6% similar despite different names*

```diff
@@ -21,15 +21,15 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file fitshandle.h
  *  Declaration of the FITS I/O helper class used by LevelS
  *
- *  Copyright (C) 2002-2014 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_FITSHANDLE_H
 #define PLANCK_FITSHANDLE_H
 
 #include <string>
@@ -219,57 +219,39 @@
       (int colnum, T *data, int64 num, int64 offset=0) const
       { read_column_raw_void (colnum, data, planckType<T>(), num, offset); }
     /*! Fills \a data with elements from column \a colnum,
         starting at offset \a offset in the column. */
     template<typename T> void read_column
       (int colnum, arr<T> &data, int64 offset=0) const
       { read_column_raw (colnum, &(data[0]), data.size(), offset); }
-    /*! Fills \a data with elements from column \a colnum,
-        starting at offset \a offset in the column. */
-    template<typename T> void read_column
-      (int colnum, std::vector<T> &data, int64 offset=0) const
-      { read_column_raw (colnum, &(data[0]), data.size(), offset); }
     /*! Reads the element \a #offset from column \a colnum into \a data. */
     template<typename T> void read_column
       (int colnum, T &data, int64 offset=0) const
       { read_column_raw (colnum, &data, 1, offset); }
     /*! Reads the whole column \a colnum into \a data (which is resized
        accordingly). */
     template<typename T> void read_entire_column
       (int colnum, arr<T> &data) const
       {
       data.alloc(safe_cast<tsize>(nelems(colnum)));
       read_column (colnum, data);
       }
-    /*! Reads the whole column \a colnum into \a data (which is resized
-       accordingly). */
-    template<typename T> void read_entire_column
-      (int colnum, std::vector<T> &data) const
-      {
-      data.resize(safe_cast<tsize>(nelems(colnum)));
-      read_column (colnum, data);
-      }
 
     void write_column_raw_void
       (int colnum, const void *data, PDT type, int64 num, int64 offset=0);
     /*! Copies \a num elements from the memory pointed to by \a data to the
         column \a colnum, starting at offset \a offset in the column. */
     template<typename T> void write_column_raw
       (int colnum, const T *data, int64 num, int64 offset=0)
       { write_column_raw_void (colnum, data, planckType<T>(), num, offset); }
     /*! Copies all elements from \a data to the
         column \a colnum, starting at offset \a offset in the column. */
     template<typename T> void write_column
       (int colnum, const arr<T> &data, int64 offset=0)
       { write_column_raw (colnum, &(data[0]), data.size(), offset); }
-    /*! Copies all elements from \a data to the
-        column \a colnum, starting at offset \a offset in the column. */
-    template<typename T> void write_column
-      (int colnum, const std::vector<T> &data, int64 offset=0)
-      { write_column_raw (colnum, &(data[0]), data.size(), offset); }
     /*! Copies \a data to the column \a colnum, at the position \a offset. */
     template<typename T> void write_column
       (int colnum, const T &data, int64 offset=0)
       { write_column_raw (colnum, &data, 1, offset); }
 
     /*! \} */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/announce.h` & `healpy-github-devel/hpbeta/cxxsupport/error_handling.h`

 * *Files 27% similar despite different names*

```diff
@@ -18,39 +18,83 @@
 
 /*
  *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file announce.h
- *  Functions for printing information at startup.
+/*
+ *  Utilities for error reporting
  *
- *  Copyright (C) 2002-2011 Max-Planck-Society
- *  \author Martin Reinecke
+ *  Copyright (C) 2003-2011 Max-Planck-Society
+ *  Authors: Reinhard Hell, Martin Reinecke
  */
 
-#ifndef PLANCK_ANNOUNCE_H
-#define PLANCK_ANNOUNCE_H
+#ifndef PLANCK_ERROR_HANDLING_H
+#define PLANCK_ERROR_HANDLING_H
 
 #include <string>
+#include <iostream>
+
+#if defined (__GNUC__)
+#define PLANCK_FUNC_NAME__ __PRETTY_FUNCTION__
+#else
+#define PLANCK_FUNC_NAME__ 0
+#endif
+
+void planck_failure__(const char *file, int line, const char *func,
+  const std::string &msg);
+void planck_failure__(const char *file, int line, const char *func,
+  const char *msg);
+void killjob__();
+
+class PlanckError
+  {
+  private:
+    std::string msg;
+
+  public:
+    explicit PlanckError(const std::string &message);
+    explicit PlanckError(const char *message);
+
+    virtual const char* what() const
+      { return msg.c_str(); }
+
+    virtual ~PlanckError();
+  };
+
+/*! \defgroup errorgroup Error handling */
+/*! \{ */
+
+/*! Writes diagnostic output and exits with an error status. */
+#define planck_fail(msg) \
+do { planck_failure__(__FILE__,__LINE__,PLANCK_FUNC_NAME__,msg); \
+throw PlanckError(msg); } while(0)
+
+/*! Throws a PlanckError without diagnostic message. */
+#define planck_fail_quietly(msg) \
+do { throw PlanckError(msg); } while(0)
+
+/*! Writes diagnostic output and exits with an error status if \a testval
+    is \a false. */
+#define planck_assert(testval,msg) \
+do { if (testval); else planck_fail(msg); } while(0)
+
+/*! Macro for improving error diagnostics. Should be placed immediately
+    after the opening brace of \c main(). Must be used in conjunction with
+    \c PLANCK_DIAGNOSIS_END. */
+#define PLANCK_DIAGNOSIS_BEGIN try {
+/*! Macro for improving error diagnostics. Should be placed immediately
+    before the closing brace of \c main(). Must be used in conjunction with
+    \c PLANCK_DIAGNOSIS_BEGIN. */
+#define PLANCK_DIAGNOSIS_END \
+} \
+catch (PlanckError &) \
+  { killjob__(); /* no need for further diagnostics; they were shown already */ } \
+catch (std::exception &e) \
+  { std::cerr << "std::exception: " << e.what() << std::endl; killjob__(); } \
+catch (...) \
+  { std::cerr << "Unknown exception" << std::endl; killjob__(); }
 
-/*! Prints a banner containing \a name, as well as some information about the
-    source code and the parallelisation techniques enabled. */
-void announce (const std::string &name);
-
-/*! Prints a banner containing \a name and checks if \a argc_valid is true.
-    If not, the string \a usage is printed and the program is terminated. */
-void module_startup (const std::string &name, bool argc_valid,
-  const std::string &usage, bool verbose=true);
-
-/*! Prints a banner containing \a name and checks if \a argc==argc_expected.
-    If not, a usage description is given and the program is terminated. */
-void module_startup (const std::string &name, int argc, const char **argv,
-  int argc_expected, const std::string &argv_expected, bool verbose=true);
-
-/*! Prints a banner containing \a name and checks if \a argc>=2.
-    If not, a usage description is given and the program is terminated. */
-void module_startup (const std::string &name, int argc, const char **argv,
-  bool verbose=true);
+/*! \} */
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/ls_image.h` & `healpy-github-devel/hpbeta/Healpix_cxx/alm.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,159 +1,169 @@
 /*
- *  This file is part of libcxxsupport.
+ *  This file is part of Healpix_cxx.
  *
- *  libcxxsupport is free software; you can redistribute it and/or modify
+ *  Healpix_cxx is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
- *  libcxxsupport is distributed in the hope that it will be useful,
+ *  Healpix_cxx is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with libcxxsupport; if not, write to the Free Software
+ *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
- *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
+ *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file ls_image.h
- *  Classes for creation and output of image files
+/*! \file alm.h
+ *  Class for storing spherical harmonic coefficients.
  *
- *  Copyright (C) 2003-2015 Max-Planck-Society
- *  \author Martin Reinecke, David Larson
+ *  Copyright (C) 2003-2011 Max-Planck-Society
+ *  \author Martin Reinecke
  */
 
-#ifndef PLANCK_LS_IMAGE_H
-#define PLANCK_LS_IMAGE_H
+#ifndef PLANCK_ALM_H
+#define PLANCK_ALM_H
 
-#include <string>
-#include <vector>
-#include <iostream>
-#include <algorithm>
 #include "arr.h"
-#include "datatypes.h"
-#include "colour.h"
-#include "linear_map.h"
-
-/*! \defgroup imagegroup Image creation */
-/*! \{ */
 
-/*! A class for mapping floting-point values into colours. */
-class Palette: public linearMap<Colour>
+/*! Base class for calculating the storage layout of spherical harmonic
+    coefficients. */
+class Alm_Base
   {
+  protected:
+    int lmax, mmax, tval;
+
   public:
-    /*! Adds a new data point \a f, with the corresponding colour \a c.
-        The additions must be done in the order of ascending \a f. */
-    void add (float f, const Colour &c)
-      { addVal (f, c); }
-    void addb (uint8 f, uint8 r,uint8 g, uint8 b)
-      { addVal (f, Colour(r/255.,g/255.,b/255.)); }
-    /*! Sets the palette to the predefined palette \a num. */
-    void setPredefined(int num);
-    /*! Returns the colour corresponding to the value \a f. The colour is
-        determined by linear interpolation between neighbouring data points. */
-    Colour Get_Colour (float f) const
-      { return getVal_const(f); }
-  };
+    /*! Returns the total number of coefficients for maximum quantum numbers
+        \a l and \a m. */
+    static tsize Num_Alms (int l, int m);
+
+    /*! Constructs an Alm_Base object with given \a lmax and \a mmax. */
+    Alm_Base (int lmax_=0, int mmax_=0)
+      : lmax(lmax_), mmax(mmax_), tval(2*lmax+1) {}
 
-class Colour8
-  {
-  private:
-    void import (const Colour &col)
+    /*! Changes the object's maximum quantum numbers to \a lmax and \a mmax. */
+    void Set (int lmax_, int mmax_)
       {
-      using namespace std;
-      r = uint8(max(0,min(255,int(col.r*256))));
-      g = uint8(max(0,min(255,int(col.g*256))));
-      b = uint8(max(0,min(255,int(col.b*256))));
+      lmax=lmax_;
+      mmax=mmax_;
+      tval=2*lmax+1;
       }
 
-  public:
-    uint8 r,g,b;
+    /*! Returns the maximum \a l */
+    int Lmax() const { return lmax; }
+    /*! Returns the maximum \a m */
+    int Mmax() const { return mmax; }
+
+    /*! Returns an array index for a given m, from which the index of a_lm
+        can be obtained by adding l. */
+    int index_l0 (int m) const
+      { return ((m*(tval-m))>>1); }
+
+    /*! Returns the array index of the specified coefficient. */
+    int index (int l, int m) const
+      { return index_l0(m) + l; }
+
+    /*! Returns \a true, if both objects have the same \a lmax and \a mmax,
+        else  \a false. */
+    bool conformable (const Alm_Base &other) const
+      { return ((lmax==other.lmax) && (mmax==other.mmax)); }
 
-    Colour8() {}
-    Colour8 (uint8 R, uint8 G, uint8 B)
-      : r(R), g(G), b(B) {}
-    Colour8 (const Colour &col)
-      { import (col); }
-    const Colour8 &operator= (const Colour &col)
-      { import (col); return *this; }
-    bool operator== (const Colour8 &that)
-      { return (r == that.r) && (g == that.g) && (b == that.b); }
-    bool operator!= (const Colour8 &that)
-      { return (r != that.r) || (g != that.g) || (b != that.b); }
+    /*! Swaps the contents of two Alm_Base objects. */
+    void swap (Alm_Base &other);
   };
 
-class MP_Font
-  {
-  public:
-    int offset, num_chars, xpix, ypix;
-    const char *data;
-  };
-
-extern const MP_Font medium_bold_font;
-extern const MP_Font giant_font;
-
-/*! Class for creating and storing image files. */
-class LS_Image
+/*! Class for storing spherical harmonic coefficients. */
+template<typename T> class Alm: public Alm_Base
   {
   private:
-    MP_Font font;
-    arr2<Colour8> pixel;
-
-    void write_char (int xpos, int ypos, const Colour &col, char c,
-                     int scale=1);
+    arr<T> alm;
 
   public:
-    /*! */
-    LS_Image ();
-    /*! Creates an image object with a resolution of \a xres by \a yres. */
-    LS_Image (int xres, int yres);
-    /*! */
-    ~LS_Image () {}
-
-    /*! Fills the entire image with colour \a col. */
-    void fill (const Colour &col) { pixel.fill(col); }
-    /*! Sets the font used for annotations to \a fnt. */
-    void set_font (const MP_Font &fnt);
-    /*! Outputs the string \a text in colour \a col.
-        \a xpos, \a ypos is the lower left corner;
-        the font is scaled by \a scale. */
-    void annotate (int xpos, int ypos, const Colour &col,
-      const std::string &text, int scale=1);
-    /*! Outputs the string \a text centered at position \a xpos, \a ypos
-        in colour \a col. The font is scaled by \a scale. */
-    void annotate_centered (int xpos, int ypos, const Colour &col,
-      const std::string &text, int scale=1);
-    /*! Sets the pixel \a i, \a j, to the colour \a col. */
-    void put_pixel (tsize i, tsize j, const Colour &col)
-      {
-      if ((i<pixel.size1()) && (j<pixel.size2()))
-        pixel[i][j] = col;
-      }
-    /*! Returns the colour of the pixel \a i, \a j, or black if the pixel
-        lies outside of the image. */
-    Colour8 get_pixel (tsize i, tsize j)
-      {
-      return ((i<pixel.size1()) && (j<pixel.size2())) ?
-        pixel[i][j] : Colour8(0, 0, 0);
+    /*! Constructs an Alm object with given \a lmax and \a mmax. */
+    Alm (int lmax_=0, int mmax_=0)
+      : Alm_Base(lmax_,mmax_), alm (Num_Alms(lmax,mmax)) {}
+
+    /*! Deletes the old coefficients and allocates storage according to
+        \a lmax and \a mmax. */
+    void Set (int lmax_, int mmax_)
+      {
+      Alm_Base::Set(lmax_, mmax_);
+      alm.alloc(Num_Alms(lmax,mmax));
       }
 
-    /*! Writes the image to \a file in uncompressed TGA format. */
-    void write_TGA (const std::string &file) const;
+    /*! Deallocates the old coefficients and uses the content of \a data
+        for storage. \a data is deallocated during the call. */
+    void Set (arr<T> &data, int lmax_, int mmax_)
+      {
+      planck_assert (Num_Alms(lmax_,mmax_)==data.size(),"wrong array size");
+      Alm_Base::Set(lmax_, mmax_);
+      alm.transfer(data);
+      }
 
-    /*! Writes the image to \a file in run-length encoded TGA format. */
-    void write_TGA_rle (const std::string &file) const;
+    /*! Sets all coefficients to zero. */
+    void SetToZero ()
+      { alm.fill (0); }
+
+    /*! Multiplies all coefficients by \a factor. */
+    template<typename T2> void Scale (const T2 &factor)
+      { for (tsize m=0; m<alm.size(); ++m) alm[m]*=factor; }
+    /*! \a a(l,m) *= \a factor[l] for all \a l,m. */
+    template<typename T2> void ScaleL (const arr<T2> &factor)
+      {
+      planck_assert(factor.size()>tsize(lmax),
+        "alm.ScaleL: factor array too short");
+      for (int m=0; m<=mmax; ++m)
+        for (int l=m; l<=lmax; ++l)
+          operator()(l,m)*=factor[l];
+      }
+    /*! Adds \a num to a_00. */
+    template<typename T2> void Add (const T2 &num)
+      { alm[0]+=num; }
+
+    /*! Returns a reference to the specified coefficient. */
+    T &operator() (int l, int m)
+      { return alm[index(l,m)]; }
+    /*! Returns a constant reference to the specified coefficient. */
+    const T &operator() (int l, int m) const
+      { return alm[index(l,m)]; }
+
+    /*! Returns a pointer for a given m, from which the address of a_lm
+        can be obtained by adding l. */
+    T *mstart (int m)
+      { return &alm[index_l0(m)]; }
+    /*! Returns a pointer for a given m, from which the address of a_lm
+        can be obtained by adding l. */
+    const T *mstart (int m) const
+      { return &alm[index_l0(m)]; }
 
-    /*! Writes the image to \a file in binary PPM format. */
-    void write_PPM (const std::string &file) const;
-  };
+    /*! Returns a constant reference to the a_lm data. */
+    const arr<T> &Alms () const { return alm; }
 
-/*! \} */
+    /*! Swaps the contents of two Alm objects. */
+    void swap (Alm &other)
+      {
+      Alm_Base::swap(other);
+      alm.swap(other.alm);
+      }
+
+    /*! Adds all coefficients from \a other to the own coefficients. */
+    void Add (const Alm &other)
+      {
+      planck_assert (conformable(other), "A_lm are not conformable");
+      for (tsize m=0; m<alm.size(); ++m)
+        alm[m] += other.alm[m];
+      }
+  };
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/geom_utils.h` & `healpy-github-devel/hpbeta/cxxsupport/geom_utils.h`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/trafos.h` & `healpy-github-devel/hpbeta/cxxsupport/trafos.h`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/math_utils.h` & `healpy-github-devel/hpbeta/cxxsupport/math_utils.h`

 * *Files 21% similar despite different names*

```diff
@@ -21,40 +21,39 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file math_utils.h
  *  Various convenience mathematical functions.
  *
- *  Copyright (C) 2002-2015 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_MATH_UTILS_H
 #define PLANCK_MATH_UTILS_H
 
 #include <cmath>
-#include <algorithm>
 #include "datatypes.h"
 
 /*! \defgroup mathutilsgroup Mathematical helper functions */
 /*! \{ */
 
-/*! Returns \e true if | \a a-b | <= \a epsilon * | \a b |, else \e false. */
+/*! Returns \e true if | \a a-b | < \a epsilon * | \a b |, else \e false. */
 template<typename F> inline bool approx (F a, F b, F epsilon=1e-5)
   {
   using namespace std;
-  return abs(a-b) <= (epsilon*abs(b));
+  return abs(a-b) < (epsilon*abs(b));
   }
 
-/*! Returns \e true if | \a a-b | <= \a epsilon, else \e false. */
+/*! Returns \e true if | \a a-b | < \a epsilon, else \e false. */
 template<typename F> inline bool abs_approx (F a, F b, F epsilon=1e-5)
   {
   using namespace std;
-  return abs(a-b) <= epsilon;
+  return abs(a-b) < epsilon;
   }
 
 /*! Returns the largest integer which is smaller than (or equal to) \a arg. */
 template<typename I, typename F> inline I ifloor (F arg)
   {
   using namespace std;
   return I(floor(arg));
@@ -66,19 +65,15 @@
 
 /*! Returns the remainder of the division \a v1/v2.
     The result is non-negative.
     \a v1 can be positive or negative; \a v2 must be positive. */
 inline double fmodulo (double v1, double v2)
   {
   using namespace std;
-  if (v1>=0)
-    return (v1<v2) ? v1 : fmod(v1,v2);
-  double tmp=fmod(v1,v2)+v2;
-  return (tmp==v2) ? 0. : tmp;
-//  return (v1>=0) ? ((v1<v2) ? v1 : fmod(v1,v2)) : (fmod(v1,v2)+v2);
+  return (v1>=0) ? ((v1<v2) ? v1 : fmod(v1,v2)) : (fmod(v1,v2)+v2);
   }
 
 /*! Returns the remainder of the division \a v1/v2.
     The result is non-negative.
     \a v1 can be positive or negative; \a v2 must be positive. */
 template<typename I> inline I imodulo (I v1, I v2)
   { I v=v1%v2; return (v>=0) ? v : v+v2; }
@@ -119,62 +114,20 @@
 /*! Returns the integer \a n, which fulfills \a n*n<=arg<(n+1)*(n+1). */
 template<typename I> inline uint32 isqrt (I arg)
   { return isqrt_helper__<I,(sizeof(I)>4)>::isqrt(arg); }
 
 /*! Returns the largest integer \a n that fulfills \a 2^n<=arg. */
 template<typename I> inline int ilog2 (I arg)
   {
-#ifdef __GNUC__
-  if (arg==0) return 0;
-  if (sizeof(I)==sizeof(int))
-    return 8*sizeof(int)-1-__builtin_clz(arg);
-  if (sizeof(I)==sizeof(long))
-    return 8*sizeof(long)-1-__builtin_clzl(arg);
-  if (sizeof(I)==sizeof(long long))
-    return 8*sizeof(long long)-1-__builtin_clzll(arg);
-#endif
   int res=0;
-  while (arg > 0xFFFF) { res+=16; arg>>=16; }
-  if (arg > 0x00FF) { res|=8; arg>>=8; }
-  if (arg > 0x000F) { res|=4; arg>>=4; }
-  if (arg > 0x0003) { res|=2; arg>>=2; }
-  if (arg > 0x0001) { res|=1; }
-  return res;
-  }
-
-template<typename I> inline int ilog2_nonnull (I arg)
-  {
-#ifdef __GNUC__
-  if (sizeof(I)<=sizeof(int))
-    return 8*sizeof(int)-1-__builtin_clz(arg);
-  if (sizeof(I)==sizeof(long))
-    return 8*sizeof(long)-1-__builtin_clzl(arg);
-  if (sizeof(I)==sizeof(long long))
-    return 8*sizeof(long long)-1-__builtin_clzll(arg);
-#endif
-  return ilog2 (arg);
-  }
-
-template<typename I> inline int trailingZeros(I arg)
-  {
-  if (arg==0) return sizeof(I)<<3;
-#ifdef __GNUC__
-  if (sizeof(I)<=sizeof(int))
-    return __builtin_ctz(arg);
-  if (sizeof(I)==sizeof(long))
-    return __builtin_ctzl(arg);
-  if (sizeof(I)==sizeof(long long))
-    return __builtin_ctzll(arg);
-#endif
-  int res=0;
-  while ((arg&0xFFFF)==0) { res+=16; arg>>=16; }
-  if ((arg&0x00FF)==0) { res|=8; arg>>=8; }
-  if ((arg&0x000F)==0) { res|=4; arg>>=4; }
-  if ((arg&0x0003)==0) { res|=2; arg>>=2; }
-  if ((arg&0x0001)==0) { res|=1; }
+  while (arg > 0x0000FFFF) { res+=16; arg>>=16; }
+  if (arg > 0x000000FF) { res|=8; arg>>=8; }
+  if (arg > 0x0000000F) { res|=4; arg>>=4; }
+  if (arg > 0x00000003) { res|=2; arg>>=2; }
+  if (arg > 0x00000001) { res|=1; }
   return res;
   }
 
 /*! Returns \a atan2(y,x) if \a x!=0 or \a y!=0; else returns 0. */
 inline double safe_atan2 (double y, double x)
   {
   using namespace std;
@@ -199,29 +152,14 @@
     The array must be ordered in ascending order; no two values may be equal. */
 template<typename T, typename Iter> inline void interpol_helper
   (const Iter &begin, const Iter &end, const T &val, tsize &idx, T &frac)
   { interpol_helper (begin,end,val,std::less<T>(),idx,frac); }
 
 /*! \} */
 
-#if (__cplusplus>=201103L)
-
-template<typename T>
-inline bool multiequal (const T &a, const T &b)
-  { return (a==b); }
-
-template<typename T, typename... Args>
-inline bool multiequal (const T &a, const T &b, Args... args)
-  { return (a==b) && multiequal (a, args...); }
-
-#else
-
-template<typename T> inline bool multiequal (const T &a, const T &b)
-  { return (a==b); }
-
 template<typename T> inline bool multiequal (const T &a, const T &b, const T &c)
   { return (a==b) && (a==c); }
 
 template<typename T> inline bool multiequal (const T &a, const T &b, const T &c,
   const T &d)
   { return (a==b) && (a==c) && (a==d); }
 
@@ -230,38 +168,7 @@
   { return (a==b) && (a==c) && (a==d) && (a==e); }
 
 template<typename T> inline bool multiequal (const T &a, const T &b, const T &c,
   const T &d, const T &e, const T &f)
   { return (a==b) && (a==c) && (a==d) && (a==e) && (a==f); }
 
 #endif
-
-template<typename T> class kahan_adder
-  {
-  private:
-    T sum, c;
-  public:
-    kahan_adder(): sum(0), c(0) {}
-
-    void add (const T &val)
-      {
-      volatile T tc=c; // volatile to disable over-eager optimizers
-      volatile T y=val-tc;
-      volatile T t=sum+y;
-      tc=(t-sum)-y;
-      sum=t;
-      c=tc;
-      }
-    T result() const { return sum; }
-  };
-
-template<typename Iter> bool checkNan (Iter begin, Iter end)
-  {
-  while (begin!=end)
-    {
-    if (*begin != *begin) return true;
-    ++begin;
-    }
-  return false;
-  }
-
-#endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/string_utils.h` & `healpy-github-devel/hpbeta/cxxsupport/string_utils.h`

 * *Files 6% similar despite different names*

```diff
@@ -21,15 +21,15 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file string_utils.h
  *  Various functions for manipulating strings.
  *
- *  Copyright (C) 2002-2012 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_STRING_UTILS_H
 #define PLANCK_STRING_UTILS_H
 
 #include <vector>
@@ -95,15 +95,10 @@
 template<typename T> void split (const std::string &inp, std::vector<T> &list);
 
 /*! Breaks the string \a inp into tokens separated by \a delim, and returns them
     in \a list. */
 void tokenize (const std::string &inp, char delim,
   std::vector<std::string> &list);
 
-/*! Reads all white-space separated strings from \a filename, and returns
-    them in \a words. */
-void parse_words_from_file (const std::string &filename,
-  std::vector<std::string> &words);
-
 /*! \} */
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/vec3.h` & `healpy-github-devel/hpbeta/cxxsupport/vec3.h`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/string_utils.cc` & `healpy-github-devel/hpbeta/cxxsupport/string_utils.cc`

 * *Files 5% similar despite different names*

```diff
@@ -22,15 +22,15 @@
  *  (DLR).
  */
 
 /*
  *  This file contains the implementation of various convenience functions
  *  used by the Planck LevelS package.
  *
- *  Copyright (C) 2002-2014 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include <sstream>
 #include <fstream>
 #include <iostream>
 #include <iomanip>
@@ -122,20 +122,21 @@
   }
 
 template<> void stringToData (const string &x, string &value)
   { value = trim(x); }
 
 template<> void stringToData (const string &x, bool &value)
   {
-  const char *fval[] = {"f","n","false",".false."};
-  const char *tval[] = {"t","y","true",".true."};
+  const char *x2 = x.c_str();
+  const char *fval[] = {"F","f","n","N","false",".false.","FALSE",".FALSE." };
+  const char *tval[] = {"T","t","y","Y","true",".true.","TRUE",".TRUE." };
   for (tsize i=0; i< sizeof(fval)/sizeof(fval[0]); ++i)
-    if (equal_nocase(x,fval[i])) { value=false; return; }
+    if (strcmp(x2,fval[i])==0) { value=false; return; }
   for (tsize i=0; i< sizeof(tval)/sizeof(tval[0]); ++i)
-    if (equal_nocase(x,tval[i])) { value=true; return; }
+    if (strcmp(x2,tval[i])==0) { value=true; return; }
   planck_fail("conversion error in stringToData<bool>(\""+x+"\")");
   }
 
 template void stringToData (const string &x, signed char &value);
 template void stringToData (const string &x, unsigned char &value);
 template void stringToData (const string &x, short &value);
 template void stringToData (const string &x, unsigned short &value);
@@ -316,21 +317,7 @@
   {
   istringstream stream(inp);
   string token;
   list.clear();
   while (getline(stream,token,delim))
     list.push_back(token);
   }
-
-void parse_words_from_file (const string &filename, vector<string> &words)
-  {
-  words.clear();
-  ifstream inp(filename.c_str());
-  planck_assert (inp,"Could not open file '"+filename+"'.");
-  while (inp)
-    {
-    string word;
-    inp>>word;
-    word=trim(word);
-    if (word!="") words.push_back(word);
-    }
-  }
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/sse_utils_cxx.h` & `healpy-github-devel/hpbeta/cxxsupport/sse_utils_cxx.h`

 * *Files 0% similar despite different names*

```diff
@@ -21,28 +21,33 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file sse_utils_cxx.h
  *  SSE/SSE2/SSE3-related functionality for C++
  *
- *  Copyright (C) 2011, 2012 Max-Planck-Society
+ *  Copyright (C) 2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_SSE_UTILS_CXX_H
 #define PLANCK_SSE_UTILS_CXX_H
 
+#ifndef PLANCK_DISABLE_SSE
+
 template<typename T, int sz> class svec;
 
 #if (defined(__SSE2__))
 
 #include <xmmintrin.h>
 #include <emmintrin.h>
 
+#define PLANCK_HAVE_SSE
+#define PLANCK_HAVE_SSE2
+
 template<> class svec<int, 4>
   {
   public:
     typedef int Ts;
     typedef __m128i Tv;
     typedef union { Tv v; Ts d[4]; } Tu;
     Tv v;
@@ -103,14 +108,18 @@
       { return svec(_mm_cmpgt_epi32(v,b.v)); }
     svec lt (const svec &b) const
       { return svec(_mm_cmplt_epi32(v,b.v)); }
   };
 
 typedef svec<int,4> V4si;
 
+inline V4si shuffle(const V4si &a, const V4si &b, int sh)
+  { return V4si(_mm_castps_si128(_mm_shuffle_ps
+    (_mm_castsi128_ps(a.v), _mm_castsi128_ps(b.v), sh))); }
+
 #if 0
 template<> class svec<long long , 2>
   {
   public:
     typedef long long Ts;
     typedef __m128i Tv;
     typedef union { Tv v; Ts d[2]; } Tu;
@@ -382,7 +391,9 @@
   { return V4sf (_mm_castsi128_ps(a.v)); }
 template<> inline V2df vcast (const V4si &a)
   { return V2df (_mm_castsi128_pd(a.v)); }
 
 #endif
 
 #endif
+
+#endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/rotmatrix.h` & `healpy-github-devel/hpbeta/cxxsupport/rotmatrix.h`

 * *Files 0% similar despite different names*

```diff
@@ -66,18 +66,18 @@
     void SetToIdentity ();
     /*! Sets all matrix elements to zero. */
     void SetToZero ();
     /*! Transposes the matrix. */
     void Transpose ();
 
     /*! Extracts a unit-length rotation axis \a axis and a rotation angle
-        \a angle (in radian) from the matrix. */
+        \a angle from the matrix. */
     void toAxisAngle (vec3 &axis, double &angle) const;
 
-    /*! Constructs a matrix which causes a rotation by \a angle radians around
+    /*! Constructs a matrix which causes a rotation by \a angle around
         \a axis. \a axis must have unit length. */
     void Make_Axis_Rotation_Transform (const vec3 &axis, double angle);
 
     /*! Creates a rotation matrix \a A, which performs the following operations
         on a vector \a v, when \a Av is calculated:
         -# rotate \a v around the z-axis by \a gamma,
         -# rotate \a v' around the y-axis by \a beta,
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/paramfile.h` & `healpy-github-devel/hpbeta/cxxsupport/paramfile.h`

 * *Files 24% similar despite different names*

```diff
@@ -18,92 +18,62 @@
 
 /*
  *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file paramfile.h
+/*
  *  Class for parsing parameter files
  *
- *  Copyright (C) 2003-2014 Max-Planck-Society
- *  Authors: Martin Reinecke
+ *  Copyright (C) 2003-2011 Max-Planck-Society
+ *  Authors: Martin Reinecke, Reinhard Hell
  */
 
 #ifndef PLANCK_PARAMFILE_H
 #define PLANCK_PARAMFILE_H
 
 #include <map>
 #include <set>
 #include <string>
 #include "datatypes.h"
 #include "string_utils.h"
 
-/*! Class for storing and querying key/value pairs. The name is historical;
-    the parameters can actually be obtained from othersources as well
-    (e.g. the command line). */
 class paramfile
   {
   private:
     typedef std::map<std::string,std::string> params_type;
     params_type params;
     mutable std::set<std::string> read_params;
     bool verbose;
 
     std::string get_valstr(const std::string &key) const;
     bool param_unread (const std::string &key) const;
     void findhelper (const std::string &key, const std::string &value, NDT type,
       bool deflt) const;
-    void setParamString (const std::string &key, const std::string &value);
 
   public:
-    paramfile() : verbose(true) {}
-    /*! Constructs a paramfile object from the contents of \a filename.
-        If  \a verbose_==true, diagnostic output is generated when calling
-        methods on this object, otherwise not. */
     paramfile (const std::string &filename, bool verbose_=true);
-    /*! Constructs a paramfile object from the contents of \a par.
-        If  \a verbose_==true, diagnostic output is generated when calling
-        methods on this object, otherwise not. */
     paramfile (const params_type &par, bool verbose_=true);
     ~paramfile();
 
-    /*! Allows adjusting the verbosity. */
     void setVerbosity (bool verbose_)
       { verbose = verbose_; }
 
-    /*! Returns the verbosity setting of the object. */
     bool getVerbosity () const
       { return verbose; }
 
-    /*! Returns \c true, if a paremeter called \a key is stored in the object,
-        else \c false. */
     bool param_present(const std::string &key) const;
 
-    /*! Returns the value stored for the parameter name \a key, after converting
-        it to the requested type. If \a key is not present, an exception is
-        thrown. */
     template<typename T> T find (const std::string &key) const;
-    /*! Returns the value stored for the parameter name \a key, after converting
-        it to the requested type. If \a key is not present, \a deflt is returned
-        instead, and is also entered into the parameter set. */
     template<typename T> T find
       (const std::string &key, const T &deflt);
 
-    /*! Returns the entire set of currently stored parameters. */
     const params_type &getParams() const
       { return params; }
 
-    /*! Sets the parameter with the name \a key to \a value. */
+    void setParamString (const std::string &key, const std::string &value);
     template<typename T> void setParam (const std::string &key, const T &value)
       { setParamString(key,dataToString(value)); }
   };
 
-/*! Tries to build a \a paramfile object from the contents of a command line.
-    If \a argc==2 and \a argv[1] does not contain the character "=", the
-    function tries to input parameters from the file \a argv[1]. Otherwise
-    the function interprets each command line argument as a "key=value"
-    statement. */
-paramfile getParamsFromCmdline (int argc, const char **argv,
-  bool verbose=true);
-
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/error_handling.cc` & `healpy-github-devel/hpbeta/cxxsupport/error_handling.cc`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/pointing.h` & `healpy-github-devel/hpbeta/cxxsupport/pointing.h`

 * *Files 3% similar despite different names*

```diff
@@ -21,15 +21,15 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file pointing.h
  *  Class representing a direction in 3D space
  *
- *  Copyright (C) 2003-2012 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_POINTING_H
 #define PLANCK_POINTING_H
 
 #include <cmath>
@@ -62,16 +62,14 @@
     /*! Returns a normalized vector pointing in the same direction. */
     operator vec3() const
       { return to_vec3(); }
     /*! Returns a normalized vector pointing in the same direction. */
     vec3 to_vec3() const;
     /*! Converts \a inp to \a ptg. \a inp need not be normalized. */
     void from_vec3 (const vec3 &inp);
-    /*! Changes the angles so that \a 0<=theta<=pi. */
-    void normalize_theta();
     /*! Changes the angles so that \a 0<=theta<=pi and \a 0<=phi<2*pi. */
     void normalize();
   };
 
 /*! Writes \a p to \a os.
     \relates pointing */
 std::ostream &operator<< (std::ostream &os, const pointing &p);
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/share_utils.h` & `healpy-github-devel/hpbeta/cxxsupport/share_utils.h`

 * *Files 8% similar despite different names*

```diff
@@ -21,15 +21,15 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file share_utils.h
  *  Various convenience functions for subdividing tasks into chunks
  *
- *  Copyright (C) 2002-2014 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_SHARE_UTILS_H
 #define PLANCK_SHARE_UTILS_H
 
 #include "datatypes.h"
@@ -43,22 +43,14 @@
   int64 nwork = ghi-glo;
   int64 nbase = nwork/nshares;
   int64 additional = nwork%nshares;
   lo = glo+myshare*nbase + ((myshare<additional) ? myshare : additional);
   hi = lo+nbase+(myshare<additional);
   }
 
-inline int64 shareSize (int64 glo, int64 ghi, int64 nshares, int64 myshare)
-  {
-  int64 nwork = ghi-glo;
-  int64 nbase = nwork/nshares;
-  int64 additional = nwork%nshares;
-  return (myshare<additional) ? nbase+1 : nbase;
-  }
-
 /*! Helper class for dividing a range of work items into chunks of specified
     size. */
 class chunkMaker
   {
   private:
     uint64 s_full, s_chunk, offset;
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/planck_rng.h` & `healpy-github-devel/hpbeta/cxxsupport/planck_rng.h`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/wigner.h` & `healpy-github-devel/hpbeta/cxxsupport/wigner.h`

 * *Files 5% similar despite different names*

```diff
@@ -153,30 +153,28 @@
     /*! Computes the Wigner matrix elements for the values of \a m and \a m'
         set by the preceding call to prepare(), for all \a l up to \a lmax
         (set in the constructor), and for the \a nth colatitude passed to the
         constructor. On return, \a firstl contains the index of the first
         matrix element larger than \a epsilon; all values with smaller indices
         in the result array are undefined. */
     const arr<double> &calc (int nth, int &firstl);
-    void calc (int nth, int &firstl, arr<double> &resx) const;
   };
 
 class wignergen: public wignergen_scalar
   {
-#ifdef __SSE2__
+#ifdef PLANCK_HAVE_SSE2
   private:
     arr_align<V2df,16> result2;
 
   public:
     wignergen (int lmax_, const arr<double> &thetas, double epsilon)
       : wignergen_scalar (lmax_,thetas,epsilon), result2(lmax_+1) {}
 
     using wignergen_scalar::calc;
     const arr_align<V2df,16> &calc (int nth1, int nth2, int &firstl);
-    void calc (int nth1, int nth2, int &firstl, arr_align<V2df,16> &resx) const;
 #else
   public:
     wignergen (int lmax_, const arr<double> &thetas, double epsilon)
       : wignergen_scalar (lmax_,thetas,epsilon) {}
 #endif
   };
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/wigner.cc` & `healpy-github-devel/hpbeta/cxxsupport/wigner.cc`

 * *Files 5% similar despite different names*

```diff
@@ -21,15 +21,15 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file wigner.cc
  *  Several C++ classes for calculating Wigner matrices
  *
- *  Copyright (C) 2009-2015 Max-Planck-Society
+ *  Copyright (C) 2009-2011 Max-Planck-Society
  *  \author Martin Reinecke and others (see individual classes)
  */
 
 #include "wigner.h"
 #include "lsconstants.h"
 
 using namespace std;
@@ -269,15 +269,15 @@
     flm1(2*lmax+1), flm2(2*lmax+1),
     cf(maxscale+1-minscale), costh(thetas.size()), xl(lmax+1),
     thetaflip(thetas.size()),
     m1(-1234567890), m2(-1234567890), am1(-1234567890), am2(-1234567890),
     mlo(-1234567890), mhi(-1234567890),
     fx(lmax+2), result(lmax+1)
   {
-  planck_assert(lmax>=0,"lmax too small");
+  planck_assert(lmax>0,"lmax too small");
   logsum[0] = 0.;
   for (tsize m=1; m<logsum.size(); ++m)
     logsum[m] = logsum[m-1]+log(static_cast<long double>(m));
   for (tsize lm=0; lm<flm1.size(); ++lm)
     {
     flm1[lm] = sqrt(1./(lm+1.));
     flm2[lm] = sqrt(lm/(lm+1.));
@@ -356,24 +356,18 @@
     if (m2<0)
       { swap(cosPow, sinPow); preMinus=((mhi+m1)&1); }
     }
   }
 
 const arr<double> &wignergen_scalar::calc (int nth, int &firstl)
   {
-  calc(nth, firstl, result);
-  return result;
-  }
-
-void wignergen_scalar::calc (int nth, int &firstl, arr<double> &resx) const
-  {
   int l=mhi;
   const dbl3 *fy = &fx[0];
   const double cth = costh[nth];
-  double *res = &resx[0];
+  double *res = &result[0];
   long double logval = prefactor + lc05[nth]*cosPow + ls05[nth]*sinPow;
   logval *= inv_ln2;
   int scale = int (logval/large_exponent2)-minscale;
   double rec1 = 0.;
   double rec2 = double(exp(ln2*(logval-(scale+minscale)*large_exponent2)));
   if (preMinus ^ (thetaflip[nth] && ((am1+am2)&1))) rec2 = -rec2;
 
@@ -388,15 +382,15 @@
       {
       rec1 *= fsmall;
       rec2 *= fsmall;
       ++scale;
       }
     }
 
-  if (scale<0) { firstl=lmax+1; return; }
+  if (scale<0) { firstl=lmax+1; return result; }
   rec1 *= cf[scale];
   rec2 *= cf[scale];
 
   for (;l<lmax-1;l+=2) // iterate until we cross the eps threshold
     {
     if (abs(rec2)>eps) break;
     rec1 = (cth - fy[l+1][1])*fy[l+1][0]*rec2 - fy[l+1][2]*rec1;
@@ -406,15 +400,15 @@
   if ((abs(rec2)<=eps) && (++l<=lmax))
     {
     rec1 = (cth - fy[l][1])*fy[l][0]*rec2 - fy[l][2]*rec1;
     swap (rec1,rec2);
     }
 
   firstl = l;
-  if (l>lmax) return;
+  if (l>lmax) return result;
 
   res[l]=rec2;
 
   for (;l<lmax-1;l+=2)
     {
     res[l+1] = rec1 = (cth - fy[l+1][1])*fy[l+1][0]*rec2 - fy[l+1][2]*rec1;
     res[l+2] = rec2 = (cth - fy[l+2][1])*fy[l+2][0]*rec1 - fy[l+2][2]*rec2;
@@ -422,17 +416,19 @@
   while (true)
     {
     if (++l>lmax) break;
     res[l] = rec1 = (cth - fy[l][1])*fy[l][0]*rec2 - fy[l][2]*rec1;
     if (++l>lmax) break;
     res[l] = rec2 = (cth - fy[l][1])*fy[l][0]*rec1 - fy[l][2]*rec2;
     }
+
+  return result;
   }
 
-#ifdef __SSE2__
+#ifdef PLANCK_HAVE_SSE2
 
 #define RENORMALIZE \
   do \
     { \
     double rec1a, rec1b, rec2a, rec2b, cfa, cfb; \
     rec1.writeTo(rec1a,rec1b); rec2.writeTo(rec2a,rec2b); \
     corfac.writeTo(cfa,cfb); \
@@ -465,25 +461,18 @@
   pred = fy[lv][2]; \
   reca = prea-preb; \
   prec *= t0; \
   }
 
 const arr_align<V2df,16> &wignergen::calc (int nth1, int nth2, int &firstl)
   {
-  calc(nth1, nth2, firstl, result2);
-  return result2;
-  }
-
-void wignergen::calc (int nth1, int nth2, int &firstl,
-  arr_align<V2df,16> &resx) const
-  {
   int l=mhi;
   const dbl3 *fy = &fx[0];
   const V2df cth(costh[nth1],costh[nth2]);
-  V2df *res = &resx[0];
+  V2df *res = &result2[0];
   long double logval1 = prefactor + lc05[nth1]*cosPow + ls05[nth1]*sinPow,
               logval2 = prefactor + lc05[nth2]*cosPow + ls05[nth2]*sinPow;
   logval1 *= inv_ln2;
   logval2 *= inv_ln2;
   int scale1 = int (logval1/large_exponent2)-minscale,
       scale2 = int (logval2/large_exponent2)-minscale;
   V2df rec1(0.);
@@ -537,15 +526,15 @@
       NEXTSTEP(pre2,pre3,pre0,pre1,rec2,rec1,l+1)
 
       if (any(abs(rec2).gt(fbig2)))
         RENORMALIZE;
       }
     }
   firstl=l;
-  if (l>lmax) return;
+  if (l>lmax) return result2;
 
   GETPRE(pre0,pre1,l+1)
   while (true)
     {
     V2df t1;
     res[l]=t1=rec2*corfac;
     if (all(abs(t1).ge(eps2)))
@@ -561,15 +550,15 @@
     if (++l>lmax) break;
     NEXTSTEP(pre2,pre3,pre0,pre1,rec2,rec1,l+1)
 
     if (any(abs(rec2).gt(fbig2)))
       RENORMALIZE;
     }
 
-  if (l>lmax) return;
+  if (l>lmax) return result2;
   rec1*=corfac;
   rec2*=corfac;
 
   GETPRE(pre0,pre1,l+1)
   for (;l<lmax-1;l+=2)
     {
     res[l] = rec2;
@@ -580,17 +569,19 @@
 
   res[l] = rec2;
   if (++l<=lmax)
     {
     NEXTSTEP(pre0,pre1,pre2,pre3,rec1,rec2,l+1)
     res[l] = rec1;
     }
+
+  return result2;
   }
 
-#endif /* __SSE2__ */
+#endif /* PLANCK_HAVE_SSE2 */
 
 wigner_estimator::wigner_estimator (int lmax_, double epsPow_)
   : lmax(lmax_), xlmax(1./lmax_), epsPow(epsPow_) {}
 
 void wigner_estimator::prepare_m (int m1_, int m2_)
   {
   m1=abs(m1_); m2=abs(m2_);
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/trafos.cc` & `healpy-github-devel/hpbeta/cxxsupport/trafos.cc`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/paramfile.cc` & `healpy-github-devel/hpbeta/cxxsupport/paramfile.cc`

 * *Files 6% similar despite different names*

```diff
@@ -135,29 +135,19 @@
 void paramfile::setParamString (const string &key, const string &value)
   {
   if (param_present(key))
     {
     if (params[key]!=value)
       {
       if (verbose)
-        cout << "Parser: altering value of key '"<<key<<"' to '"<<value<<"'."
+        cout << "Parser: altering value of key'"<<key<<"' to '"<<value<<"'."
              << endl;
       params[key]=value;
       }
     }
   else
     {
     if (verbose)
-      cout << "Parser: setting new key '"<<key<<"' to '"<<value<<"'."<<endl;
+      cout << "Parser: setting new key'"<<key<<"' to '"<<value<<"'."<<endl;
     params[key]=value;
     }
   }
-
-paramfile getParamsFromCmdline (int argc, const char **argv, bool verbose)
-  {
-  planck_assert(argc>=2,"incorrect command line format");
-  if ((argc==2) && (string(argv[1]).find("=")==string::npos))
-    return paramfile(argv[1],verbose);
-  map<string,string> pmap;
-  parse_cmdline_equalsign(argc,argv,pmap);
-  return paramfile(pmap,verbose);
-  }
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/rotmatrix.cc` & `healpy-github-devel/hpbeta/cxxsupport/rotmatrix.cc`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/lsconstants.h` & `healpy-github-devel/hpbeta/cxxsupport/lsconstants.h`

 * *Files 4% similar despite different names*

```diff
@@ -78,16 +78,16 @@
 
 //! Astronomical unit in m
 const double astronomicalUnit=1.49597870691e11;
 
 //! Solar constant in W/m^2
 const double solarConstant=1368.0;
 
-//! Average CMB temperature in K (Fixsen, ApJ 709 (2009), arXiv:0911.1955)
-const double tcmb = 2.72548;
+//! Average CMB temperature in K (Mather et al. 1999, ApJ 512, 511)
+const double tcmb = 2.725;
 
 //! offset (in seconds) between Jan 1, 1958 and Jan 1, 1970
 const double sec_58_70 = 378691200.;
 
 /*! \} */
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/openmp_support.h` & `healpy-github-devel/hpbeta/cxxsupport/openmp_support.h`

 * *Files 5% similar despite different names*

```diff
@@ -18,17 +18,15 @@
 
 /*
  *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file openmp_support.h
- *  Various OpenMP-related convenience functions
- *
+/*
  *  Copyright (C) 2005-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_OPENMP_SUPPORT_H
 #define PLANCK_OPENMP_SUPPORT_H
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/safe_ptr.h` & `healpy-github-devel/hpbeta/cxxsupport/safe_cast.h`

 * *Files 25% similar despite different names*

```diff
@@ -18,67 +18,75 @@
 
 /*
  *  libcxxsupport is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
-/*! \file safe_ptr.h
- *  Pointer wrapper for better exception safety and leakage prevention
+/*! \file safe_cast.h
+ *  Numerical cast operator with additional checks that the value is preserved.
  *
- *  Copyright (C) 2005-2015 Max-Planck-Society
- *  \author Martin Reinecke
+ *  Copyright (C) 2009 Max-Planck-Society
+ *  Author: Martin Reinecke
  */
 
-#ifndef PLANCK_SAFE_PTR_H
-#define PLANCK_SAFE_PTR_H
+#ifndef PLANCK_SAFE_CAST_H
+#define PLANCK_SAFE_CAST_H
 
-#if (__cplusplus>=201103L)
+#include <limits>
+#include "error_handling.h"
 
-#include <memory>
-template<typename T> using safe_ptr = std::unique_ptr<T>;
+template<typename T1, typename T2, bool s1, bool s2> struct safe_cast_helper__
+  {};
 
-#else
+template<typename T1, typename T2> struct safe_cast_helper__ <T1,T2,true,true>
+  {
+  static T1 cast (const T2 &arg)
+    {
+    T1 res = T1(arg);
+    planck_assert(T2(res)==arg, "safe_cast: value changed during cast");
+    return res;
+    }
+  };
 
-#include "error_handling.h"
+template<typename T1, typename T2> struct safe_cast_helper__ <T1,T2,false,false>
+  {
+  static T1 cast (const T2 &arg)
+    {
+    T1 res = T1(arg);
+    planck_assert(T2(res)==arg, "safe_cast: value changed during cast");
+    return res;
+    }
+  };
 
-template <typename T> class safe_ptr
+template<typename T1, typename T2> struct safe_cast_helper__ <T1,T2,true,false>
   {
-  private:
-    T *p;
-    bool set;
-
-    // forbid copying of safe_ptrs, at least until we know how to do it
-    safe_ptr (const safe_ptr &) {}
-    safe_ptr &operator= (const safe_ptr &) { return *this; }
-
-  public:
-    safe_ptr() : p(0), set(false) {}
-    safe_ptr (T *p2) : p(p2), set(true) {}
-    ~safe_ptr() { delete p; }
-
-    void reset (T *p2)
-      {
-      planck_assert (!set, "safe_ptr: already set");
-      set = true;
-      p=p2;
-      }
-
-    void reset()
-      {
-      delete p;
-      p=0;
-      set=false;
-      }
-
-    T * get() const
-      { return p; }
-
-    operator T*() { return p; }
-    operator const T*() const { return p; }
-    T *operator->() { return p; }
-    const T *operator->() const { return p; }
+  static T1 cast (const T2 &arg)
+    {
+    T1 res = T1(arg);
+    planck_assert((res>=0) && (T2(res)==arg),
+      "safe_cast: value changed during cast");
+    return res;
+    }
   };
 
-#endif
+template<typename T1, typename T2> struct safe_cast_helper__ <T1,T2,false,true>
+  {
+  static T1 cast (const T2 &arg)
+    {
+    T1 res = T1(arg);
+    planck_assert((arg>=0) && (T2(res)==arg),
+      "safe_cast: value changed during cast");
+    return res;
+    }
+  };
+
+/*! Tries to cast \a arg from its type to a variable of type \c T1.
+    If this conversion leads to a change of the actual value (e.g. due to
+    overflow or truncation), an exception is thrown. */
+template<typename T1, typename T2> inline T1 safe_cast(const T2 &arg)
+  {
+  return safe_cast_helper__<T1,T2,std::numeric_limits<T1>::is_signed,
+    std::numeric_limits<T2>::is_signed>::cast(arg);
+  }
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/arr.h` & `healpy-github-devel/hpbeta/cxxsupport/arr.h`

 * *Files 3% similar despite different names*

```diff
@@ -21,23 +21,22 @@
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file arr.h
  *  Various high-performance array classes used by the Planck LevelS package.
  *
- *  Copyright (C) 2002-2015 Max-Planck-Society
+ *  Copyright (C) 2002-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_ARR_H
 #define PLANCK_ARR_H
 
 #include <algorithm>
-#include <vector>
 #include <cstdlib>
 #include "alloc_utils.h"
 #include "datatypes.h"
 #include "math_utils.h"
 
 /*! \defgroup arraygroup Array classes */
 /*! \{ */
@@ -170,30 +169,31 @@
     template<typename T2> T &operator[] (T2 n) {return d[n];}
     /*! Returns a constant reference to element \a n */
     template<typename T2> const T &operator[] (T2 n) const {return d[n];}
   };
 
 
 /*! One-dimensional array type, with selectable storage management. */
-template <typename T, typename stm> class arrT: public arr_ref<T>
+template <typename T, typename storageManager> class arrT: public arr_ref<T>
   {
   private:
+    storageManager stm;
     bool own;
 
     void reset()
       { this->d=0; this->s=0; own=true; }
 
   public:
     /*! Creates a zero-sized array. */
     arrT() : arr_ref<T>(0,0), own(true) {}
     /*! Creates an array with \a sz entries. */
-    explicit arrT(tsize sz) : arr_ref<T>(stm::alloc(sz),sz), own(true) {}
+    arrT(tsize sz) : arr_ref<T>(stm.alloc(sz),sz), own(true) {}
     /*! Creates an array with \a sz entries, and initializes them with
         \a inival. */
-    arrT(tsize sz, const T &inival) : arr_ref<T>(stm::alloc(sz),sz), own(true)
+    arrT(tsize sz, const T &inival) : arr_ref<T>(stm.alloc(sz),sz), own(true)
       { this->fill(inival); }
     /*! Creates an array with \a sz entries, which uses the memory pointed
         to by \a ptr.
         \note \a ptr will <i>not</i> be deallocated by the destructor.
         \warning Only use this if you REALLY know what you are doing.
         In particular, this is only safely usable if
           <ul>
@@ -201,90 +201,77 @@
           <li>\a ptr survives during the lifetime of the array object</li>
           <li>\a ptr is not subject to garbage collection</li>
           </ul>
         Other restrictions may apply. You have been warned. */
     arrT (T *ptr, tsize sz): arr_ref<T>(ptr,sz), own(false) {}
     /*! Creates an array which is a copy of \a orig. The data in \a orig
         is duplicated. */
-    arrT (const arrT &orig): arr_ref<T>(stm::alloc(orig.s),orig.s), own(true)
+    arrT (const arrT &orig): arr_ref<T>(stm.alloc(orig.s),orig.s), own(true)
       { for (tsize m=0; m<this->s; ++m) this->d[m] = orig.d[m]; }
     /*! Frees the memory allocated by the object. */
-    ~arrT() { if (own) stm::dealloc(this->d); }
+    ~arrT() { if (own) stm.dealloc(this->d); }
 
     /*! Allocates space for \a sz elements. The content of the array is
         undefined on exit. \a sz can be 0. If \a sz is the
         same as the current size, no reallocation is performed. */
     void alloc (tsize sz)
       {
       if (sz==this->s) return;
-      if (own) stm::dealloc(this->d);
+      if (own) stm.dealloc(this->d);
       this->s = sz;
-      this->d = stm::alloc(sz);
+      this->d = stm.alloc(sz);
       own = true;
       }
     /*! Allocates space for \a sz elements. If \a sz is the
         same as the current size, no reallocation is performed.
         All elements are set to \a inival. */
     void allocAndFill (tsize sz, const T &inival)
       { alloc(sz); this->fill(inival); }
     /*! Deallocates the memory held by the array, and sets the array size
         to 0. */
-    void dealloc() {if (own) stm::dealloc(this->d); reset();}
+    void dealloc() {if (own) stm.dealloc(this->d); reset();}
     /*! Resizes the array to hold \a sz elements. The existing content of the
         array is copied over to the new array to the extent possible.
         \a sz can be 0. If \a sz is the same as the current size, no
         reallocation is performed. */
     void resize (tsize sz)
       {
       using namespace std;
       if (sz==this->s) return;
-      T *tmp = stm::alloc(sz);
+      T *tmp = stm.alloc(sz);
       for (tsize m=0; m<min(sz,this->s); ++m)
         tmp[m]=this->d[m];
-      if (own) stm::dealloc(this->d);
+      if (own) stm.dealloc(this->d);
       this->s = sz;
       this->d = tmp;
       own = true;
       }
 
     /*! Changes the array to be a copy of \a orig. */
     arrT &operator= (const arrT &orig)
       {
       if (this==&orig) return *this;
       alloc (orig.s);
       for (tsize m=0; m<this->s; ++m) this->d[m] = orig.d[m];
       return *this;
       }
 
-    /*! Changes the array to be a copy of the std::vector \a orig. */
-    template<typename T2> void copyFrom (const std::vector<T2> &orig)
-      {
-      alloc (orig.size());
-      for (tsize m=0; m<this->s; ++m) this->d[m] = orig[m];
-      }
-    /*! Changes the std::vector \a vec to be a copy of the object. */
-    template<typename T2> void copyTo (std::vector<T2> &vec) const
-      {
-      vec.clear(); vec.reserve(this->s);
-      for (tsize m=0; m<this->s; ++m) vec.push_back(this->d[m]);
-      }
-
     /*! Reserves space for \a sz elements, then copies \a sz elements
         from \a ptr into the array. */
     template<typename T2> void copyFromPtr (const T2 *ptr, tsize sz)
       {
       alloc(sz);
       for (tsize m=0; m<this->s; ++m) this->d[m]=ptr[m];
       }
 
     /*! Assigns the contents and size of \a other to the array.
         \note On exit, \a other is zero-sized! */
     void transfer (arrT &other)
       {
-      if (own) stm::dealloc(this->d);
+      if (own) stm.dealloc(this->d);
       this->d=other.d;
       this->s=other.s;
       own=other.own;
       other.reset();
       }
     /*! Swaps contents and size with \a other. */
     void swap (arrT &other)
@@ -299,15 +286,15 @@
 template <typename T>
   class arr: public arrT<T,normalAlloc__<T> >
   {
   public:
     /*! Creates a zero-sized array. */
     arr() : arrT<T,normalAlloc__<T> >() {}
     /*! Creates an array with \a sz entries. */
-    explicit arr(tsize sz) : arrT<T,normalAlloc__<T> >(sz) {}
+    arr(tsize sz) : arrT<T,normalAlloc__<T> >(sz) {}
     /*! Creates an array with \a sz entries, and initializes them with
         \a inival. */
     arr(tsize sz, const T &inival) : arrT<T,normalAlloc__<T> >(sz,inival) {}
     /*! Creates an array with \a sz entries, which uses the memory pointed
         to by \a ptr.
         \note \a ptr will <i>not</i> be deallocated by the destructor.
         \warning Only use this if you REALLY know what you are doing.
@@ -315,28 +302,25 @@
           <ul>
           <li>\a T is a POD type</li>
           <li>\a ptr survives during the lifetime of the array object</li>
           <li>\a ptr is not subject to garbage collection</li>
           </ul>
         Other restrictions may apply. You have been warned. */
     arr (T *ptr, tsize sz): arrT<T,normalAlloc__<T> >(ptr,sz) {}
-    /*! Creates an array which is a copy of \a orig. The data in \a orig
-        is duplicated. */
-    arr (const arr &orig): arrT<T,normalAlloc__<T> >(orig) {}
   };
 
 /*! One-dimensional array type, with selectable storage alignment. */
 template <typename T, int align>
   class arr_align: public arrT<T,alignAlloc__<T,align> >
   {
   public:
     /*! Creates a zero-sized array. */
     arr_align() : arrT<T,alignAlloc__<T,align> >() {}
     /*! Creates an array with \a sz entries. */
-    explicit arr_align(tsize sz) : arrT<T,alignAlloc__<T,align> >(sz) {}
+    arr_align(tsize sz) : arrT<T,alignAlloc__<T,align> >(sz) {}
     /*! Creates an array with \a sz entries, and initializes them with
         \a inival. */
     arr_align(tsize sz, const T &inival)
       : arrT<T,alignAlloc__<T,align> >(sz,inival) {}
   };
 
 
@@ -354,18 +338,14 @@
     /*! Creates a zero-sized array. */
     arr2T() : s1(0), s2(0) {}
     /*! Creates an array with the dimensions \a sz1 and \a sz2. */
     arr2T(tsize sz1, tsize sz2)
       : s1(sz1), s2(sz2), d(s1*s2) {}
     /*! Creates an array with the dimensions  \a sz1 and \a sz2
         and initializes them with \a inival. */
-    /*! Creates an array with the dimensions \a sz1 and \a sz2 from existing
-        pointer. */
-    arr2T(T* p, tsize sz1, tsize sz2)
-      : s1(sz1), s2(sz2), d(p, s1*s2) {}
     arr2T(tsize sz1, tsize sz2, const T &inival)
       : s1(sz1), s2(sz2), d (s1*s2)
       { fill(inival); }
     /*! Creates the array as a copy of \a orig. */
     arr2T(const arr2T &orig)
       : s1(orig.s1), s2(orig.s2), d(orig.d) {}
     /*! Frees the memory associated with the array. */
@@ -408,18 +388,14 @@
     /*! Deallocates the space and makes the array zero-sized. */
     void dealloc () {d.dealloc(); s1=0; s2=0;}
 
     /*! Sets all array elements to \a val. */
     void fill (const T &val)
       { for (tsize m=0; m<s1*s2; ++m) d[m]=val; }
 
-    /*! Multiplies all array elements by \a val. */
-    void scale (const T &val)
-      { for (tsize m=0; m<s1*s2; ++m) d[m]*=val; }
-
     /*! Changes the array to be a copy of \a orig. */
     arr2T &operator= (const arr2T &orig)
       {
       if (this==&orig) return *this;
       alloc (orig.s1, orig.s2);
       d = orig.d;
       return *this;
@@ -474,17 +450,14 @@
   class arr2: public arr2T<T,normalAlloc__<T> >
   {
   public:
     /*! Creates a zero-sized array. */
     arr2() : arr2T<T,normalAlloc__<T> > () {}
     /*! Creates an array with the dimensions \a sz1 and \a sz2. */
     arr2(tsize sz1, tsize sz2) : arr2T<T,normalAlloc__<T> > (sz1,sz2) {}
-    /*! Creates an array with the dimensions \a sz1 and \a sz2 from existing
-        pointer. */
-    arr2(T* p, tsize sz1, tsize sz2) : arr2T<T,normalAlloc__<T> > (p,sz1,sz2) {}
     /*! Creates an array with the dimensions  \a sz1 and \a sz2
         and initializes them with \a inival. */
     arr2(tsize sz1, tsize sz2, const T &inival)
       : arr2T<T,normalAlloc__<T> > (sz1,sz2,inival) {}
   };
 
 /*! Two-dimensional array type, with selectable storage alignment.
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/datatypes.h` & `healpy-github-devel/hpbeta/cxxsupport/datatypes.h`

 * *Files 5% similar despite different names*

```diff
@@ -23,24 +23,23 @@
  */
 
 /*! \file datatypes.h
  *  This file defines various platform-independent data types.
  *  If any of the requested types is not available, compilation aborts
  *  with an error (unfortunately a rather obscure one).
  *
- *  Copyright (C) 2004-2015 Max-Planck-Society
+ *  Copyright (C) 2004-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_DATATYPES_H
 #define PLANCK_DATATYPES_H
 
 #include <string>
 #include <cstddef>
-#include "xcomplex.h"
 #include "error_handling.h"
 
 // Template magic to select the proper data types. These templates
 // should not be used outside this file.
 
 template <typename T, bool equalSize> struct sizeChooserHelper__
   { typedef void TYPE; };
@@ -65,32 +64,14 @@
   {
   typedef typename sizeChooserHelper2__
     <typename sizeChooserHelper__<T1,sizeof(T1)==sz>::TYPE,
      typename sizeChooserHelper__<T2,sizeof(T2)==sz>::TYPE,
      typename sizeChooserHelper__<T3,sizeof(T3)==sz>::TYPE >::TYPE TYPE;
   };
 
-#if (__cplusplus>=201103L)
-
-#include <cstdint>
-
-typedef int8_t int8;
-typedef uint8_t uint8;
-
-typedef int16_t int16;
-typedef uint16_t uint16;
-
-typedef int32_t int32;
-typedef uint32_t uint32;
-
-typedef int64_t int64;
-typedef uint64_t uint64;
-
-#else
-
 typedef signed char int8;
 typedef unsigned char uint8;
 
 typedef sizeChooser__<2, short, int>::TYPE
   int16;
 typedef sizeChooser__<2, unsigned short, unsigned int>::TYPE
   uint16;
@@ -101,16 +82,14 @@
   uint32;
 
 typedef sizeChooser__<8, long, long long>::TYPE
   int64;
 typedef sizeChooser__<8, unsigned long, unsigned long long>::TYPE
   uint64;
 
-#endif
-
 typedef sizeChooser__<4, float, double>::TYPE
   float32;
 typedef sizeChooser__<8, double, long double>::TYPE
   float64;
 
 /*! unsigned integer type which should be used for array sizes */
 typedef std::size_t tsize;
@@ -257,16 +236,14 @@
        NAT_LONG,
        NAT_ULONG,
        NAT_LONGLONG,
        NAT_ULONGLONG,
        NAT_FLOAT,
        NAT_DOUBLE,
        NAT_LONGDOUBLE,
-       NAT_FCMPLX,
-       NAT_DCMPLX,
        NAT_BOOL,
        NAT_STRING };
 
 /*! Returns the \a NDT constant associated with \a T. */
 template<typename T> inline NDT nativeType()
   { planck_fail(T::UNSUPPORTED_DATA_TYPE); }
 template<> inline NDT nativeType<char>              () { return NAT_CHAR;      }
@@ -279,16 +256,14 @@
 template<> inline NDT nativeType<long>              () { return NAT_LONG;      }
 template<> inline NDT nativeType<unsigned long>     () { return NAT_ULONG;     }
 template<> inline NDT nativeType<long long>         () { return NAT_LONGLONG;  }
 template<> inline NDT nativeType<unsigned long long>() { return NAT_ULONGLONG; }
 template<> inline NDT nativeType<float>             () { return NAT_FLOAT;     }
 template<> inline NDT nativeType<double>            () { return NAT_DOUBLE;    }
 template<> inline NDT nativeType<long double>       () { return NAT_LONGDOUBLE;}
-template<> inline NDT nativeType<fcomplex>          () { return NAT_FCMPLX;    }
-template<> inline NDT nativeType<dcomplex>          () { return NAT_DCMPLX;    }
 template<> inline NDT nativeType<bool>              () { return NAT_BOOL;      }
 template<> inline NDT nativeType<std::string>       () { return NAT_STRING;    }
 
 /*! Returns the size (in bytes) of the native data type \a type. */
 inline int ndt2size (NDT type)
   {
   switch (type)
@@ -303,16 +278,14 @@
     case NAT_LONG      :
     case NAT_ULONG     : return sizeof(long);
     case NAT_LONGLONG  :
     case NAT_ULONGLONG : return sizeof(long long);
     case NAT_FLOAT     : return sizeof(float);
     case NAT_DOUBLE    : return sizeof(double);
     case NAT_LONGDOUBLE: return sizeof(long double);
-    case NAT_FCMPLX    : return sizeof(fcomplex);
-    case NAT_DCMPLX    : return sizeof(dcomplex);
     case NAT_BOOL      : return sizeof(bool);
     default:
       planck_fail ("ndt2size: unsupported data type");
     }
   }
 
 #endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/cxxsupport/fitshandle.cc` & `healpy-github-devel/hpbeta/cxxsupport/fitshandle.cc`

 * *Files 2% similar despite different names*

```diff
@@ -398,15 +398,15 @@
   arr2b<char> ttype(ncol,81), tform(ncol,81), tunit(ncol,81);
 
   for (long m=0; m<ncol; ++m)
     {
     strcpy (ttype[m], cols[m].name().c_str());
     strcpy (tunit[m], cols[m].unit().c_str());
     ostringstream x;
-    if (cols[m].type()!=PLANCK_STRING)
+    if (cols[m].type()!=TSTRING)
       {
       planck_assert (cols[m].repcount()==1,"bad repcount for ASCII table");
       x << type2asciiform(cols[m].type());
       }
     else
       {
       x << "A" << dataToString(cols[m].repcount());
@@ -662,17 +662,14 @@
       {
       string *data2 = static_cast<string *> (data);
       planck_assert(table_hdu(colnum),"incorrect FITS table access");
       planck_assert (num<=(nrows_-offset),
         "read_column(): array too large");
       arr2b<char> tdata(safe_cast<tsize>(num),
                         safe_cast<tsize>(columns_[colnum-1].repcount()+1));
-      int dispwidth;
-      fits_get_col_display_width(FPTR, colnum, &dispwidth, &status);
-      planck_assert(dispwidth<=columns_[colnum-1].repcount(),"column too wide");
       fits_read_col (FPTR, TSTRING, colnum, offset+1, 1, num,
         0, tdata.p0(), 0, &status);
       check_errors();
       for (long m=0;m<num;++m) data2[m]=tdata[m];
       break;
       }
     default:
@@ -785,14 +782,16 @@
   int64 offset) const
   {
   planck_assert(image_hdu(),"not connected to an image");
   fits_read_img (FPTR, type2ftc(type), 1+offset, ndata, 0, data, 0, &status);
   check_errors();
   }
 
+#if 0 // disabled because Python does not like globals with constructor
+
 namespace {
 
 class cfitsio_checker
   {
   public:
     cfitsio_checker()
       {
@@ -807,7 +806,9 @@
              << dataToString(v_library*0.001) << ")." << endl << endl;
       }
   };
 
 cfitsio_checker Cfitsio_Checker;
 
 } // unnamed namespace
+
+#endif
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_healpix_tools.h` & `healpy-github-devel/hpbeta/Healpix_cxx/alm_healpix_tools.h`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map.h` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_map.h`

 * *Files 6% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file healpix_map.h
- *  Copyright (C) 2003-2013 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef HEALPIX_MAP_H
 #define HEALPIX_MAP_H
 
 #include "arr.h"
@@ -109,17 +109,16 @@
 #pragma omp for schedule (dynamic,5000)
         for (m=0; m<npix_; ++m) map[(this->*swapper)(m)] = orig.map[m];
 }
         }
       }
 
     /*! Imports the map \a orig into the current map, adjusting the
-        ordering scheme and the map resolution. \a orig must have lower
-        resolution than the current map, and \a this->Nside() must be an
-        integer multiple of \a orig.Nside(). */
+        ordering scheme and the map resolution. \a orig must have higher
+        resolution than the current map. */
     void Import_upgrade (const Healpix_Map<T> &orig)
       {
       planck_assert(nside_>orig.nside_,"Import_upgrade: this is no upgrade");
       int fact = nside_/orig.nside_;
       planck_assert (nside_==orig.nside_*fact,
         "the larger Nside must be a multiple of the smaller one");
 
@@ -139,16 +138,15 @@
             }
         }
 }
       }
 
     /*! Imports the map \a orig into the current map, adjusting the
         ordering scheme and the map resolution. \a orig must have higher
-        resolution than the current map, and \a orig.Nside() must be an
-        integer multiple of \a this->Nside().
+        resolution than the current map.
         \a pessimistic determines whether or not
         pixels are set to \a Healpix_undef when not all of the corresponding
         high-resolution pixels are defined.
 
         This method is instantiated for \a float and \a double only. */
     void Import_degrade (const Healpix_Map<T> &orig, bool pessimistic=false);
 
@@ -238,20 +236,20 @@
       Healpix_Base::swap(other);
       map.swap(other.map);
       }
 
     /*! Returns the average of all defined map pixels. */
     double average() const
       {
-      kahan_adder<double> adder;
+      double avg=0;
       int pix=0;
       for (int m=0; m<npix_; ++m)
         if (!approx<double>(map[m],Healpix_undef))
-          { ++pix; adder.add(map[m]); }
-      return (pix>0) ? adder.result()/pix : Healpix_undef;
+          { ++pix; avg+=map[m]; }
+      return (pix>0) ? avg/pix : Healpix_undef;
       }
 
     /*! Adds \a val to all defined map pixels. */
     void Add (T val)
       {
       for (int m=0; m<npix_; ++m)
         if (!approx<double>(map[m],Healpix_undef))
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_tables.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_tables.cc`

 * *Files 16% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2011-2014 Max-Planck-Society
+ *  Copyright (C) 2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "healpix_tables.h"
 #include "string_utils.h"
 
 using namespace std;
@@ -64,37 +64,24 @@
 #undef Y
 #undef Z
 };
 
 const int Healpix_Tables::jrll[] = { 2,2,2,2,3,3,3,3,4,4,4,4 },
           Healpix_Tables::jpll[] = { 1,3,5,7,0,2,4,6,1,3,5,7 };
 
-const uint8 Healpix_Tables::peano_arr2[] = {
-        0, 35, 65, 66, 68,  5,103,  6,110,109, 15, 44, 72,  9,107, 10,
-       31,126, 60,125, 81, 16, 82, 51,123, 88, 26, 25,119, 84, 22, 21,
-       42, 75, 41,104, 12, 47, 77, 78, 38, 71, 37,100, 98, 97,  3, 32,
-       53, 54,116, 87, 57, 58,120, 91, 19,114, 48,113, 93, 28, 94, 63,
-       64,  1, 99,  2, 46, 79, 45,108,  4, 39, 69, 70,  8, 43, 73, 74,
-       85, 20, 86, 55,115, 80, 18, 17, 89, 24, 90, 59, 61, 62,124, 95,
-      106,105, 11, 40,102,101,  7, 36, 76, 13,111, 14, 34, 67, 33, 96,
-      127, 92, 30, 29, 27,122, 56,121, 49, 50,112, 83, 23,118, 52,117,
-
-      128,194,195,161,196,133,135,230,204,141,143,238,171,233,232,138,
-      149,212,214,183,221,159,158,252,217,155,154,248,178,243,241,144,
-      175,237,236,142,235,170,168,201,227,162,160,193,132,198,199,165,
-      186,251,249,152,242,176,177,211,246,180,181,215,157,220,222,191,
-      192,129,131,226,136,202,203,169,140,206,207,173,231,166,164,197,
-      213,151,150,244,145,208,210,179,153,216,218,187,254,188,189,223,
-      239,174,172,205,167,229,228,134,163,225,224,130,200,137,139,234,
-      250,184,185,219,190,255,253,156,182,247,245,148,209,147,146,240 };
-const uint8 Healpix_Tables::peano_arr[] =
-      { 16, 1,27, 2,31,20, 6, 5,10,19, 9,24,13,14,28,23,
-         0,11,17,18,21, 4,22,15,26,25, 3, 8, 7,30,12,29,
-        48,33,35,58,53,39,38,60,59,42,40,49,62,44,45,55,
-        32,50,51,41,37,52,54,47,43,57,56,34,46,63,61,36 };
+const uint8 Healpix_Tables::peano_subpix[2][8][4] =
+  { { {0,1,3,2}, {3,0,2,1}, {2,3,1,0}, {1,2,0,3},
+      {0,3,1,2}, {1,0,2,3}, {2,1,3,0}, {3,2,0,1} },
+    { {0,1,3,2}, {1,3,2,0}, {3,2,0,1}, {2,0,1,3},
+      {0,2,3,1}, {1,0,2,3}, {3,1,0,2}, {2,3,1,0} } };
+const uint8 Healpix_Tables::peano_subpath[2][8][4] =
+  { { {4,0,6,0}, {7,5,1,1}, {2,4,2,6}, {3,3,7,5},
+      {0,2,4,4}, {5,1,5,3}, {6,6,0,2}, {1,7,3,7} },
+    { {4,0,0,6}, {5,1,1,7}, {6,2,2,4}, {7,3,3,5},
+      {0,4,4,2}, {1,5,5,3}, {2,6,6,0}, {3,7,7,1} } };
 const uint8 Healpix_Tables::peano_face2path[2][12] =
   { { 2,5,2,5,3,6,3,6,2,3,2,3 }, { 2,6,2,3,3,5,2,6,2,3,3,5 } };
 const uint8 Healpix_Tables::peano_face2face[2][12] =
   { { 0,5,6,11,10,1,4,7,2,3,8,9 }, { 0,5,8,9,6,1,2,7,10,11,4,3 } };
 
 const int Healpix_Tables::nb_xoffset[] = { -1,-1, 0, 1, 1, 1, 0,-1 },
           Healpix_Tables::nb_yoffset[] = {  0, 1, 1, 1, 0,-1,-1,-1 };
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_healpix_tools.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/alm_healpix_tools.cc`

 * *Files 5% similar despite different names*

```diff
@@ -11,33 +11,33 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2003-2015 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "alm_healpix_tools.h"
 #include "alm.h"
 #include "healpix_map.h"
 #include "xcomplex.h"
-#include "sharp_cxx.h"
+#include "psht_cxx.h"
 
 using namespace std;
 
 namespace {
 
 void checkLmaxNside(tsize lmax, tsize nside)
   {
@@ -53,18 +53,19 @@
   {
   planck_assert (map.Scheme()==RING, "map2alm: map must be in RING scheme");
   planck_assert (int(weight.size())>=2*map.Nside(),
     "map2alm: weight array has too few entries");
   planck_assert (map.fullyDefined(),"map contains undefined pixels");
   checkLmaxNside(alm.Lmax(), map.Nside());
 
-  sharp_cxxjob<T> job;
-  job.set_weighted_Healpix_geometry (map.Nside(),&weight[0]);
-  job.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
-  job.map2alm(&map[0], &alm(0,0), add_alm);
+  psht_joblist<T> joblist;
+  joblist.set_weighted_Healpix_geometry (map.Nside(),&weight[0]);
+  joblist.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
+  joblist.add_map2alm(&map[0], &alm(0,0), add_alm);
+  joblist.execute();
   }
 
 template void map2alm (const Healpix_Map<float> &map,
   Alm<xcomplex<float> > &alm, const arr<double> &weight,
   bool add_alm);
 template void map2alm (const Healpix_Map<double> &map,
   Alm<xcomplex<double> > &alm, const arr<double> &weight,
@@ -107,15 +108,14 @@
     for (int m=0; m<map.Npix(); ++m)
       {
       double err = abs(map[m]-map2[m]);
       double rel = (map[m]!=0) ? abs(err/map[m]) : 1e300;
       errmeasure = max(errmeasure,min(err*x_err_abs,rel*x_err_rel));
       map2[m] = map[m]-map2[m];
       }
-//cout << errmeasure << endl;
     if (errmeasure<1) break;
     }
   }
 
 template void map2alm_iter2 (const Healpix_Map<double> &map,
   Alm<xcomplex<double> > &alm, double err_abs, double err_rel);
 
@@ -133,18 +133,20 @@
     "map2alm_spin: a_lm are not conformable");
   planck_assert (int(weight.size())>=2*map1.Nside(),
     "map2alm_spin: weight array has too few entries");
   planck_assert (map1.fullyDefined()&&map2.fullyDefined(),
     "map contains undefined pixels");
   checkLmaxNside(alm1.Lmax(), map1.Nside());
 
-  sharp_cxxjob<T> job;
-  job.set_weighted_Healpix_geometry (map1.Nside(),&weight[0]);
-  job.set_triangular_alm_info (alm1.Lmax(), alm1.Mmax());
-  job.map2alm_spin(&map1[0],&map2[0],&alm1(0,0),&alm2(0,0),spin,add_alm);
+  psht_joblist<T> joblist;
+  joblist.set_weighted_Healpix_geometry (map1.Nside(),&weight[0]);
+  joblist.set_triangular_alm_info (alm1.Lmax(), alm1.Mmax());
+  joblist.add_map2alm_spin(&map1[0], &map2[0], &alm1(0,0), &alm2(0,0),
+    spin, add_alm);
+  joblist.execute();
   }
 
 template void map2alm_spin
   (const Healpix_Map<float> &map1, const Healpix_Map<float> &map2,
    Alm<xcomplex<float> > &alm1, Alm<xcomplex<float> > &alm2,
    int spin, const arr<double> &weight, bool add_alm);
 template void map2alm_spin
@@ -173,15 +175,14 @@
       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
       map1b[m] = map1[m]-map1b[m];
       err = abs(map2[m]-map2b[m]);
       rel = (map2[m]!=0) ? abs(err/map2[m]) : 1e300;
       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
       map2b[m] = map2[m]-map2b[m];
       }
-//cout << errmeasure << endl;
     if (errmeasure<1) break;
     }
   }
 
 template void map2alm_spin_iter2
   (const Healpix_Map<double> &map1, const Healpix_Map<double> &map2,
    Alm<xcomplex<double> > &alm1, Alm<xcomplex<double> > &alm2,
@@ -205,19 +206,20 @@
     "map2alm_pol: a_lm are not conformable");
   planck_assert (int(weight.size())>=2*mapT.Nside(),
     "map2alm_pol: weight array has too few entries");
   planck_assert (mapT.fullyDefined()&&mapQ.fullyDefined()&&mapU.fullyDefined(),
     "map contains undefined pixels");
   checkLmaxNside(almT.Lmax(), mapT.Nside());
 
-  sharp_cxxjob<T> job;
-  job.set_weighted_Healpix_geometry (mapT.Nside(),&weight[0]);
-  job.set_triangular_alm_info (almT.Lmax(), almT.Mmax());
-  job.map2alm(&mapT[0], &almT(0,0), add_alm);
-  job.map2alm_spin(&mapQ[0],&mapU[0],&almG(0,0),&almC(0,0),2,add_alm);
+  psht_joblist<T> joblist;
+  joblist.set_weighted_Healpix_geometry (mapT.Nside(),&weight[0]);
+  joblist.set_triangular_alm_info (almT.Lmax(), almT.Mmax());
+  joblist.add_map2alm_pol(&mapT[0], &mapQ[0], &mapU[0], &almT(0,0),
+    &almG(0,0), &almC(0,0), add_alm);
+  joblist.execute();
   }
 
 template void map2alm_pol
   (const Healpix_Map<float> &mapT,
    const Healpix_Map<float> &mapQ,
    const Healpix_Map<float> &mapU,
    Alm<xcomplex<float> > &almT,
@@ -312,15 +314,14 @@
       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
       mapQ2[m] = mapQ[m]-mapQ2[m];
       err = abs(mapU[m]-mapU2[m]);
       rel = (mapU[m]!=0) ? abs(err/mapU[m]) : 1e300;
       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
       mapU2[m] = mapU[m]-mapU2[m];
       }
-//cout << errmeasure << endl;
     if (errmeasure<1) break;
     }
   }
 
 template void map2alm_pol_iter2
   (const Healpix_Map<double> &mapT,
    const Healpix_Map<double> &mapQ,
@@ -332,18 +333,19 @@
 
 
 template<typename T> void alm2map (const Alm<xcomplex<T> > &alm,
   Healpix_Map<T> &map)
   {
   planck_assert (map.Scheme()==RING, "alm2map: map must be in RING scheme");
 
-  sharp_cxxjob<T> job;
-  job.set_Healpix_geometry (map.Nside());
-  job.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
-  job.alm2map(&alm(0,0), &map[0], false);
+  psht_joblist<T> joblist;
+  joblist.set_Healpix_geometry (map.Nside());
+  joblist.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
+  joblist.add_alm2map(&alm(0,0), &map[0], false);
+  joblist.execute();
   }
 
 template void alm2map (const Alm<xcomplex<double> > &alm,
   Healpix_Map<double> &map);
 template void alm2map (const Alm<xcomplex<float> > &alm,
   Healpix_Map<float> &map);
 
@@ -354,18 +356,20 @@
   planck_assert (map1.Scheme()==RING,
     "alm2map_spin: maps must be in RING scheme");
   planck_assert (map1.conformable(map2),
     "alm2map_spin: maps are not conformable");
   planck_assert (alm1.conformable(alm2),
     "alm2map_spin: a_lm are not conformable");
 
-  sharp_cxxjob<T> job;
-  job.set_Healpix_geometry (map1.Nside());
-  job.set_triangular_alm_info (alm1.Lmax(), alm1.Mmax());
-  job.alm2map_spin(&alm1(0,0),&alm2(0,0),&map1[0],&map2[0],spin,false);
+  psht_joblist<T> joblist;
+  joblist.set_Healpix_geometry (map1.Nside());
+  joblist.set_triangular_alm_info (alm1.Lmax(), alm1.Mmax());
+  joblist.add_alm2map_spin(&alm1(0,0), &alm2(0,0), &map1[0], &map2[0],
+    spin, false);
+  joblist.execute();
   }
 
 template void alm2map_spin
   (const Alm<xcomplex<double> > &alm1, const Alm<xcomplex<double> > &alm2,
    Healpix_Map<double> &map, Healpix_Map<double> &map2, int spin);
 template void alm2map_spin
   (const Alm<xcomplex<float> > &alm1, const Alm<xcomplex<float> > &alm2,
@@ -383,19 +387,20 @@
   planck_assert (mapT.Scheme()==RING,
     "alm2map_pol: maps must be in RING scheme");
   planck_assert (mapT.conformable(mapQ) && mapT.conformable(mapU),
     "alm2map_pol: maps are not conformable");
   planck_assert (almT.conformable(almG) && almT.conformable(almC),
     "alm2map_pol: a_lm are not conformable");
 
-  sharp_cxxjob<T> job;
-  job.set_Healpix_geometry (mapT.Nside());
-  job.set_triangular_alm_info (almT.Lmax(), almT.Mmax());
-  job.alm2map(&almT(0,0), &mapT[0], false);
-  job.alm2map_spin(&almG(0,0), &almC(0,0), &mapQ[0], &mapU[0], 2, false);
+  psht_joblist<T> joblist;
+  joblist.set_Healpix_geometry (mapT.Nside());
+  joblist.set_triangular_alm_info (almT.Lmax(), almT.Mmax());
+  joblist.add_alm2map_pol(&almT(0,0), &almG(0,0), &almC(0,0), &mapT[0],
+    &mapQ[0], &mapU[0], false);
+  joblist.execute();
   }
 
 template void alm2map_pol (const Alm<xcomplex<double> > &almT,
                            const Alm<xcomplex<double> > &almG,
                            const Alm<xcomplex<double> > &almC,
                            Healpix_Map<double> &mapT,
                            Healpix_Map<double> &mapQ,
@@ -416,19 +421,20 @@
    Healpix_Map<T> &mapdph)
   {
   planck_assert (map.Scheme()==RING,
     "alm2map_der1: maps must be in RING scheme");
   planck_assert (map.conformable(mapdth) && map.conformable(mapdph),
     "alm2map_der1: maps are not conformable");
 
-  sharp_cxxjob<T> job;
-  job.set_Healpix_geometry (map.Nside());
-  job.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
-  job.alm2map(&alm(0,0), &map[0], false);
-  job.alm2map_der1(&alm(0,0), &mapdth[0], &mapdph[0], false);
+  psht_joblist<T> joblist;
+  joblist.set_Healpix_geometry (map.Nside());
+  joblist.set_triangular_alm_info (alm.Lmax(), alm.Mmax());
+  joblist.add_alm2map(&alm(0,0), &map[0], false);
+  joblist.add_alm2map_der1(&alm(0,0), &mapdth[0], &mapdph[0], false);
+  joblist.execute();
   }
 
 template void alm2map_der1 (const Alm<xcomplex<double> > &alm,
                             Healpix_Map<double> &map,
                             Healpix_Map<double> &map_dth,
                             Healpix_Map<double> &map_dph);
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_base.h` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_base.h`

 * *Files 9% similar despite different names*

```diff
@@ -11,41 +11,37 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file healpix_base.h
- *  Copyright (C) 2003-2014 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef HEALPIX_BASE_H
 #define HEALPIX_BASE_H
 
 #include <vector>
 #include "healpix_tables.h"
 #include "pointing.h"
 #include "arr.h"
 #include "rangeset.h"
 
-template<typename I> struct Orderhelper__ {};
-template<> struct Orderhelper__<int> {enum{omax=13};};
-template<> struct Orderhelper__<int64> {enum{omax=29};};
-
 /*! Functionality related to the HEALPix pixelisation. */
 template<typename I> class T_Healpix_Base: public Healpix_Tables
   {
   protected:
     /*! The order of the map; -1 for nonhierarchical map. */
     int order_;
     /*! The N_side parameter of the map; 0 if not allocated. */
@@ -56,16 +52,16 @@
     Healpix_Ordering_Scheme scheme_;
 
     /*! Returns the number of the next ring to the north of \a z=cos(theta).
         It may return 0; in this case \a z lies north of all rings. */
     inline I ring_above (double z) const;
     void in_ring (I iz, double phi0, double dphi, rangeset<I> &pixset) const;
 
-    template<typename I2> void query_multidisc (const arr<vec3> &norm,
-      const arr<double> &rad, int fact, rangeset<I2> &pixset) const;
+    void query_multidisc (const arr<vec3> &norm, const arr<double> &rad,
+      bool inclusive, rangeset<I> &pixset) const;
 
     void query_multidisc_general (const arr<vec3> &norm, const arr<double> &rad,
       bool inclusive, const std::vector<int> &cmds, rangeset<I> &pixset) const;
 
     void query_strip_internal (double theta1, double theta2, bool inclusive,
       rangeset<I> &pixset) const;
 
@@ -77,23 +73,20 @@
     I xyf2ring(int ix, int iy, int face_num) const;
     void ring2xyf(I pix, int &ix, int &iy, int &face_num) const;
 
     I loc2pix (double z, double phi, double sth, bool have_sth) const;
     void pix2loc (I pix, double &z, double &phi, double &sth, bool &have_sth)
       const;
 
-    void xyf2loc(double x, double y, int face, double &z, double &ph,
-      double &sth, bool &have_sth) const;
-
     I nest_peano_helper (I pix, int dir) const;
 
     typedef I (T_Healpix_Base::*swapfunc)(I pix) const;
 
   public:
-    enum {order_max=Orderhelper__<I>::omax};
+    static const int order_max;
 
     /*! Calculates the map order from its \a N_side parameter.
         Returns -1 if \a nside is not a power of 2.
         \param nside the \a N_side parameter */
     static int nside2order (I nside);
     /*! Calculates the \a N_side parameter from the number of pixels.
         \param npix the number of pixels */
@@ -147,16 +140,14 @@
     I zphi2pix (double z, double phi) const
       { return loc2pix(z,phi,0.,false); }
 
     /*! Returns the number of the pixel which contains the angular coordinates
         \a ang. */
     I ang2pix (const pointing &ang) const
       {
-      const double pi_=3.141592653589793238462643383279502884197;
-      planck_assert((ang.theta>=0)&&(ang.theta<=pi_),"invalid theta value");
       return ((ang.theta<0.01) || (ang.theta > 3.14159-0.01)) ?
         loc2pix(cos(ang.theta),ang.phi,sin(ang.theta),true) :
         loc2pix(cos(ang.theta),ang.phi,0.,false);
       }
     /*! Returns the number of the pixel which contains the vector \a vec
         (\a vec is normalized if necessary). */
     I vec2pix (const vec3 &vec) const
@@ -200,99 +191,61 @@
       else
         {
         vec3 res;
         res.set_z_phi (z, phi);
         return res;
         }
       }
-    /*! Returns the pixel number for this T_Healpix_Base corresponding to the
-        pixel number \a pix in \a b.
-        \note \a b.Nside()\%Nside() must be 0. */
-    I pixel_import (I pix, const T_Healpix_Base &b) const
-      {
-      I ratio = b.nside_/nside_;
-      planck_assert(nside_*ratio==b.nside_,"bad nside ratio");
-      int x, y, f;
-      b.pix2xyf(pix, x, y, f);
-      x/=ratio; y/=ratio;
-      return xyf2pix(x, y, f);
-      }
-
-    template<typename I2> void query_disc_internal (pointing ptg, double radius,
-      int fact, rangeset<I2> &pixset) const;
 
-    /*! Returns the range set of all pixels whose centers lie within the disk
-        defined by \a dir and \a radius.
-        \param dir the angular coordinates of the disk center
-        \param radius the radius (in radians) of the disk
-        \param pixset a \a rangeset object containing the indices of all pixels
-           whose centers lie inside the disk
-        \note This method is more efficient in the RING scheme. */
-    void query_disc (pointing ptg, double radius, rangeset<I> &pixset) const;
-    /*! Returns the range set of all pixels which overlap with the disk
-        defined by \a dir and \a radius.
+    /*! Returns a range set of pixels whose centers lie within the disk
+        defined by \a dir and \a radius (if \a inclusive==false), or which
+        overlap with this disk (if \a inclusive==true).
         \param dir the angular coordinates of the disk center
         \param radius the radius (in radians) of the disk
+        \param inclusive if \a false, return the exact set of pixels whose
+           pixel centers lie within the disk; if \a true, return all pixels
+           that overlap with the disk, and maybe a few more.
         \param pixset a \a rangeset object containing the indices of all pixels
-           overlapping with the disk.
-        \param fact The overlapping test will be done at the resolution
-           \a fact*nside. For NESTED ordering, \a fact must be a power of 2,
-           else it can be any positive integer. A typical choice would be 4.
-        \note This method may return some pixels which don't overlap with
-           the disk at all. The higher \a fact is chosen, the fewer false
-           positives are returned, at the cost of increased run time.
-        \note This method is more efficient in the RING scheme. */
-    void query_disc_inclusive (pointing ptg, double radius, rangeset<I> &pixset,
-      int fact=1) const;
+           within the disk
+        \note This method is more efficient in the RING scheme, but the
+           algorithm used for \a inclusive==true returns fewer false positives
+           in the NEST scheme. */
+    void query_disc (pointing ptg, double radius, bool inclusive,
+      rangeset<I> &pixset) const;
 
     /*! \deprecated Please use the version based on \a rangeset */
     void query_disc (const pointing &dir, double radius,
       std::vector<I> &listpix) const
       {
       rangeset<I> pixset;
-      query_disc(dir,radius,pixset);
+      query_disc(dir,radius,false,pixset);
       pixset.toVector(listpix);
       }
     /*! \deprecated Please use the version based on \a rangeset */
     void query_disc_inclusive (const pointing &dir, double radius,
-      std::vector<I> &listpix, int fact=1) const
+      std::vector<I> &listpix) const
       {
       rangeset<I> pixset;
-      query_disc_inclusive(dir,radius,pixset,fact);
+      query_disc(dir,radius,true,pixset);
       pixset.toVector(listpix);
       }
 
-    template<typename I2> void query_polygon_internal
-      (const std::vector<pointing> &vertex, int fact,
-      rangeset<I2> &pixset) const;
-
     /*! Returns a range set of pixels whose centers lie within the convex
-        polygon defined by the \a vertex array.
+        polygon defined by the \a vertex array (if \a inclusive==false), or
+        which overlap with this polygon (if \a inclusive==true).
         \param vertex array containing the vertices of the polygon.
-        \param pixset a \a rangeset object containing the indices of all pixels
-           whose centers lie inside the polygon
-        \note This method is more efficient in the RING scheme. */
-    void query_polygon (const std::vector<pointing> &vertex,
+        \param inclusive if \a false, return the exact set of pixels whose
+           pixel centers lie within the polygon; if \a true, return all pixels
+           that overlap with the polygon, and maybe a few more.
+        \note This method is more efficient in the RING scheme, but the
+           algorithm used for \a inclusive==true returns fewer false positives
+           in the NEST scheme. */
+    void query_polygon (const std::vector<pointing> &vertex, bool inclusive,
       rangeset<I> &pixset) const;
 
-    /*! Returns a range set of pixels which overlap with the convex
-        polygon defined by the \a vertex array.
-        \param vertex array containing the vertices of the polygon.
-        \param pixset a \a rangeset object containing the indices of all pixels
-           overlapping with the polygon.
-        \param fact The overlapping test will be done at the resolution
-           \a fact*nside. For NESTED ordering, \a fact must be a power of 2,
-           else it can be any positive integer. A typical choice would be 4.
-        \note This method may return some pixels which don't overlap with
-           the polygon at all. The higher \a fact is chosen, the fewer false
-           positives are returned, at the cost of increased run time.
-        \note This method is more efficient in the RING scheme. */
-    void query_polygon_inclusive (const std::vector<pointing> &vertex,
-      rangeset<I> &pixset, int fact=1) const;
-
     /*! Returns a range set of pixels whose centers lie within the colatitude
         range defined by \a theta1 and \a theta2 (if \a inclusive==false), or
         which overlap with this region (if \a inclusive==true). If
         \a theta1<theta2, the region between both angles is considered,
         otherwise the regions \a 0<theta<theta2 and \a theta1<theta<pi.
         \param theta1 first colatitude
         \param theta2 second colatitude
@@ -370,22 +323,14 @@
         center and its corners. */
     double max_pixrad() const;
 
     /*! Returns the maximum angular distance (in radian) between any pixel
         center and its corners in a given ring. */
     double max_pixrad(I ring) const;
 
-    /*! Returns a set of points along the boundary of the given pixel.
-        \a step=1 gives 4 points on the corners. The first point corresponds
-        to the northernmost corner, the subsequent points follow the pixel
-        boundary through west, south and east corners.
-        \param pix pixel index number
-        \param step the number of returned points is 4*step. */
-    void boundaries (I pix, tsize step, std::vector<vec3> &out) const;
-
     arr<int> swap_cycles() const;
   };
 
 /*! T_Healpix_Base for Nside up to 2^13. */
 typedef T_Healpix_Base<int> Healpix_Base;
 /*! T_Healpix_Base for Nside up to 2^29. */
 typedef T_Healpix_Base<int64> Healpix_Base2;
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/powspec.cc`

 * *Files 2% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2003-2015 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "powspec.h"
 #include "lsconstants.h"
 
 using namespace std;
@@ -135,27 +135,23 @@
   num_specs = 6;
   tc_.transfer(tc_new); gc_.transfer(gc_new);
   assertArraySizes();
   }
 
 void PowSpec::smoothWithGauss (double fwhm)
   {
+  planck_assert (num_specs<=4, "not yet implemented for num_specs>4");
   double sigma = fwhm*fwhm2sigma;
   double fact_pol = exp(2*sigma*sigma);
   for (tsize l=0; l<tt_.size(); ++l)
     {
     double f1 = exp(-.5*l*(l+1)*sigma*sigma);
     double f2 = f1*fact_pol;
     tt_[l] *= f1*f1;
     if (num_specs>1)
       {
       gg_[l] *= f2*f2;
       cc_[l] *= f2*f2;
       tg_[l] *= f1*f2;
-      if (num_specs>4)
-        {
-        tc_[l] *= f1*f2;
-        gc_[l] *= f2*f2;
-        }
       }
     }
   }
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_base.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_base.cc`

 * *Files 6% similar despite different names*

```diff
@@ -11,34 +11,39 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2003-2015 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "healpix_base.h"
 #include "geom_utils.h"
 #include "lsconstants.h"
 
 using namespace std;
 
+const int OPLUS=2, FACT=1<<OPLUS;
+
+template<> const int T_Healpix_Base<int  >::order_max=13;
+template<> const int T_Healpix_Base<int64>::order_max=29;
+
 template<typename I> int T_Healpix_Base<I>::nside2order (I nside)
   {
   planck_assert (nside>I(0), "invalid value for Nside");
   return ((nside)&(nside-1)) ? -1 : ilog2(nside);
   }
 template<typename I> I T_Healpix_Base<I>::npix2nside (I npix)
   {
@@ -60,39 +65,39 @@
 
 /* Short note on the "zone":
    zone = 0: pixel lies completely outside the queried shape
           1: pixel may overlap with the shape, pixel center is outside
           2: pixel center is inside the shape, but maybe not the complete pixel
           3: pixel lies completely inside the shape */
 
-template<typename I, typename I2> inline void check_pixel (int o, int order_,
-  int omax, int zone, rangeset<I2> &pixset, I pix, vector<pair<I,int> > &stk,
+template<typename I> inline void check_pixel (int o, int order_, int omax,
+  int zone, rangeset<I> &pixset, I pix, vector<pair<I,int> > &stk,
   bool inclusive, int &stacktop)
   {
   if (zone==0) return;
 
   if (o<order_)
     {
     if (zone>=3)
       {
       int sdist=2*(order_-o); // the "bit-shift distance" between map orders
       pixset.append(pix<<sdist,(pix+1)<<sdist); // output all subpixels
       }
-    else // (1<=zone<=2)
+    else // (zone>=1)
       for (int i=0; i<4; ++i)
         stk.push_back(make_pair(4*pix+3-i,o+1)); // add children
     }
   else if (o>order_) // this implies that inclusive==true
     {
     if (zone>=2) // pixel center in shape
       {
       pixset.append(pix>>(2*(o-order_))); // output the parent pixel at order_
       stk.resize(stacktop); // unwind the stack
       }
-    else // (zone==1): pixel center in safety range
+    else // (zone>=1): pixel center in safety range
       {
       if (o<omax) // check sublevels
         for (int i=0; i<4; ++i) // add children in reverse order
           stk.push_back(make_pair(4*pix+3-i,o+1));
       else // at resolution limit
         {
         pixset.append(pix>>(2*(o-order_))); // output the parent pixel at order_
@@ -146,31 +151,23 @@
       return false;
     }
   return true;
   }
 
 } // unnamed namespace
 
-template<typename I> template<typename I2>
-  void T_Healpix_Base<I>::query_disc_internal
-  (pointing ptg, double radius, int fact, rangeset<I2> &pixset) const
+template<typename I> void T_Healpix_Base<I>::query_disc (pointing ptg,
+  double radius, bool inclusive, rangeset<I> &pixset) const
   {
-  bool inclusive = (fact!=0);
   pixset.clear();
   ptg.normalize();
 
   if (scheme_==RING)
     {
-    I fct=1;
-    if (inclusive)
-      {
-      planck_assert (((I(1)<<order_max)/nside_)>=fact,
-        "invalid oversampling factor");
-      fct = fact;
-      }
+    I fct = inclusive ? min(I(FACT),(I(1)<<order_max)/nside_) : 1;
     T_Healpix_Base b2;
     double rsmall, rbig;
     if (fct>1)
       {
       b2.SetNside(fct*nside_,RING);
       rsmall = radius+b2.max_pixrad();
       rbig = radius+max_pixrad();
@@ -211,77 +208,62 @@
     if ((fct>1) && (rlat2<pi)) irmax=min(4*nside_-1,irmax+1);
 
     for (I iz=irmin; iz<=irmax; ++iz)
       {
       double z=ring2z(iz);
       double x = (cosrbig-z*z0)*xa;
       double ysq = 1-z*z-x*x;
-      double dphi=-1;
-      if (ysq<=0) // no intersection, ring completely inside or outside
-        dphi = (fct==1) ? 0: pi-1e-15;
-      else
-        dphi = atan2(sqrt(ysq),x);
-      if (dphi>0)
-        {
-        I nr, ipix1;
-        bool shifted;
-        get_ring_info_small(iz,ipix1,nr,shifted);
-        double shift = shifted ? 0.5 : 0.;
+      double dphi = (ysq<=0) ? pi-1e-15 : atan2(sqrt(ysq),x);
+      I nr, ipix1;
+      bool shifted;
+      get_ring_info_small(iz,ipix1,nr,shifted);
+      double shift = shifted ? 0.5 : 0.;
 
-        I ipix2 = ipix1 + nr - 1; // highest pixel number in the ring
+      I ipix2 = ipix1 + nr - 1; // highest pixel number in the ring
 
-        I ip_lo = ifloor<I>(nr*inv_twopi*(ptg.phi-dphi) - shift)+1;
-        I ip_hi = ifloor<I>(nr*inv_twopi*(ptg.phi+dphi) - shift);
+      I ip_lo = ifloor<I>(nr*inv_twopi*(ptg.phi-dphi) - shift)+1;
+      I ip_hi = ifloor<I>(nr*inv_twopi*(ptg.phi+dphi) - shift);
 
-        if (fct>1)
-          {
-          while ((ip_lo<=ip_hi) && check_pixel_ring
-                (*this,b2,ip_lo,nr,ipix1,fct,z0,ptg.phi,cosrsmall,cpix))
-            ++ip_lo;
-          while ((ip_hi>ip_lo) && check_pixel_ring
-                (*this,b2,ip_hi,nr,ipix1,fct,z0,ptg.phi,cosrsmall,cpix))
-            --ip_hi;
-          }
+      if (fct>1)
+        {
+        while ((ip_lo<=ip_hi) && check_pixel_ring
+               (*this,b2,ip_lo,nr,ipix1,fct,z0,ptg.phi,cosrsmall,cpix))
+          ++ip_lo;
+        while ((ip_hi>ip_lo) && check_pixel_ring
+               (*this,b2,ip_hi,nr,ipix1,fct,z0,ptg.phi,cosrsmall,cpix))
+          --ip_hi;
+        }
 
-        if (ip_lo<=ip_hi)
+      if (ip_lo<=ip_hi)
+        {
+        if (ip_hi>=nr)
+          { ip_lo-=nr; ip_hi-=nr; }
+        if (ip_lo<0)
           {
-          if (ip_hi>=nr)
-            { ip_lo-=nr; ip_hi-=nr; }
-          if (ip_lo<0)
-            {
-            pixset.append(ipix1,ipix1+ip_hi+1);
-            pixset.append(ipix1+ip_lo+nr,ipix2+1);
-            }
-          else
-            pixset.append(ipix1+ip_lo,ipix1+ip_hi+1);
+          pixset.append(ipix1,ipix1+ip_hi+1);
+          pixset.append(ipix1+ip_lo+nr,ipix2+1);
           }
+        else
+          pixset.append(ipix1+ip_lo,ipix1+ip_hi+1);
         }
       }
     if ((rlat2>=pi) && (irmax+1<4*nside_)) // south pole in the disk
       {
       I sp,rp; bool dummy;
       get_ring_info_small(irmax+1,sp,rp,dummy);
       pixset.append(sp,npix_);
       }
     }
   else // scheme_==NEST
     {
     if (radius>=pi) // disk covers the whole sphere
       { pixset.append(0,npix_); return; }
 
-    int oplus = 0;
-    if (inclusive)
-      {
-      planck_assert ((I(1)<<(order_max-order_))>=fact,
-        "invalid oversampling factor");
-      planck_assert ((fact&(fact-1))==0,
-        "oversampling factor must be a power of 2");
-      oplus=ilog2(fact);
-      }
-    int omax=order_+oplus; // the order up to which we test
+    int oplus=inclusive ? OPLUS : 0;
+    int omax=min(int(order_max),order_+oplus); // the order up to which we test
 
     vec3 vptg(ptg);
     arr<T_Healpix_Base<I> > base(omax+1);
     arr<double> crpdr(omax+1), crmdr(omax+1);
     double cosrad=cos(radius);
     for (int o=0; o<=omax; ++o) // prepare data at the required orders
       {
@@ -316,51 +298,25 @@
         check_pixel (o, order_, omax, zone, pixset, pix, stk, inclusive,
           stacktop);
         }
       }
     }
   }
 
-template<typename I> void T_Healpix_Base<I>::query_disc
-  (pointing ptg, double radius, rangeset<I> &pixset) const
-  {
-  query_disc_internal (ptg, radius, 0, pixset);
-  }
-
-template<typename I> void T_Healpix_Base<I>::query_disc_inclusive
-  (pointing ptg, double radius, rangeset<I> &pixset, int fact) const
-  {
-  planck_assert(fact>0,"fact must be a positive integer");
-  if ((sizeof(I)<8) && (((I(1)<<order_max)/nside_)<fact))
-    {
-    T_Healpix_Base<int64> base2(nside_,scheme_,SET_NSIDE);
-    base2.query_disc_internal(ptg,radius,fact,pixset);
-    return;
-    }
-  query_disc_internal (ptg, radius, fact, pixset);
-  }
-
-template<typename I> template<typename I2>
-  void T_Healpix_Base<I>::query_multidisc (const arr<vec3> &norm,
-  const arr<double> &rad, int fact, rangeset<I2> &pixset) const
+template<typename I> void T_Healpix_Base<I>::query_multidisc
+  (const arr<vec3> &norm, const arr<double> &rad, bool inclusive,
+  rangeset<I> &pixset) const
   {
-  bool inclusive = (fact!=0);
   tsize nv=norm.size();
   planck_assert(nv==rad.size(),"inconsistent input arrays");
   pixset.clear();
 
   if (scheme_==RING)
     {
-    I fct=1;
-    if (inclusive)
-      {
-      planck_assert (((I(1)<<order_max)/nside_)>=fact,
-        "invalid oversampling factor");
-      fct = fact;
-      }
+    I fct = inclusive ? min(I(FACT),(I(1)<<order_max)/nside_) : 1;
     T_Healpix_Base b2;
     double rpsmall, rpbig;
     if (fct>1)
       {
       b2.SetNside(fct*nside_,RING);
       rpsmall = b2.max_pixrad();
       rpbig = max_pixrad();
@@ -407,15 +363,16 @@
     for (I iz=irmin; iz<=irmax; ++iz)
       {
       double z=ring2z(iz);
       I ipix1,nr;
       bool shifted;
       get_ring_info_small(iz,ipix1,nr,shifted);
       double shift = shifted ? 0.5 : 0.;
-      rangeset<I2> tr;
+      I ipix2 = ipix1 + nr - 1; // highest pixel number in the ring
+      rangeset<I> tr;
       tr.append(ipix1,ipix1+nr);
       for (tsize j=0; j<z0.size(); ++j)
         {
         double x = (cosrbig[j]-z*z0[j])*xa[j];
         double ysq = 1.-z*z-x*x;
         double dphi = (ysq<=0) ? pi-1e-15 : atan2(sqrt(ysq),x);
         I ip_lo = ifloor<I>(nr*inv_twopi*(ptg[j].phi-dphi) - shift)+1;
@@ -430,31 +387,27 @@
             --ip_hi;
           }
         if (ip_hi>=nr)
           { ip_lo-=nr; ip_hi-=nr;}
         if (ip_lo<0)
           tr.remove(ipix1+ip_hi+1,ipix1+ip_lo+nr);
         else
-          tr.intersect(ipix1+ip_lo,ipix1+ip_hi+1);
+          {
+          tr.remove(ipix1,ipix1+ip_lo);
+          tr.remove(ipix1+ip_hi+1,ipix2+1);
+          }
         }
-      pixset.append(tr);
+      for (tsize j=0; j<tr.size(); ++j)
+        pixset.append(tr[j]);
       }
     }
   else // scheme_ == NEST
     {
-    int oplus = 0;
-    if (inclusive)
-      {
-      planck_assert ((I(1)<<(order_max-order_))>=fact,
-        "invalid oversampling factor");
-      planck_assert ((fact&(fact-1))==0,
-        "oversampling factor must be a power of 2");
-      oplus=ilog2(fact);
-      }
-    int omax=order_+oplus; // the order up to which we test
+    int oplus=inclusive ? OPLUS : 0;
+    int omax=min(order_max,order_+oplus); // the order up to which we test
 
     // TODO: ignore all disks with radius>=pi
 
     arr<T_Healpix_Base<I> > base(omax+1);
     arr3<double> crlimit(omax+1,nv,3);
     for (int o=0; o<=omax; ++o) // prepare data at the required orders
       {
@@ -511,15 +464,15 @@
   if (scheme_==RING)
     {
     planck_fail ("not yet implemented");
     }
   else // scheme_ == NEST
     {
     int oplus=inclusive ? 2 : 0;
-    int omax=min<int>(order_max,order_+oplus); // the order up to which we test
+    int omax=min(order_max,order_+oplus); // the order up to which we test
 
     // TODO: ignore all disks with radius>=pi
 
     arr<T_Healpix_Base<I> > base(omax+1);
     arr3<double> crlimit(omax+1,nv,3);
     for (int o=0; o<=omax; ++o) // prepare data at the required orders
       {
@@ -767,27 +720,24 @@
   ring2xyf (pix, ix, iy, face_num);
   return xyf2nest (ix, iy, face_num);
   }
 
 template<typename I> inline I T_Healpix_Base<I>::nest_peano_helper
   (I pix, int dir) const
   {
-  int face = (pix>>(2*order_));
+  int face = pix>>(2*order_);
   I result = 0;
-  int state = ((peano_face2path[dir][face]<<4))|(dir<<7);
-  int shift=2*order_-4;
-  for (; shift>=0; shift-=4)
-    {
-    state=peano_arr2[(state&0xF0) | ((pix>>shift)&0xF)];
-    result = (result<<4) | (state&0xF);
-    }
-  if (shift==-2)
+  uint8 path = peano_face2path[dir][face];
+
+  for (int shift=2*order_-2; shift>=0; shift-=2)
     {
-    state=peano_arr[((state>>2)&0xFC) | (pix&0x3)];
-    result = (result<<2) | (state&0x3);
+    uint8 spix = uint8((pix>>shift) & 0x3);
+    result <<= 2;
+    result |= peano_subpix[dir][path][spix];
+    path=peano_subpath[dir][path][spix];
     }
 
   return result + (I(peano_face2face[dir][face])<<(2*order_));
   }
 
 template<typename I> I T_Healpix_Base<I>::nest2peano (I pix) const
   { return nest_peano_helper(pix,0); }
@@ -946,65 +896,44 @@
     planck_assert(tmp<8*nr,"must not happen");
     if (tmp<0) tmp+=8*nr;
     phi = (nr==nside_) ? 0.75*halfpi*tmp*fact1_ :
                          (0.5*halfpi*tmp)/nr;
     }
   }
 
-template<typename I> template<typename I2>
-  void T_Healpix_Base<I>::query_polygon_internal
-  (const vector<pointing> &vertex, int fact, rangeset<I2> &pixset) const
+template<typename I> void T_Healpix_Base<I>::query_polygon
+  (const vector<pointing> &vertex, bool inclusive, rangeset<I> &pixset) const
   {
-  bool inclusive = (fact!=0);
   tsize nv=vertex.size();
   tsize ncirc = inclusive ? nv+1 : nv;
   planck_assert(nv>=3,"not enough vertices in polygon");
   arr<vec3> vv(nv);
   for (tsize i=0; i<nv; ++i)
     vv[i]=vertex[i].to_vec3();
   arr<vec3> normal(ncirc);
   int flip=0;
   for (tsize i=0; i<nv; ++i)
     {
-    normal[i]=crossprod(vv[i],vv[(i+1)%nv]).Norm();
+    normal[i]=crossprod(vv[i],vv[(i+1)%nv]);
     double hnd=dotprod(normal[i],vv[(i+2)%nv]);
     planck_assert(abs(hnd)>1e-10,"degenerate corner");
     if (i==0)
       flip = (hnd<0.) ? -1 : 1;
     else
       planck_assert(flip*hnd>0,"polygon is not convex");
-    normal[i]*=flip;
+    normal[i]*=flip/normal[i].Length();
     }
   arr<double> rad(ncirc,halfpi);
   if (inclusive)
     {
     double cosrad;
     find_enclosing_circle (vv, normal[nv], cosrad);
     rad[nv]=acos(cosrad);
     }
-  query_multidisc(normal,rad,fact,pixset);
-  }
-
-template<typename I> void T_Healpix_Base<I>::query_polygon
-  (const vector<pointing> &vertex, rangeset<I> &pixset) const
-  {
-  query_polygon_internal(vertex, 0, pixset);
-  }
-
-template<typename I> void T_Healpix_Base<I>::query_polygon_inclusive
-  (const vector<pointing> &vertex, rangeset<I> &pixset, int fact) const
-  {
-  planck_assert(fact>0,"fact must be a positive integer");
-  if ((sizeof(I)<8) && (((I(1)<<order_max)/nside_)<fact))
-    {
-    T_Healpix_Base<int64> base2(nside_,scheme_,SET_NSIDE);
-    base2.query_polygon_internal(vertex,fact,pixset);
-    return;
-    }
-  query_polygon_internal(vertex, fact, pixset);
+  query_multidisc(normal,rad,inclusive,pixset);
   }
 
 template<typename I> void T_Healpix_Base<I>::query_strip_internal
   (double theta1, double theta2, bool inclusive, rangeset<I> &pixset) const
   {
   if (scheme_==RING)
     {
@@ -1036,15 +965,16 @@
   if (theta1<theta2)
     query_strip_internal(theta1,theta2,inclusive,pixset);
   else
     {
     query_strip_internal(0.,theta2,inclusive,pixset);
     rangeset<I> ps2;
     query_strip_internal(theta1,pi,inclusive,ps2);
-    pixset.append(ps2);
+    for (tsize i=0; i<ps2.size(); ++i)
+      pixset.appendRelaxed(ps2[i]);
     }
   }
 
 template<typename I> inline void T_Healpix_Base<I>::get_ring_info_small
   (I ring, I &startpix, I &ringpix, bool &shifted) const
   {
   if (ring < nside_)
@@ -1178,15 +1108,14 @@
       }
     }
   }
 
 template<typename I> void T_Healpix_Base<I>::get_interpol (const pointing &ptg,
   fix_arr<I,4> &pix, fix_arr<double,4> &wgt) const
   {
-  planck_assert((ptg.theta>=0)&&(ptg.theta<=pi),"invalid theta value");
   double z = cos (ptg.theta);
   I ir1 = ring_above(z);
   I ir2 = ir1+1;
   double theta1, theta2, w1, tmp, dphi;
   I sp,nr;
   bool shift;
   I i1,i2;
@@ -1268,111 +1197,28 @@
   vb.set_z_phi (1-t1/3, 0);
   return v_angle(va,vb);
   }
 
 template<typename I> double T_Healpix_Base<I>::max_pixrad(I ring) const
   {
   if (ring>=2*nside_) ring=4*nside_-ring;
-  double z=ring2z(ring), z_up=ring2z(ring-1);
+  double z=ring2z(ring), z_up=(ring>1) ? ring2z(ring-1) : 1.;
   vec3 mypos, uppos;
   uppos.set_z_phi(z_up,0);
   if (ring<=nside_)
     {
     mypos.set_z_phi(z,pi/(4*ring));
-    double v1=v_angle(mypos,uppos);
-    if (ring!=1) return v1;
-    uppos.set_z_phi(ring2z(ring+1),pi/(4*(min(nside_,ring+1))));
-    return max(v1,v_angle(mypos,uppos));
+    return v_angle(mypos,uppos);
     }
   mypos.set_z_phi(z,0);
   double vdist=v_angle(mypos,uppos);
   double hdist=sqrt(1.-z*z)*pi/(4*nside_);
   return max(hdist,vdist);
   }
 
-template<typename I> void T_Healpix_Base<I>::xyf2loc (double x, double y,
-  int face, double &z, double &phi, double &sth, bool &have_sth) const
-  {
-  have_sth = false;
-  double jr = jrll[face] - x - y;
-  double nr;
-  if (jr<1)
-    {
-    nr = jr;
-    double tmp = nr*nr/3.;
-    z = 1 - tmp;
-    if (z > 0.99)
-      {
-      sth = std::sqrt(tmp*(2.0-tmp));
-      have_sth = true;
-      }
-    }
-  else if (jr>3)
-    {
-    nr = 4-jr;
-    double tmp = nr*nr/3.;
-    z = tmp - 1;
-    if (z<-0.99)
-      {
-      sth = std::sqrt(tmp*(2.-tmp));
-      have_sth = true;
-      }
-    }
-  else
-    {
-    nr = 1;
-    z = (2-jr)*2./3.;
-    }
-
-  double tmp=jpll[face]*nr+x-y;
-  if (tmp<0) tmp+=8;
-  if (tmp>=8) tmp-=8;
-  phi = (nr<1e-15) ? 0 : (0.5*halfpi*tmp)/nr;
-  }
-
-namespace {
-
-vec3 locToVec3 (double z, double phi, double sth, bool have_sth)
-  {
-  if (have_sth)
-    return vec3(sth*cos(phi),sth*sin(phi),z);
-  else
-    {
-    vec3 res;
-    res.set_z_phi (z, phi);
-    return res;
-    }
-  }
-
-} // unnamed namespace
-
-template<typename I> void T_Healpix_Base<I>::boundaries(I pix, tsize step,
-  vector<vec3> &out) const
-  {
-  out.resize(4*step);
-  int ix, iy, face;
-  pix2xyf(pix, ix, iy, face);
-  double dc = 0.5 / nside_;
-  double xc = (ix + 0.5)/nside_, yc = (iy + 0.5)/nside_;
-  double d = 1.0/(step*nside_);
-  for (tsize i=0; i<step; ++i)
-    {
-    double z, phi, sth;
-    bool have_sth;
-    xyf2loc(xc+dc-i*d, yc+dc, face, z, phi, sth, have_sth);
-    out[i] = locToVec3(z, phi, sth, have_sth);
-    xyf2loc(xc-dc, yc+dc-i*d, face, z, phi, sth, have_sth);
-    out[i+step] = locToVec3(z, phi, sth, have_sth);
-    xyf2loc(xc-dc+i*d, yc-dc, face, z, phi, sth, have_sth);
-    out[i+2*step] = locToVec3(z, phi, sth, have_sth);
-    xyf2loc(xc+dc, yc-dc+i*d, face, z, phi, sth, have_sth);
-    out[i+3*step] = locToVec3(z, phi, sth, have_sth);
-    }
-  }
-
 template<typename I> arr<int> T_Healpix_Base<I>::swap_cycles() const
   {
   planck_assert(order_>=0, "need hierarchical map");
   planck_assert(order_<=13, "map too large");
   arr<int> result(swap_clen[order_]);
   tsize ofs=0;
   for (int m=0; m<order_;++m) ofs+=swap_clen[m];
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_data_io.h` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_data_io.h`

 * *Files 7% similar despite different names*

```diff
@@ -11,15 +11,15 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_powspec_tools.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/alm_powspec_tools.cc`

 * *Files 12% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2003-2015 Max-Planck-Society
+ *  Copyright (C) 2003-2011 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "alm_powspec_tools.h"
 #include "string_utils.h"
 #include "alm.h"
 #include "planck_rng.h"
@@ -53,104 +53,85 @@
     double rms_tt = sqrt(powspec.tt(l));
     double zeta1_r = rng.rand_gauss();
     alm(l,0) = T(zeta1_r * rms_tt);
     for (int m=1; m<=min(l,mmax); ++m)
       {
       zeta1_r = rng.rand_gauss()*hsqrt2;
       double zeta1_i = rng.rand_gauss()*hsqrt2;
-      alm(l,m) = xcomplex<T>(T(zeta1_r*rms_tt), T(zeta1_i*rms_tt));
+      alm(l,m).Set (T(zeta1_r*rms_tt), T(zeta1_i*rms_tt));
       }
     }
   }
 
 template void create_alm (const PowSpec &powspec,
   Alm<xcomplex<float> > &alm, planck_rng &rng);
 template void create_alm (const PowSpec &powspec,
   Alm<xcomplex<double> > &alm, planck_rng &rng);
 
 
 template<typename T> void create_alm_pol
-  (const PowSpec &ps,
+  (const PowSpec &powspec,
    Alm<xcomplex<T> > &almT,
    Alm<xcomplex<T> > &almG,
    Alm<xcomplex<T> > &almC,
    planck_rng &rng)
   {
   int lmax = almT.Lmax();
   int mmax = almT.Mmax();
   const double hsqrt2 = 1/sqrt(2.);
 
-  bool full = ps.Num_specs()==6;
-
   for (int l=0; l<=lmax; ++l)
     {
-    double rms_tt=0, rms_g1=0, rms_c1=0;
-    if (ps.tt(l) > 0)
+    double rms_tt=0, rms_g1=0;
+    if (powspec.tt(l) != 0)
       {
-      rms_tt = sqrt(ps.tt(l));
-      rms_g1 = ps.tg(l)/rms_tt;
-      if (full) rms_c1 = ps.tc(l)/rms_tt;
+      rms_tt = sqrt(powspec.tt(l));
+      rms_g1 = powspec.tg(l)/rms_tt;
       }
 
     double zeta1_r = rng.rand_gauss();
     almT(l,0) = T(zeta1_r * rms_tt);
     almG(l,0) = T(zeta1_r * rms_g1);
-    almC(l,0) = T(zeta1_r * rms_c1);
     for (int m=1; m<=min(l,mmax); ++m)
       {
       zeta1_r = rng.rand_gauss()*hsqrt2;
       double zeta1_i = rng.rand_gauss()*hsqrt2;
-      almT(l,m) = xcomplex<T>(T(zeta1_r*rms_tt), T(zeta1_i*rms_tt));
-      almG(l,m) = xcomplex<T>(T(zeta1_r*rms_g1), T(zeta1_i*rms_g1));
-      almC(l,m) = xcomplex<T>(T(zeta1_r*rms_c1), T(zeta1_i*rms_c1));
+      almT(l,m).Set (T(zeta1_r*rms_tt), T(zeta1_i*rms_tt));
+      almG(l,m).Set (T(zeta1_r*rms_g1), T(zeta1_i*rms_g1));
       }
     }
 
   for (int l=0; l<=lmax; ++l)
     {
-    double rms_g2=0, rms_c2=0, rms_c3=0;
-    if (ps.tt(l) > 0)
+    double rms_g2 = 0;
+    double rms_cc = 0;
+    if (powspec.tt(l) != 0)
       {
-      rms_g2 = ps.gg(l) - (ps.tg(l)/ps.tt(l))*ps.tg(l);
-      if (rms_g2<=0)
+      rms_g2 = powspec.gg(l) - (powspec.tg(l)/powspec.tt(l))*powspec.tg(l);
+      if (rms_g2 <= 0)
         {
-        planck_assert (abs(rms_g2) <= 1e-8*abs(ps.gg(l)),
+        planck_assert (abs(rms_g2) <= 1e-8*abs(powspec.gg(l)),
           "Inconsistent TT, GG and TG spectra at l="+dataToString(l));
         rms_g2 = 0;
         }
-      double rms_c1 = full ? (ps.tc(l) / sqrt(ps.tt(l))) : 0.;
-      if (rms_g2>0)
-        {
-        rms_g2 = sqrt(rms_g2);
-        if (full) rms_c2 = (ps.gc(l) - ps.tc(l) * (ps.tg(l)/ps.tt(l))) / rms_g2;
-        }
-      rms_c3 = ps.cc(l) - rms_c1*rms_c1 - rms_c2*rms_c2; 
-      if (rms_c3<=0)
-        {
-        planck_assert (abs(rms_c3) <= 1e-8*abs(ps.cc(l)),
-          "Inconsistent spectra at l="+dataToString(l));
-        rms_c3 = 0;
-        }
-      rms_c3 = sqrt(rms_c3);
+      rms_g2 = sqrt(rms_g2);
+      rms_cc = sqrt(powspec.cc(l));
       }
-    double zeta2_r = rng.rand_gauss();
-    double zeta3_r = rng.rand_gauss();
-    almG(l,0) += T(zeta2_r*rms_g2);
-    almC(l,0) += T(zeta3_r*rms_c3 + zeta2_r*rms_c2);
+    almG(l,0) += T(rng.rand_gauss()*rms_g2);
+    almC(l,0)  = T(rng.rand_gauss()*rms_cc);
 
     for (int m=1; m<=min(l,mmax); ++m)
       {
-      zeta2_r = rng.rand_gauss()*hsqrt2;
+      double zeta2_r = rng.rand_gauss()*hsqrt2;
       double zeta2_i = rng.rand_gauss()*hsqrt2;
-      zeta3_r = rng.rand_gauss()*hsqrt2;
+      double zeta3_r = rng.rand_gauss()*hsqrt2;
       double zeta3_i = rng.rand_gauss()*hsqrt2;
 
       almG(l,m) += xcomplex<T> (T(zeta2_r*rms_g2),T(zeta2_i*rms_g2));
-      almC(l,m) += xcomplex<T> (T(zeta3_r*rms_c3),T(zeta3_i*rms_c3))
-                  +xcomplex<T> (T(zeta2_r*rms_c2),T(zeta2_i*rms_c2));
+      almC(l,m).Set (T(zeta3_r*rms_cc),T(zeta3_i*rms_cc));
       }
     }
   }
 
 template void create_alm_pol
   (const PowSpec &powspec,
    Alm<xcomplex<float> > &almT,
@@ -169,19 +150,18 @@
   (const Alm<xcomplex<T> > &alm1,
    const Alm<xcomplex<T> > &alm2,PowSpec &powspec)
   {
   planck_assert (alm1.conformable(alm2), "a_lm are not conformable");
   arr<double> tt(alm1.Lmax()+1);
   for (int l=0; l<=alm1.Lmax(); ++l)
     {
-    tt[l] = alm1(l,0).real()*alm2(l,0).real();
+    tt[l] = alm1(l,0).re*alm2(l,0).re;
     int limit = min(l,alm1.Mmax());
     for (int m=1; m<=limit; ++m)
-      tt[l] += 2 * (alm1(l,m).real()*alm2(l,m).real()
-                  + alm1(l,m).imag()*alm2(l,m).imag());
+      tt[l] += 2 * (alm1(l,m).re*alm2(l,m).re + alm1(l,m).im*alm2(l,m).im);
     tt[l] /= (2*l+1);
     }
   powspec.Set(tt);
   }
 
 template void extract_crosspowspec
   (const Alm<xcomplex<float> > &alm1,
@@ -216,35 +196,29 @@
                  almT1.conformable(almC2), "a_lm are not conformable");
 
   int lmax = almT1.Lmax();
   arr<double> tt(lmax+1), gg(lmax+1), cc(lmax+1), tg(lmax+1),
               tc(lmax+1), gc(lmax+1);
   for (int l=0; l<=lmax; ++l)
     {
-    tt[l] = almT1(l,0).real()*almT2(l,0).real();
-    gg[l] = almG1(l,0).real()*almG2(l,0).real();
-    cc[l] = almC1(l,0).real()*almC2(l,0).real();
-    tg[l] = almT1(l,0).real()*almG2(l,0).real();
-    tc[l] = almT1(l,0).real()*almC2(l,0).real();
-    gc[l] = almG1(l,0).real()*almC2(l,0).real();
+    tt[l] = almT1(l,0).re*almT2(l,0).re;
+    gg[l] = almG1(l,0).re*almG2(l,0).re;
+    cc[l] = almC1(l,0).re*almC2(l,0).re;
+    tg[l] = almT1(l,0).re*almG2(l,0).re;
+    tc[l] = almT1(l,0).re*almC2(l,0).re;
+    gc[l] = almG1(l,0).re*almC2(l,0).re;
     int limit = min(l,almT1.Mmax());
     for (int m=1; m<=limit; ++m)
       {
-      tt[l] += 2 * (almT1(l,m).real()*almT2(l,m).real()
-                  + almT1(l,m).imag()*almT2(l,m).imag());
-      gg[l] += 2 * (almG1(l,m).real()*almG2(l,m).real()
-                  + almG1(l,m).imag()*almG2(l,m).imag());
-      cc[l] += 2 * (almC1(l,m).real()*almC2(l,m).real()
-                  + almC1(l,m).imag()*almC2(l,m).imag());
-      tg[l] += 2 * (almT1(l,m).real()*almG2(l,m).real()
-                  + almT1(l,m).imag()*almG2(l,m).imag());
-      tc[l] += 2 * (almT1(l,m).real()*almC2(l,m).real()
-                  + almT1(l,m).imag()*almC2(l,m).imag());
-      gc[l] += 2 * (almG1(l,m).real()*almC2(l,m).real()
-                  + almG1(l,m).imag()*almC2(l,m).imag());
+      tt[l] += 2 * (almT1(l,m).re*almT2(l,m).re + almT1(l,m).im*almT2(l,m).im);
+      gg[l] += 2 * (almG1(l,m).re*almG2(l,m).re + almG1(l,m).im*almG2(l,m).im);
+      cc[l] += 2 * (almC1(l,m).re*almC2(l,m).re + almC1(l,m).im*almC2(l,m).im);
+      tg[l] += 2 * (almT1(l,m).re*almG2(l,m).re + almT1(l,m).im*almG2(l,m).im);
+      tc[l] += 2 * (almT1(l,m).re*almC2(l,m).re + almT1(l,m).im*almC2(l,m).im);
+      gc[l] += 2 * (almG1(l,m).re*almC2(l,m).re + almG1(l,m).im*almC2(l,m).im);
       }
     tt[l] /= (2*l+1);
     gg[l] /= (2*l+1);
     cc[l] /= (2*l+1);
     tg[l] /= (2*l+1);
     tc[l] /= (2*l+1);
     gc[l] /= (2*l+1);
@@ -304,35 +278,14 @@
     gb[l] = exp(-.5*fct*l*(l+1)*sigma*sigma);
   almT.ScaleL(gb);
   for (int l=0; l<=almT.Lmax(); ++l)
     gb[l] *= fact_pol;
   almG.ScaleL(gb); almC.ScaleL(gb);
   }
 
-template<typename T> void applyCosineWindow
-  (Alm<xcomplex<T> > &alm, int lmin, int lmax)
-  {
-  planck_assert((lmin>=0)&&(lmax>lmin),"bad lmin/lmax");
-  arr<double> cw(alm.Lmax()+1);
-  for (int i=0; i<int(cw.size()); ++i)
-  if (i<lmin)
-    cw[i]=1;
-  else if (i<lmax)
-    cw[i]=(1+cos(pi*(i-lmin)/double(lmax-lmin)))/2;
-  else
-    cw[i]=0;
-
-  alm.ScaleL(cw);
-  }
-
-template void applyCosineWindow
-  (Alm<xcomplex<float> > &alm, int lmin, int lmax);
-template void applyCosineWindow
-  (Alm<xcomplex<double> > &alm, int lmin, int lmax);
-
 template void smoothWithGauss
   (Alm<xcomplex<float> > &almT,
    Alm<xcomplex<float> > &almG,
    Alm<xcomplex<float> > &almC,
    double fwhm);
 template void smoothWithGauss
   (Alm<xcomplex<double> > &almT,
@@ -345,16 +298,16 @@
   {
   planck_assert (alm.Lmax()==alm.Mmax(),
     "rotate_alm: lmax must be equal to mmax");
   int lmax=alm.Lmax();
   arr<xcomplex<double> > exppsi(lmax+1), expphi(lmax+1);
   for (int m=0; m<=lmax; ++m)
     {
-    exppsi[m] = dcomplex(cos(psi*m),-sin(psi*m));
-    expphi[m] = dcomplex(cos(phi*m),-sin(phi*m));
+    exppsi[m].Set (cos(psi*m),-sin(psi*m));
+    expphi[m].Set (cos(phi*m),-sin(phi*m));
     }
 
   wigner_d_risbo_openmp rec(lmax,theta);
 
   arr<xcomplex<double> > almtmp(lmax+1);
 
   for (int l=0; l<=lmax; ++l)
@@ -368,22 +321,22 @@
 {
     int64 lo,hi;
     openmp_calc_share(0,l+1,lo,hi);
 
     bool flip = true;
     for (int mm=1; mm<=l; ++mm)
       {
-      dcomplex t1 = dcomplex(alm(l,mm))*exppsi[mm];
+      xcomplex<double> t1 = xcomplex<double>(alm(l,mm))*exppsi[mm];
       bool flip2 = ((mm+lo)&1) ? true : false;
       for (int m=lo; m<hi; ++m)
         {
         double d1 = flip2 ? -d[l-mm][l-m] : d[l-mm][l-m];
         double d2 = flip  ? -d[l-mm][l+m] : d[l-mm][l+m];
         double f1 = d1+d2, f2 = d1-d2;
-        almtmp[m]+=dcomplex(t1.real()*f1,t1.imag()*f2);
+        almtmp[m].re += t1.re*f1; almtmp[m].im += t1.im*f2;
         flip2 = !flip2;
         }
       flip = !flip;
       }
 }
 
     for (int m=0; m<=l; ++m)
@@ -404,16 +357,16 @@
     "rotate_alm: lmax must be equal to mmax");
   planck_assert (almG.conformable(almT) && almC.conformable(almT),
     "rotate_alm: a_lm are not conformable");
   int lmax=almT.Lmax();
   arr<xcomplex<double> > exppsi(lmax+1), expphi(lmax+1);
   for (int m=0; m<=lmax; ++m)
     {
-    exppsi[m] = dcomplex(cos(psi*m),-sin(psi*m));
-    expphi[m] = dcomplex(cos(phi*m),-sin(phi*m));
+    exppsi[m].Set (cos(psi*m),-sin(psi*m));
+    expphi[m].Set (cos(phi*m),-sin(phi*m));
     }
 
   wigner_d_risbo_openmp rec(lmax,theta);
 
   arr<xcomplex<double> > almtmpT(lmax+1), almtmpG(lmax+1), almtmpC(lmax+1);
 
   for (int l=0; l<=lmax; ++l)
@@ -431,26 +384,26 @@
 {
     int64 lo,hi;
     openmp_calc_share(0,l+1,lo,hi);
 
     bool flip = true;
     for (int mm=1; mm<=l; ++mm)
       {
-      dcomplex t1T = dcomplex(almT(l,mm))*exppsi[mm];
-      dcomplex t1G = dcomplex(almG(l,mm))*exppsi[mm];
-      dcomplex t1C = dcomplex(almC(l,mm))*exppsi[mm];
+      xcomplex<double> t1T = xcomplex<double>(almT(l,mm))*exppsi[mm];
+      xcomplex<double> t1G = xcomplex<double>(almG(l,mm))*exppsi[mm];
+      xcomplex<double> t1C = xcomplex<double>(almC(l,mm))*exppsi[mm];
       bool flip2 = ((mm+lo)&1) ? true : false;
       for (int m=lo; m<hi; ++m)
         {
         double d1 = flip2 ? -d[l-mm][l-m] : d[l-mm][l-m];
         double d2 = flip  ? -d[l-mm][l+m] : d[l-mm][l+m];
         double f1 = d1+d2, f2 = d1-d2;
-        almtmpT[m]+=dcomplex(t1T.real()*f1,t1T.imag()*f2);
-        almtmpG[m]+=dcomplex(t1G.real()*f1,t1G.imag()*f2);
-        almtmpC[m]+=dcomplex(t1C.real()*f1,t1C.imag()*f2);
+        almtmpT[m].re += t1T.re*f1; almtmpT[m].im += t1T.im*f2;
+        almtmpG[m].re += t1G.re*f1; almtmpG[m].im += t1G.im*f2;
+        almtmpC[m].re += t1C.re*f1; almtmpC[m].im += t1C.im*f2;
         flip2 = !flip2;
         }
       flip = !flip;
       }
 }
 
     for (int m=0; m<=l; ++m)
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/powspec.h` & `healpy-github-devel/hpbeta/Healpix_cxx/powspec.h`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_data_io.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_data_io.cc`

 * *Files 5% similar despite different names*

```diff
@@ -11,15 +11,15 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm_powspec_tools.h` & `healpy-github-devel/hpbeta/Healpix_cxx/alm_powspec_tools.h`

 * *Files 6% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file alm_powspec_tools.h
- *  Copyright (C) 2003-2014 Max-Planck-Society
+ *  Copyright (C) 2003, 2004, 2005 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef PLANCK_ALM_POWSPEC_TOOLS_H
 #define PLANCK_ALM_POWSPEC_TOOLS_H
 
 #include "xcomplex.h"
@@ -87,29 +87,14 @@
     \relates Alm */
 template<typename T> void smoothWithGauss
   (Alm<xcomplex<T> > &almT,
    Alm<xcomplex<T> > &almG,
    Alm<xcomplex<T> > &almC,
    double fwhm);
 
-/*! Applies a function to \a alm that is 1 for all \c l<=lmin, 0 for all
-    \c l>=lmax, and \c 0.5*(1+cos((l-lmin)/(lmax-lmin)*pi)) in between.
-    \relates Alm  */
-template<typename T> void applyCosineWindow
-  (Alm<xcomplex<T> > &alm, int lmin, int lmax);
-
-template<typename T> inline void applyCosineWindow
-  (Alm<xcomplex<T> > &almT, Alm<xcomplex<T> > &almG, Alm<xcomplex<T> > &almC,
-  int lmin, int lmax)
-  {
-  applyCosineWindow(almT,lmin,lmax);
-  applyCosineWindow(almG,lmin,lmax);
-  applyCosineWindow(almC,lmin,lmax);
-  }
-
 /*! Rotates \a alm through the Euler angles \a psi, \a theta and \a phi.
     The Euler angle convention  is right handed, rotations are active.
     - \a psi is the first rotation about the z-axis (vertical)
     - then \a theta about the ORIGINAL (unrotated) y-axis
     - then \a phi  about the ORIGINAL (unrotated) z-axis (vertical)
     \relates Alm */
 template<typename T> void rotate_alm (Alm<xcomplex<T> > &alm,
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_map.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_map.cc`

 * *Files 4% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2003-2013 Max-Planck-Society
+ *  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Max-Planck-Society
  *  Author: Martin Reinecke
  */
 
 #include "healpix_map.h"
 
 using namespace std;
 
@@ -37,36 +37,36 @@
   (const Healpix_Map<T> &orig, bool pessimistic)
   {
   planck_assert(nside_<orig.nside_,"Import_degrade: this is no degrade");
   int fact = orig.nside_/nside_;
   planck_assert (orig.nside_==nside_*fact,
     "the larger Nside must be a multiple of the smaller one");
 
-  int minhits = pessimistic ? fact*fact : 1;
+  int minhits = pessimistic ? fact : 1;
 #pragma omp parallel
 {
   int m;
 #pragma omp for schedule (static)
   for (m=0; m<npix_; ++m)
     {
     int x,y,f;
     pix2xyf(m,x,y,f);
     int hits = 0;
-    kahan_adder<double> adder;
+    double sum = 0;
     for (int j=fact*y; j<fact*(y+1); ++j)
       for (int i=fact*x; i<fact*(x+1); ++i)
         {
         int opix = orig.xyf2pix(i,j,f);
         if (!approx<double>(orig.map[opix],Healpix_undef))
           {
           ++hits;
-          adder.add(orig.map[opix]);
+          sum += orig.map[opix];
           }
         }
-    map[m] = T((hits<minhits) ? Healpix_undef : adder.result()/hits);
+    map[m] = T((hits<minhits) ? Healpix_undef : sum/hits);
     }
 }
   }
 
 template void Healpix_Map<float>::Import_degrade
   (const Healpix_Map<float> &orig, bool pessimistic);
 template void Healpix_Map<double>::Import_degrade
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/healpix_tables.h` & `healpy-github-devel/hpbeta/Healpix_cxx/healpix_tables.h`

 * *Files 6% similar despite different names*

```diff
@@ -11,25 +11,25 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*! \file healpix_tables.h
- *  Copyright (C) 2011-2014 Max-Planck-Society
+ *  Copyright (C) 2011 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #ifndef HEALPIX_TABLES_H
 #define HEALPIX_TABLES_H
 
 #include "datatypes.h"
@@ -47,16 +47,16 @@
 class Healpix_Tables
   {
   protected:
     static const uint16 ctab[], utab[];
 
     static const int jrll[], jpll[];
 
-    static const uint8 peano_face2path[2][12], peano_face2face[2][12],
-                       peano_arr[],peano_arr2[];
+    static const uint8 peano_subpix[2][8][4], peano_subpath[2][8][4],
+                       peano_face2path[2][12], peano_face2face[2][12];
 
     static const int nb_xoffset[], nb_yoffset[],
                      nb_facearray[][12], nb_swaparray[][3];
 
     static const int swap_clen[], swap_cycle[];
   };
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/alm.cc` & `healpy-github-devel/hpbeta/Healpix_cxx/alm.cc`

 * *Files 2% similar despite different names*

```diff
@@ -11,15 +11,15 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Healpix_cxx; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- *  For more information about HEALPix, see http://healpix.sourceforge.net
+ *  For more information about HEALPix, see http://healpix.jpl.nasa.gov
  */
 
 /*
  *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/Healpix_cxx/Healpix_cxx.dox` & `healpy-github-devel/hpbeta/Healpix_cxx/Healpix_cxx.dox`

 * *Files 12% similar despite different names*

```diff
@@ -1,11 +1,10 @@
 /*! \mainpage HEALPix C++ documentation
   <ul>
   <li>\ref components "Programming interface"
-  <li>\ref uselib "How to use the library in your own codes"
   <li>\ref facilities "Facilities"
   </ul>
  */
 
 /*! \page components Code components
 
   Classes:
@@ -25,26 +24,14 @@
 
   FITS I/O:
    - for \ref healpix_map_fitsio_group "HEALPix Maps"
    - for \ref alm_fitsio_group "spherical harmonic coefficients"
    - for \ref powspec_fitsio_group "power spectra"
 */
 
-/*! \page uselib Using Healpix C++ in your own codes
-
-  In order to use the Healpix library in your own C++ codes, you have to do two
-  things:
-   - \c #include the appropriate header files in your sources. From this
-     documentation it should be evident which ones you have to include for a
-     specific task.
-   - Specify the required libraries when linking your executable. For this
-     release of the software, this should be (order is important!):
-     \verbatim-lhealpix_cxx -lcxxsupport -lsharp -lfftpack -lc_utils -lcfitsio\endverbatim
-*/
-
 /*! \page facilities HEALPix C++ facilities
 
   \section syn_alm_cxx
     This program reads a set of \f$C_l\f$ from disk and converts it to
     a set of \f$a_{lm}\f$.
 
     \verbinclude syn_alm_cxx.par.txt
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/README` & `healpy-github-devel/hpbeta/libfftpack/README`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/bluestein.c` & `healpy-github-devel/hpbeta/libfftpack/bluestein.c`

 * *Files 2% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 /*
  *  libfftpack is being developed at the Max-Planck-Institut fuer Astrophysik
  *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt
  *  (DLR).
  */
 
 /*
- *  Copyright (C) 2005-2008 Max-Planck-Society
+ *  Copyright (C) 2005, 2006, 2007, 2008 Max-Planck-Society
  *  \author Martin Reinecke
  */
 
 #include <math.h>
 #include <stdlib.h>
 #include "fftpack.h"
 #include "bluestein.h"
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/fftpack_inc.c` & `healpy-github-devel/hpbeta/libfftpack/fftpack_inc.c`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/ls_fft.h` & `healpy-github-devel/hpbeta/libfftpack/ls_fft.h`

 * *Files 1% similar despite different names*

```diff
@@ -118,15 +118,15 @@
 void kill_real_plan (real_plan plan);
 /*! Computes a real forward FFT on \a data, using \a plan
     and assuming the FFTPACK storage scheme:
     - on entry, \a data has the form <tt>r0, r1, ..., r[length-1]</tt>;
     - on exit, it has the form <tt>r0, r1, i1, r2, i2, ...</tt>
       (a total of \a length values). */
 void real_plan_forward_fftpack (real_plan plan, double *data);
-/*! Computes a real backward FFT on \a data, using \a plan
+/*! Computes a real forward FFT on \a data, using \a plan
     and assuming the FFTPACK storage scheme:
     - on entry, \a data has the form <tt>r0, r1, i1, r2, i2, ...</tt>
     (a total of \a length values);
     - on exit, it has the form <tt>r0, r1, ..., r[length-1]</tt>. */
 void real_plan_backward_fftpack (real_plan plan, double *data);
 /*! Computes a real forward FFT on \a data, using \a plan
     and assuming the FFTW halfcomplex storage scheme:
@@ -139,15 +139,16 @@
     - on exit, it has the form <tt>r0, r1, ..., r[length-1]</tt>. */
 void real_plan_backward_fftw (real_plan plan, double *data);
 /*! Computes a real forward FFT on \a data, using \a plan
     and assuming a full-complex storage scheme:
     - on entry, \a data has the form <tt>r0, [ignored], r1, [ignored], ...,
       r[length-1], [ignored]</tt>;
     - on exit, it has the form <tt>r0, i0, r1, i1, ...,
-      r[length-1], i[length-1]</tt>. */
+      r[length-1], i[length-1]</tt>.
+    */
 void real_plan_forward_c (real_plan plan, double *data);
 /*! Computes a real backward FFT on \a data, using \a plan
     and assuming a full-complex storage scheme:
     - on entry, \a data has the form <tt>r0, i0, r1, i1, ...,
       r[length-1], i[length-1]</tt>;
     - on exit, it has the form <tt>r0, 0, r1, 0, ..., r[length-1], 0</tt>. */
 void real_plan_backward_c (real_plan plan, double *data);
```

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/fftpack.c` & `healpy-github-devel/hpbeta/libfftpack/fftpack.c`

 * *Files identical despite different names*

### Comparing `healpy-1.9.1/healpixsubmodule/src/cxx/autotools/libfftpack/ls_fft.c` & `healpy-github-devel/hpbeta/libfftpack/ls_fft.c`

 * *Files identical despite different names*

